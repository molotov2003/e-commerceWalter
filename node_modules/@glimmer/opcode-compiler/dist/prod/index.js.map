{"version":3,"file":"index.js","sources":["../../../local-debug-flags/index.ts","../../lib/compiler.ts","../../lib/opcode-builder/helpers/resolution.ts","../../lib/opcode-builder/opcodes.ts","../../lib/opcode-builder/operands.ts","../../lib/opcode-builder/encoder.ts","../../lib/compilable-template.ts","../../lib/opcode-builder/stdlib.ts","../../lib/utils.ts","../../lib/opcode-builder/helpers/vm.ts","../../lib/syntax/compilers.ts","../../lib/syntax/expressions.ts","../../lib/opcode-builder/helpers/expr.ts","../../lib/opcode-builder/helpers/shared.ts","../../lib/opcode-builder/helpers/blocks.ts","../../lib/opcode-builder/helpers/conditional.ts","../../lib/opcode-builder/helpers/components.ts","../../lib/opcode-builder/helpers/stdlib.ts","../../lib/program-context.ts","../../lib/opcode-builder/context.ts","../../lib/syntax/statements.ts","../../lib/opcode-builder/delegate.ts","../../lib/wrapped-component.ts","../../lib/template.ts"],"sourcesContent":["\n\nexport const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import { debugSlice } from '@glimmer/debug';\nimport type { HandleResult, TemplateCompilationContext } from \"@glimmer/interfaces\";\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { extractHandle } from '@glimmer/util';\n\nexport let debugCompiler: (context: TemplateCompilationContext, handle: HandleResult) => void;\n\nif (LOCAL_SHOULD_LOG) {\n  debugCompiler = (context: TemplateCompilationContext, result: HandleResult) => {\n    let handle = extractHandle(result);\n    let { heap } = context.program;\n    let start = heap.getaddr(handle);\n    let end = start + heap.sizeof(handle);\n\n    debugSlice(context, start, end);\n  };\n}\n","import type {\n  CompileTimeConstants,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Expressions,\n  Owner,\n  ResolutionTimeConstants,\n  ResolveComponentOp,\n  ResolveComponentOrHelperOp,\n  ResolveHelperOp,\n  ResolveModifierOp,\n  ResolveOptionalComponentOrHelperOp,\n  ResolveOptionalHelperOp,\n  SexpOpcode,\n} from \"@glimmer/interfaces\";\nimport { assert, debugToString, expect, unwrap } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nfunction isGetLikeTuple(opcode: Expressions.Expression): opcode is Expressions.TupleExpression {\n  return Array.isArray(opcode) && opcode.length === 2;\n}\n\nfunction makeResolutionTypeVerifier(typeToVerify: SexpOpcode) {\n  return (\n    opcode: Expressions.Expression\n  ): opcode is Expressions.GetFree | Expressions.GetLexicalSymbol => {\n    if (!isGetLikeTuple(opcode)) return false;\n\n    let type = opcode[0];\n\n    return (\n      type === SexpOpcodes.GetStrictKeyword ||\n      type === SexpOpcodes.GetLexicalSymbol ||\n      type === typeToVerify\n    );\n  };\n}\n\nexport const isGetFreeComponent = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentHead);\n\nexport const isGetFreeModifier = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsModifierHead);\n\nexport const isGetFreeHelper = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsHelperHead);\n\nexport const isGetFreeComponentOrHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsComponentOrHelperHead\n);\n\nexport const isGetFreeOptionalHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsHelperHeadOrThisFallback\n);\n\nexport function isGetFreeDeprecatedHelper(\n  opcode: Expressions.Expression\n): opcode is Expressions.GetPathFreeAsDeprecatedHelperHeadOrThisFallback {\n  return (\n    Array.isArray(opcode) && opcode[0] === SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback\n  );\n}\n\nexport const isGetFreeOptionalComponentOrHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback\n);\n\ninterface ResolvedContainingMetadata extends ContainingMetadata {\n  owner: Owner;\n  upvars: string[];\n}\n\nfunction assertResolverInvariants(meta: ContainingMetadata): ResolvedContainingMetadata {\n  if (import.meta.env.DEV) {\n    if (!meta.upvars) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no free vars were found'\n      );\n    }\n\n    if (!meta.owner) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from'\n      );\n    }\n  }\n\n  return meta as unknown as ResolvedContainingMetadata;\n}\n\n/**\n * <Foo/>\n * <Foo></Foo>\n * <Foo @arg={{true}} />\n */\nexport function resolveComponent(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveComponentOp\n): void {\n  assert(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode');\n\n  let type = expr[0];\n\n  if (import.meta.env.DEV && expr[0] === SexpOpcodes.GetStrictKeyword) {\n    throw new Error(\n      `Attempted to resolve a component in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(\n      constants.component(\n        definition as object,\n        expect(owner, 'BUG: expected owner when resolving component definition')\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner)!;\n\n    if (import.meta.env.DEV && (typeof definition !== 'object' || definition === null)) {\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`\n      );\n    }\n\n    then(constants.resolvedComponent(definition, name));\n  }\n}\n\n/**\n * (helper)\n * (helper arg)\n */\nexport function resolveHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveHelperOp\n): void {\n  assert(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.helper(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    then(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'helper')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let helper = resolver.lookupHelper(name, owner)!;\n\n    if (import.meta.env.DEV && helper === null) {\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a helper, but nothing was found.`\n      );\n    }\n\n    then(constants.helper(helper, name));\n  }\n}\n\n/**\n * <div {{modifier}}/>\n * <div {{modifier arg}}/>\n * <Foo {{modifier}}/>\n */\nexport function resolveModifier(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveModifierOp\n): void {\n  assert(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.modifier(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    let { upvars } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupBuiltInModifier(name);\n\n    if (import.meta.env.DEV && modifier === null) {\n      throw new Error(\n        `Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`\n      );\n    }\n\n    then(constants.modifier(modifier!, name));\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupModifier(name, owner)!;\n\n    if (import.meta.env.DEV && modifier === null) {\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a modifier, but nothing was found.`\n      );\n    }\n\n    then(constants.modifier(modifier, name));\n  }\n}\n\n/**\n * {{component-or-helper arg}}\n */\nexport function resolveComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper }]: ResolveComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve a component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    let component = constants.component(\n      definition as object,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition as object, null, true);\n\n    if (import.meta.env.DEV && helper === null) {\n      throw new Error(\n        `Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n\n    ifHelper(expect(helper, 'BUG: helper must exist'));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(\n        expr as Expressions.GetStrictFree,\n        resolver,\n        meta,\n        constants,\n        'component or helper'\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n    } else {\n      let helper = resolver.lookupHelper(name, owner);\n\n      if (import.meta.env.DEV && helper === null) {\n        throw new Error(\n          `Attempted to resolve \\`${name}\\`, which was expected to be a component or helper, but nothing was found.`\n        );\n      }\n\n      ifHelper(constants.helper(helper!, name));\n    }\n  }\n}\n\n/**\n * <Foo @arg={{helper}}>\n */\nexport function resolveOptionalHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifHelper }]: ResolveOptionalHelperOp\n): void {\n  assert(\n    isGetFreeOptionalHelper(expr) || isGetFreeDeprecatedHelper(expr),\n    'Attempted to resolve a helper with incorrect opcode'\n  );\n  let { upvars, owner } = assertResolverInvariants(meta);\n\n  let name = unwrap(upvars[expr[1]]);\n  let helper = resolver.lookupHelper(name, owner);\n\n  if (helper) {\n    ifHelper(constants.helper(helper, name), name, meta.moduleName);\n  }\n}\n\n/**\n * {{maybeHelperOrComponent}}\n */\nexport function resolveOptionalComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper, ifValue }]: ResolveOptionalComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeOptionalComponentOrHelper(expr),\n    'Attempted to resolve an optional component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    if (\n      typeof definition !== 'function' &&\n      (typeof definition !== 'object' || definition === null)\n    ) {\n      // The value is not an object, so it can't be a component or helper.\n      ifValue(constants.value(definition));\n      return;\n    }\n\n    let component = constants.component(\n      definition,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition, null, true);\n\n    if (helper !== null) {\n      ifHelper(helper);\n      return;\n    }\n\n    ifValue(constants.value(definition));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'value')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n      return;\n    }\n\n    let helper = resolver.lookupHelper(name, owner);\n\n    if (helper !== null) {\n      ifHelper(constants.helper(helper, name));\n    }\n  }\n}\n\nfunction lookupBuiltInHelper(\n  expr: Expressions.GetStrictFree,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  constants: ResolutionTimeConstants,\n  type: string\n): number {\n  let { upvars } = assertResolverInvariants(meta);\n\n  let name = unwrap(upvars[expr[1]]);\n  let helper = resolver.lookupBuiltInHelper(name);\n\n  if (import.meta.env.DEV && helper === null) {\n    // Keyword helper did not exist, which means that we're attempting to use a\n    // value of some kind that is not in scope\n    throw new Error(\n      `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  return constants.helper(helper!, name);\n}\n","import type {\n  HighLevelEnd,\n  HighLevelLabel,\n  HighLevelResolveComponent,\n  HighLevelResolveComponentOrHelper,\n  HighLevelResolveFree,\n  HighLevelResolveHelper,\n  HighLevelResolveLocal,\n  HighLevelResolveModifier,\n  HighLevelResolveOptionalComponentOrHelper,\n  HighLevelResolveOptionalHelper,\n  HighLevelResolveTemplateLocal,\n  HighLevelStart,\n  HighLevelStartLabels,\n  HighLevelStopLabels,\n} from \"@glimmer/interfaces\";\n\nexport const HighLevelResolutionOpcodes = {\n  Modifier: 1003 satisfies HighLevelResolveModifier,\n  Component: 1004 satisfies HighLevelResolveComponent,\n  Helper: 1005 satisfies HighLevelResolveHelper,\n  OptionalHelper: 1006 satisfies HighLevelResolveOptionalHelper,\n  ComponentOrHelper: 1007 satisfies HighLevelResolveComponentOrHelper,\n  OptionalComponentOrHelper: 1008 satisfies HighLevelResolveOptionalComponentOrHelper,\n  Free: 1009 satisfies HighLevelResolveFree,\n  Local: 1010 satisfies HighLevelResolveLocal,\n  TemplateLocal: 1011 satisfies HighLevelResolveTemplateLocal,\n} as const;\n\nexport const HighLevelBuilderOpcodes = {\n  Label: 1000 satisfies HighLevelLabel,\n  StartLabels: 1001 satisfies HighLevelStartLabels,\n  StopLabels: 1002 satisfies HighLevelStopLabels,\n  Start: 1000 satisfies HighLevelStart,\n  End: 1002 satisfies HighLevelEnd,\n} as const;\n","import type {\n  BlockOperand,\n  BlockOperandType,\n  CompilableTemplate,\n  DebugSymbolsOperand,\n  DebugSymbolsOperandType,\n  IsStrictModeOperand,\n  IsStrictModeOperandType,\n  LabelOperand,\n  LabelOperandType,\n  LayoutOperand,\n  LayoutOperandType,\n  NonSmallIntOperand,\n  NonSmallIntOperandType,\n  SerializedBlock,\n  SerializedInlineBlock,\n  StdLibOperand,\n  StdLibOperandType,\n  SymbolTable,\n  SymbolTableOperand,\n  SymbolTableOperandType,\n} from \"@glimmer/interfaces\";\nimport { assert, isSmallInt } from '@glimmer/util';\n\nexport const HighLevelOperands = {\n  Label: 1 satisfies LabelOperandType,\n  IsStrictMode: 2 satisfies IsStrictModeOperandType,\n  DebugSymbols: 3 satisfies DebugSymbolsOperandType,\n  Block: 4 satisfies BlockOperandType,\n  StdLib: 5 satisfies StdLibOperandType,\n  NonSmallInt: 6 satisfies NonSmallIntOperandType,\n  SymbolTable: 7 satisfies SymbolTableOperandType,\n  Layout: 8 satisfies LayoutOperandType,\n} as const;\n\nexport function labelOperand(value: string): LabelOperand {\n  return { type: HighLevelOperands.Label, value };\n}\n\nexport function debugSymbolsOperand(): DebugSymbolsOperand {\n  return { type: HighLevelOperands.DebugSymbols, value: undefined };\n}\n\nexport function isStrictMode(): IsStrictModeOperand {\n  return { type: HighLevelOperands.IsStrictMode, value: undefined };\n}\n\nexport function blockOperand(value: SerializedInlineBlock | SerializedBlock): BlockOperand {\n  return { type: HighLevelOperands.Block, value };\n}\n\nexport function stdlibOperand(\n  value:\n    | 'main'\n    | 'trusting-append'\n    | 'cautious-append'\n    | 'trusting-non-dynamic-append'\n    | 'cautious-non-dynamic-append'\n): StdLibOperand {\n  return { type: HighLevelOperands.StdLib, value };\n}\n\nexport function nonSmallIntOperand(value: number): NonSmallIntOperand {\n  assert(\n    !isSmallInt(value),\n    'Attempted to make a operand for an int that was not a small int, you should encode this as an immediate'\n  );\n  return { type: HighLevelOperands.NonSmallInt, value };\n}\n\nexport function symbolTableOperand(value: SymbolTable): SymbolTableOperand {\n  return { type: HighLevelOperands.SymbolTable, value };\n}\n\nexport function layoutOperand(value: CompilableTemplate): LayoutOperand {\n  return { type: HighLevelOperands.Layout, value };\n}\n","import { InstructionEncoderImpl } from '@glimmer/encoder';\nimport type {\n  BuilderOp,\n  BuilderOpcode,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Dict,\n  Encoder,\n  EncoderError,\n  HandleResult,\n  HighLevelOp,\n  InstructionEncoder,\n  Operand,\n  ResolutionTimeConstants,\n  SingleBuilderOperand,\n  STDLib,\n} from '@glimmer/interfaces';\nimport {\n  assert,\n  dict,\n  EMPTY_STRING_ARRAY,\n  encodeHandle,\n  expect,\n  isPresentArray,\n  Stack,\n} from '@glimmer/util';\nimport { ARG_SHIFT, isMachineOp, MACHINE_MASK, MachineOp, Op, TYPE_SIZE } from '@glimmer/vm';\n\nimport { compilableBlock } from '../compilable-template';\nimport {\n  resolveComponent,\n  resolveComponentOrHelper,\n  resolveHelper,\n  resolveModifier,\n  resolveOptionalComponentOrHelper,\n  resolveOptionalHelper,\n} from './helpers/resolution';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from './opcodes';\nimport { HighLevelOperands } from './operands';\n\nexport class Labels {\n  labels: Dict<number> = dict();\n  targets: Array<{ at: number; target: string }> = [];\n\n  label(name: string, index: number) {\n    this.labels[name] = index;\n  }\n\n  target(at: number, target: string) {\n    this.targets.push({ at, target });\n  }\n\n  patch(heap: CompileTimeHeap): void {\n    let { targets, labels } = this;\n\n    for (const { at, target } of targets) {\n      let address = labels[target]! - at;\n\n      assert(heap.getbyaddr(at) === -1, 'Expected heap to contain a placeholder, but it did not');\n\n      heap.setbyaddr(at, address);\n    }\n  }\n}\n\nexport function encodeOp(\n  encoder: Encoder,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  op: BuilderOp | HighLevelOp\n): void {\n  if (isBuilderOpcode(op[0])) {\n    let [type, ...operands] = op;\n    encoder.push(constants, type, ...(operands as SingleBuilderOperand[]));\n  } else {\n    switch (op[0]) {\n      case HighLevelBuilderOpcodes.Label:\n        return encoder.label(op[1]);\n      case HighLevelBuilderOpcodes.StartLabels:\n        return encoder.startLabels();\n      case HighLevelBuilderOpcodes.StopLabels:\n        return encoder.stopLabels();\n\n      case HighLevelResolutionOpcodes.Component:\n        return resolveComponent(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Modifier:\n        return resolveModifier(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Helper:\n        return resolveHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.ComponentOrHelper:\n        return resolveComponentOrHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.OptionalHelper:\n        return resolveOptionalHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.OptionalComponentOrHelper:\n        return resolveOptionalComponentOrHelper(resolver, constants, meta, op);\n\n      case HighLevelResolutionOpcodes.Local: {\n        let freeVar = op[1];\n        let name = expect(meta.upvars, 'BUG: attempted to resolve value but no upvars found')[\n          freeVar\n        ]!;\n\n        let andThen = op[2];\n        andThen(name, meta.moduleName);\n\n        break;\n      }\n\n      case HighLevelResolutionOpcodes.TemplateLocal: {\n        let [, valueIndex, then] = op;\n        let value = expect(\n          meta.scopeValues,\n          'BUG: Attempted to gect a template local, but template does not have any'\n        )[valueIndex];\n\n        then(constants.value(value));\n\n        break;\n      }\n\n      case HighLevelResolutionOpcodes.Free:\n        if (import.meta.env.DEV) {\n          let [, upvarIndex] = op;\n          let freeName = expect(meta.upvars, 'BUG: attempted to resolve value but no upvars found')[\n            upvarIndex\n          ];\n\n          throw new Error(\n            `Attempted to resolve a value in a strict mode template, but that value was not in scope: ${freeName}`\n          );\n        }\n        break;\n\n      default:\n        throw new Error(`Unexpected high level opcode ${op[0]}`);\n    }\n  }\n}\n\nexport class EncoderImpl implements Encoder {\n  private labelsStack = new Stack<Labels>();\n  private encoder: InstructionEncoder = new InstructionEncoderImpl([]);\n  private errors: EncoderError[] = [];\n  private handle: number;\n\n  constructor(\n    private heap: CompileTimeHeap,\n    private meta: ContainingMetadata,\n    private stdlib?: STDLib\n  ) {\n    this.handle = heap.malloc();\n  }\n\n  error(error: EncoderError): void {\n    this.encoder.encode(Op.Primitive, 0);\n    this.errors.push(error);\n  }\n\n  commit(size: number): HandleResult {\n    let handle = this.handle;\n\n    this.heap.pushMachine(MachineOp.Return);\n    this.heap.finishMalloc(handle, size);\n\n    if (isPresentArray(this.errors)) {\n      return { errors: this.errors, handle };\n    } else {\n      return handle;\n    }\n  }\n\n  push(\n    constants: CompileTimeConstants,\n    type: BuilderOpcode,\n    ...args: SingleBuilderOperand[]\n  ): void {\n    let { heap } = this;\n\n    if (import.meta.env.DEV && (type as number) > TYPE_SIZE) {\n      throw new Error(`Opcode type over 8-bits. Got ${type}.`);\n    }\n\n    let machine = isMachineOp(type) ? MACHINE_MASK : 0;\n    let first = type | machine | (args.length << ARG_SHIFT);\n\n    heap.pushRaw(first);\n\n    for (let i = 0; i < args.length; i++) {\n      let op = args[i];\n      heap.pushRaw(this.operand(constants, op));\n    }\n  }\n\n  private operand(constants: CompileTimeConstants, operand: SingleBuilderOperand): Operand {\n    if (typeof operand === 'number') {\n      return operand;\n    }\n\n    if (typeof operand === 'object' && operand !== null) {\n      if (Array.isArray(operand)) {\n        return encodeHandle(constants.array(operand));\n      } else {\n        switch (operand.type) {\n          case HighLevelOperands.Label:\n            this.currentLabels.target(this.heap.offset, operand.value);\n            return -1;\n\n          case HighLevelOperands.IsStrictMode:\n            return encodeHandle(constants.value(this.meta.isStrictMode));\n\n          case HighLevelOperands.DebugSymbols:\n            return encodeHandle(constants.array(this.meta.evalSymbols || EMPTY_STRING_ARRAY));\n\n          case HighLevelOperands.Block:\n            return encodeHandle(constants.value(compilableBlock(operand.value, this.meta)));\n\n          case HighLevelOperands.StdLib:\n            return expect(\n              this.stdlib,\n              'attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?'\n            )[operand.value];\n\n          case HighLevelOperands.NonSmallInt:\n          case HighLevelOperands.SymbolTable:\n          case HighLevelOperands.Layout:\n            return constants.value(operand.value);\n        }\n      }\n    }\n\n    return encodeHandle(constants.value(operand));\n  }\n\n  private get currentLabels(): Labels {\n    return expect(this.labelsStack.current, 'bug: not in a label stack');\n  }\n\n  label(name: string) {\n    this.currentLabels.label(name, this.heap.offset + 1);\n  }\n\n  startLabels() {\n    this.labelsStack.push(new Labels());\n  }\n\n  stopLabels() {\n    let label = expect(this.labelsStack.pop(), 'unbalanced push and pop labels');\n    label.patch(this.heap);\n  }\n}\n\nfunction isBuilderOpcode(op: number): op is BuilderOpcode {\n  return op < HighLevelBuilderOpcodes.Start;\n}\n","import type {\n  BlockSymbolTable,\n  BuilderOp,\n  CompilableBlock,\n  CompilableProgram,\n  CompilableTemplate,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  SerializedBlock,\n  SerializedInlineBlock,\n  Statement,\n  SymbolTable,\n  WireFormat,\n} from \"@glimmer/interfaces\";\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { EMPTY_ARRAY } from '@glimmer/util';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { meta } from './opcode-builder/helpers/shared';\nimport type { HighLevelStatementOp } from './syntax/compilers';\nimport { STATEMENTS } from './syntax/statements';\n\nexport const PLACEHOLDER_HANDLE = -1;\n\nclass CompilableTemplateImpl<S extends SymbolTable> implements CompilableTemplate<S> {\n  compiled: Nullable<HandleResult> = null;\n\n  constructor(\n    readonly statements: WireFormat.Statement[],\n    readonly meta: ContainingMetadata,\n    // Part of CompilableTemplate\n    readonly symbolTable: S,\n    // Used for debugging\n    readonly moduleName = 'plain block'\n  ) {}\n\n  // Part of CompilableTemplate\n  compile(context: CompileTimeCompilationContext): HandleResult {\n    return maybeCompile(this, context);\n  }\n}\n\nexport function compilable(layout: LayoutWithContext, moduleName: string): CompilableProgram {\n  let [statements, symbols, hasEval] = layout.block;\n  return new CompilableTemplateImpl(\n    statements,\n    meta(layout),\n    {\n      symbols,\n      hasEval,\n    },\n    moduleName\n  );\n}\n\nfunction maybeCompile(\n  compilable: CompilableTemplateImpl<SymbolTable>,\n  context: CompileTimeCompilationContext\n): HandleResult {\n  if (compilable.compiled !== null) return compilable.compiled;\n\n  compilable.compiled = PLACEHOLDER_HANDLE;\n\n  let { statements, meta } = compilable;\n\n  let result = compileStatements(statements, meta, context);\n  compilable.compiled = result;\n\n  return result;\n}\n\nexport function compileStatements(\n  statements: Statement[],\n  meta: ContainingMetadata,\n  syntaxContext: CompileTimeCompilationContext\n): HandleResult {\n  let sCompiler = STATEMENTS;\n  let context = templateCompilationContext(syntaxContext, meta);\n\n  let {\n    encoder,\n    program: { constants, resolver },\n  } = context;\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, meta, op as BuilderOp | HighLevelOp);\n  }\n\n  for (const statement of statements) {\n    sCompiler.compile(pushOp, statement);\n  }\n\n  let handle = context.encoder.commit(meta.size);\n\n  if (LOCAL_SHOULD_LOG) {\n    debugCompiler(context, handle);\n  }\n\n  return handle;\n}\n\nexport function compilableBlock(\n  block: SerializedInlineBlock | SerializedBlock,\n  containing: ContainingMetadata\n): CompilableBlock {\n  return new CompilableTemplateImpl<BlockSymbolTable>(block[0], containing, {\n    parameters: block[1] || (EMPTY_ARRAY as number[]),\n  });\n}\n","export class StdLib {\n  constructor(\n    public main: number,\n    private trustingGuardedAppend: number,\n    private cautiousGuardedAppend: number,\n    private trustingNonDynamicAppend: number,\n    private cautiousNonDynamicAppend: number\n  ) {}\n\n  get 'trusting-append'() {\n    return this.trustingGuardedAppend;\n  }\n\n  get 'cautious-append'() {\n    return this.cautiousGuardedAppend;\n  }\n\n  get 'trusting-non-dynamic-append'() {\n    return this.trustingNonDynamicAppend;\n  }\n\n  get 'cautious-non-dynamic-append'() {\n    return this.cautiousNonDynamicAppend;\n  }\n\n  getAppend(trusting: boolean) {\n    return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;\n  }\n}\n","import type { NamedBlocks, Nullable, SerializedInlineBlock, WireFormat } from \"@glimmer/interfaces\";\nimport { assign, dict, enumerate, unwrap } from '@glimmer/util';\n\ninterface NamedBlocksDict {\n  [key: string]: Nullable<WireFormat.SerializedInlineBlock>;\n}\n\nexport class NamedBlocksImpl implements NamedBlocks {\n  public names: string[];\n\n  constructor(private blocks: Nullable<NamedBlocksDict>) {\n    this.names = blocks ? Object.keys(blocks) : [];\n  }\n\n  get(name: string): Nullable<SerializedInlineBlock> {\n    if (!this.blocks) return null;\n\n    return this.blocks[name] || null;\n  }\n\n  has(name: string): boolean {\n    let { blocks } = this;\n    return blocks !== null && name in blocks;\n  }\n\n  with(name: string, block: Nullable<SerializedInlineBlock>): NamedBlocks {\n    let { blocks } = this;\n\n    if (blocks) {\n      return new NamedBlocksImpl(assign({}, blocks, { [name]: block }));\n    } else {\n      return new NamedBlocksImpl({ [name]: block });\n    }\n  }\n\n  get hasAny(): boolean {\n    return this.blocks !== null;\n  }\n}\n\nexport const EMPTY_BLOCKS = new NamedBlocksImpl(null);\n\nexport function namedBlocks(blocks: WireFormat.Core.Blocks): NamedBlocks {\n  if (blocks === null) {\n    return EMPTY_BLOCKS;\n  }\n\n  let out: NamedBlocksDict = dict();\n\n  let [keys, values] = blocks;\n\n  for (const [i, key] of enumerate(keys)) {\n    out[key] = unwrap(values[i]);\n  }\n\n  return new NamedBlocksImpl(out);\n}\n","import type { CurriedType, NonSmallIntOperand, Nullable, WireFormat } from \"@glimmer/interfaces\";\nimport { encodeImmediate, isSmallInt } from '@glimmer/util';\nimport { $fp, $v0, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\nimport { isStrictMode, nonSmallIntOperand } from '../operands';\nimport { expr } from './expr';\nimport { SimpleArgs } from './shared';\n\nexport type Primitive = undefined | null | boolean | number | string;\n\nexport interface CompileHelper {\n  handle: number;\n  positional: Nullable<WireFormat.Core.Params>;\n  named: WireFormat.Core.Hash;\n}\n\n/**\n * Push a reference onto the stack corresponding to a statically known primitive\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitiveReference(op: PushExpressionOp, value: Primitive): void {\n  PushPrimitive(op, value);\n  op(Op.PrimitiveReference);\n}\n\n/**\n * Push an encoded representation of a JavaScript primitive on the stack\n *\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitive(op: PushExpressionOp, primitive: Primitive): void {\n  let p: Primitive | NonSmallIntOperand = primitive;\n\n  if (typeof p === 'number') {\n    p = isSmallInt(p) ? encodeImmediate(p) : nonSmallIntOperand(p);\n  }\n\n  op(Op.Primitive, p);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a statically known handle\n *\n * @param op The op creation function\n * @param handle A handle\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function Call(\n  op: PushExpressionOp,\n  handle: number,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Helper, handle);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a dynamically loaded definition\n *\n * @param op The op creation function\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function CallDynamic(\n  op: PushExpressionOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  append?: () => void\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Dup, $fp, 1);\n  op(Op.DynamicHelper);\n  if (append) {\n    op(Op.Fetch, $v0);\n    append();\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n  } else {\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n    op(Op.Fetch, $v0);\n  }\n}\n\n/**\n * Evaluate statements in the context of new dynamic scope entries. Move entries from the\n * stack into named entries in the dynamic scope, then evaluate the statements, then pop\n * the dynamic scope\n *\n * @param names a list of dynamic scope names\n * @param block a function that returns a list of statements to evaluate\n */\nexport function DynamicScope(op: PushStatementOp, names: string[], block: () => void): void {\n  op(Op.PushDynamicScope);\n  op(Op.BindDynamicScope, names);\n  block();\n  op(Op.PopDynamicScope);\n}\n\nexport function Curry(\n  op: PushExpressionOp,\n  type: CurriedType,\n  definition: WireFormat.Expression,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.CaptureArgs);\n  expr(op, definition);\n  op(Op.Curry, type, isStrictMode());\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n","import type { BuilderOp, HighLevelOp, SexpOpcode, SexpOpcodeMap } from \"@glimmer/interfaces\";\nimport { assert, unwrap } from '@glimmer/util';\n\nexport type PushExpressionOp = (...op: BuilderOp | HighLevelOp) => void;\n\ndeclare const STATEMENT: unique symbol;\n\nexport type HighLevelStatementOp = [{ [STATEMENT]: undefined }];\n\nexport type PushStatementOp = (...op: BuilderOp | HighLevelOp | HighLevelStatementOp) => void;\n\nexport type CompilerFunction<PushOp extends PushExpressionOp, TSexp> = (\n  op: PushOp,\n  sexp: TSexp\n) => void;\n\nexport class Compilers<PushOp extends PushExpressionOp, TSexpOpcodes extends SexpOpcode> {\n  private names: {\n    [name: number]: number;\n  } = {};\n\n  private funcs: CompilerFunction<PushOp, any>[] = [];\n\n  add<TSexpOpcode extends TSexpOpcodes>(\n    name: TSexpOpcode,\n    func: CompilerFunction<PushOp, SexpOpcodeMap[TSexpOpcode]>\n  ): void {\n    this.names[name] = this.funcs.push(func) - 1;\n  }\n\n  compile(op: PushOp, sexp: SexpOpcodeMap[TSexpOpcodes]): void {\n    let name = sexp[0];\n    let index = unwrap(this.names[name]);\n    let func = this.funcs[index];\n    assert(!!func, `expected an implementation for ${sexp[0]}`);\n\n    func(op, sexp);\n  }\n}\n","import { assert, deprecate } from '@glimmer/global-context';\nimport type { ExpressionSexpOpcode } from \"@glimmer/interfaces\";\nimport { $v0, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport { expr } from '../opcode-builder/helpers/expr';\nimport { isGetFreeHelper } from '../opcode-builder/helpers/resolution';\nimport { SimpleArgs } from '../opcode-builder/helpers/shared';\nimport { Call, CallDynamic, Curry, PushPrimitiveReference } from '../opcode-builder/helpers/vm';\nimport { HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { Compilers, type PushExpressionOp } from './compilers';\n\nexport const EXPRESSIONS = new Compilers<PushExpressionOp, ExpressionSexpOpcode>();\n\nEXPRESSIONS.add(SexpOpcodes.Concat, (op, [, parts]) => {\n  for (let part of parts) {\n    expr(op, part);\n  }\n\n  op(Op.Concat, parts.length);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Call, (op, [, expression, positional, named]) => {\n  if (isGetFreeHelper(expression)) {\n    op(HighLevelResolutionOpcodes.Helper, expression, (handle: number) => {\n      Call(op, handle, positional, named);\n    });\n  } else {\n    expr(op, expression);\n    CallDynamic(op, positional, named);\n  }\n});\n\nEXPRESSIONS.add(SexpOpcodes.Curry, (op, [, expr, type, positional, named]) => {\n  Curry(op, type, expr, positional, named);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetSymbol, (op, [, sym, path]) => {\n  op(Op.GetVariable, sym);\n  withPath(op, path);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetLexicalSymbol, (op, [, sym, path]) => {\n  op(HighLevelResolutionOpcodes.TemplateLocal, sym, (handle: number) => {\n    op(Op.ConstantReference, handle);\n    withPath(op, path);\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetStrictKeyword, (op, [, sym, _path]) => {\n  op(HighLevelResolutionOpcodes.Free, sym, (_handle: unknown) => {\n    // TODO: Implement in strict mode\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback, () => {\n  // TODO: The logic for this opcode currently exists in STATEMENTS.Append, since\n  // we want different wrapping logic depending on if we are invoking a component,\n  // helper, or {{this}} fallback. Eventually we fix the opcodes so that we can\n  // traverse the subexpression tree like normal in this location.\n  throw new Error('unimplemented opcode');\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsHelperHeadOrThisFallback, (op, expr) => {\n  // <div id={{baz}}>\n\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.OptionalHelper, expr, {\n      ifHelper: (handle: number) => {\n        Call(op, handle, null, null);\n      },\n    });\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback, (op, expr) => {\n  // <Foo @bar={{baz}}>\n\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.OptionalHelper, expr, {\n      ifHelper: (handle: number, name: string, moduleName: string) => {\n        assert(expr[2] && expr[2].length === 1, '[BUG] Missing argument name');\n\n        let arg = expr[2][0];\n\n        deprecate(\n          `The \\`${name}\\` helper was used in the \\`${moduleName}\\` template as \\`${arg}={{${name}}}\\`. ` +\n            `This is ambigious between wanting the \\`${arg}\\` argument to be the \\`${name}\\` helper itself, ` +\n            `or the result of invoking the \\`${name}\\` helper (current behavior). ` +\n            `This implicit invocation behavior has been deprecated.\\n\\n` +\n            `Instead, please explicitly invoke the helper with parenthesis, i.e. \\`${arg}={{(${name})}}\\`.\\n\\n` +\n            `Note: the parenthesis are only required in this exact scenario where an ambiguity is present – where ` +\n            `\\`${name}\\` referes to a global helper (as opposed to a local variable), AND ` +\n            `the \\`${name}\\` helper invocation does not take any arguments, AND ` +\n            `this occurs in a named argument position of a component invocation.\\n\\n` +\n            `We expect this combination to be quite rare, as most helpers require at least one argument. ` +\n            `There is no need to refactor helper invocations in cases where this deprecation was not triggered.`,\n          false,\n          {\n            id: 'argument-less-helper-paren-less-invocation',\n          }\n        );\n\n        Call(op, handle, null, null);\n      },\n    });\n  });\n});\n\nfunction withPath(op: PushExpressionOp, path?: string[]) {\n  if (path === undefined || path.length === 0) return;\n\n  for (let i = 0; i < path.length; i++) {\n    op(Op.GetProperty, path[i]);\n  }\n}\n\nEXPRESSIONS.add(SexpOpcodes.Undefined, (op) => PushPrimitiveReference(op, undefined));\nEXPRESSIONS.add(SexpOpcodes.HasBlock, (op, [, block]) => {\n  expr(op, block);\n  op(Op.HasBlock);\n});\n\nEXPRESSIONS.add(SexpOpcodes.HasBlockParams, (op, [, block]) => {\n  expr(op, block);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.HasBlockParams);\n});\n\nEXPRESSIONS.add(SexpOpcodes.IfInline, (op, [, condition, truthy, falsy]) => {\n  // Push in reverse order\n  expr(op, falsy);\n  expr(op, truthy);\n  expr(op, condition);\n  op(Op.IfInline);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Not, (op, [, value]) => {\n  expr(op, value);\n  op(Op.Not);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetDynamicVar, (op, [, expression]) => {\n  expr(op, expression);\n  op(Op.GetDynamicVar);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Log, (op, [, positional]) => {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, null, false);\n  op(Op.Log);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n});\n","import type { WireFormat } from \"@glimmer/interfaces\";\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp } from '../../syntax/compilers';\nimport { EXPRESSIONS } from '../../syntax/expressions';\nimport { PushPrimitive } from './vm';\n\nexport function expr(op: PushExpressionOp, expression: WireFormat.Expression): void {\n  if (Array.isArray(expression)) {\n    EXPRESSIONS.compile(op, expression);\n  } else {\n    PushPrimitive(op, expression);\n    op(Op.PrimitiveReference);\n  }\n}\n","import type {\n  ContainingMetadata,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from \"@glimmer/interfaces\";\nimport { EMPTY_ARRAY, EMPTY_STRING_ARRAY } from '@glimmer/util';\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\nimport { PushYieldableBlock } from './blocks';\nimport { expr } from './expr';\n\n/**\n * Compile arguments, pushing an Arguments object onto the stack.\n *\n * @param args.params\n * @param args.hash\n * @param args.blocks\n * @param args.atNames\n */\nexport function CompileArgs(\n  op: PushStatementOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  blocks: NamedBlocks,\n  atNames: boolean\n): void {\n  let blockNames: string[] = blocks.names;\n  for (const name of blockNames) {\n    PushYieldableBlock(op, blocks.get(name));\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  if (blocks) {\n    flags |= 0b111;\n  }\n\n  let names = EMPTY_ARRAY as readonly string[];\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names as string[], blockNames, flags);\n}\n\nexport function SimpleArgs(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>,\n  named: Nullable<WireFormat.Core.Hash>,\n  atNames: boolean\n): void {\n  if (positional === null && named === null) {\n    op(Op.PushEmptyArgs);\n    return;\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  let names = EMPTY_STRING_ARRAY;\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n}\n\n/**\n * Compile an optional list of positional arguments, which pushes each argument\n * onto the stack and returns the number of parameters compiled\n *\n * @param positional an optional list of positional arguments\n */\nexport function CompilePositional(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>\n): number {\n  if (positional === null) return 0;\n\n  for (let i = 0; i < positional.length; i++) {\n    expr(op, positional[i]);\n  }\n\n  return positional.length;\n}\n\nexport function meta(layout: LayoutWithContext): ContainingMetadata {\n  let [, symbols, , upvars] = layout.block;\n\n  return {\n    evalSymbols: evalSymbols(layout),\n    upvars: upvars,\n    scopeValues: layout.scope?.() ?? null,\n    isStrictMode: layout.isStrictMode,\n    moduleName: layout.moduleName,\n    owner: layout.owner,\n    size: symbols.length,\n  };\n}\n\nexport function evalSymbols(layout: LayoutWithContext): Nullable<string[]> {\n  let { block } = layout;\n  let [, symbols, hasEval] = block;\n\n  return hasEval ? symbols : null;\n}\n","import type { Nullable, WireFormat } from \"@glimmer/interfaces\";\nimport { $fp, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\nimport { blockOperand, symbolTableOperand } from '../operands';\nimport { SimpleArgs } from './shared';\nimport { PushPrimitive } from './vm';\n\n/**\n * Yield to a block located at a particular symbol location.\n *\n * @param to the symbol containing the block to yield to\n * @param params optional block parameters to yield to the block\n */\nexport function YieldBlock(\n  op: PushStatementOp,\n  to: number,\n  positional: Nullable<WireFormat.Core.Params>\n): void {\n  SimpleArgs(op, positional, null, true);\n  op(Op.GetBlock, to);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.InvokeYield);\n  op(Op.PopScope);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Push an (optional) yieldable block onto the stack. The yieldable block must be known\n * statically at compile time.\n *\n * @param block An optional Compilable block\n */\nexport function PushYieldableBlock(\n  op: PushStatementOp,\n  block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  PushSymbolTable(op, block && block[1]);\n  op(Op.PushBlockScope);\n  PushCompilable(op, block);\n}\n\n/**\n * Invoke a block that is known statically at compile time.\n *\n * @param block a Compilable block\n */\nexport function InvokeStaticBlock(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock\n): void {\n  op(MachineOp.PushFrame);\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Invoke a static block, preserving some number of stack entries for use in\n * updating.\n *\n * @param block A compilable block\n * @param callerCount A number of stack entries to preserve\n */\nexport function InvokeStaticBlockWithStack(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock,\n  callerCount: number\n): void {\n  let parameters = block[1];\n  let calleeCount = parameters.length;\n  let count = Math.min(callerCount, calleeCount);\n\n  if (count === 0) {\n    InvokeStaticBlock(op, block);\n    return;\n  }\n\n  op(MachineOp.PushFrame);\n\n  if (count) {\n    op(Op.ChildScope);\n\n    for (let i = 0; i < count; i++) {\n      op(Op.Dup, $fp, callerCount - i);\n      op(Op.SetVariable, parameters[i]);\n    }\n  }\n\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n\n  if (count) {\n    op(Op.PopScope);\n  }\n\n  op(MachineOp.PopFrame);\n}\n\nexport function PushSymbolTable(op: PushExpressionOp, parameters: number[] | null): void {\n  if (parameters !== null) {\n    op(Op.PushSymbolTable, symbolTableOperand({ parameters }));\n  } else {\n    PushPrimitive(op, null);\n  }\n}\n\nexport function PushCompilable(\n  op: PushExpressionOp,\n  _block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  if (_block === null) {\n    PushPrimitive(op, null);\n  } else {\n    op(Op.Constant, blockOperand(_block));\n  }\n}\n","import { unwrap } from '@glimmer/util';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushStatementOp } from '../../syntax/compilers';\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { labelOperand } from '../operands';\n\nexport type When = (match: number, callback: () => void) => void;\n\nexport function SwitchCases(\n  op: PushStatementOp,\n  bootstrap: () => void,\n  matcher: (when: When) => void\n): void {\n  // Setup the switch DSL\n  let clauses: Array<{ match: number; label: string; callback: () => void }> = [];\n\n  let count = 0;\n\n  function when(match: number, callback: () => void): void {\n    clauses.push({ match, callback, label: `CLAUSE${count++}` });\n  }\n\n  // Call the callback\n  matcher(when);\n\n  // Emit the opcodes for the switch\n  op(Op.Enter, 1);\n  bootstrap();\n  op(HighLevelBuilderOpcodes.StartLabels);\n\n  // First, emit the jump opcodes. We don't need a jump for the last\n  // opcode, since it bleeds directly into its clause.\n  for (let clause of clauses.slice(0, -1)) {\n    op(Op.JumpEq, labelOperand(clause.label), clause.match);\n  }\n\n  // Enumerate the clauses in reverse order. Earlier matches will\n  // require fewer checks.\n  for (let i = clauses.length - 1; i >= 0; i--) {\n    let clause = unwrap(clauses[i]);\n\n    op(HighLevelBuilderOpcodes.Label, clause.label);\n    op(Op.Pop, 1);\n    clause.callback();\n\n    // The first match is special: it is placed directly before the END\n    // label, so no additional jump is needed at the end of it.\n    if (i !== 0) {\n      op(MachineOp.Jump, labelOperand('END'));\n    }\n  }\n\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(HighLevelBuilderOpcodes.StopLabels);\n  op(Op.Exit);\n}\n\n/**\n * A convenience for pushing some arguments on the stack and\n * running some code if the code needs to be re-executed during\n * updating execution if some of the arguments have changed.\n *\n * # Initial Execution\n *\n * The `args` function should push zero or more arguments onto\n * the stack and return the number of arguments pushed.\n *\n * The `body` function provides the instructions to execute both\n * during initial execution and during updating execution.\n *\n * Internally, this function starts by pushing a new frame, so\n * that the body can return and sets the return point ($ra) to\n * the ENDINITIAL label.\n *\n * It then executes the `args` function, which adds instructions\n * responsible for pushing the arguments for the block to the\n * stack. These arguments will be restored to the stack before\n * updating execution.\n *\n * Next, it adds the Enter opcode, which marks the current position\n * in the DOM, and remembers the current $pc (the next instruction)\n * as the first instruction to execute during updating execution.\n *\n * Next, it runs `body`, which adds the opcodes that should\n * execute both during initial execution and during updating execution.\n * If the `body` wishes to finish early, it should Jump to the\n * `FINALLY` label.\n *\n * Next, it adds the FINALLY label, followed by:\n *\n * - the Exit opcode, which finalizes the marked DOM started by the\n *   Enter opcode.\n * - the Return opcode, which returns to the current return point\n *   ($ra).\n *\n * Finally, it adds the ENDINITIAL label followed by the PopFrame\n * instruction, which restores $fp, $sp and $ra.\n *\n * # Updating Execution\n *\n * Updating execution for this `replayable` occurs if the `body` added an\n * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.\n *\n * If, during updating executon, the assertion fails, the initial VM is\n * restored, and the stored arguments are pushed onto the stack. The DOM\n * between the starting and ending markers is cleared, and the VM's cursor\n * is set to the area just cleared.\n *\n * The return point ($ra) is set to -1, the exit instruction.\n *\n * Finally, the $pc is set to to the instruction saved off by the\n * Enter opcode during initial execution, and execution proceeds as\n * usual.\n *\n * The only difference is that when a `Return` instruction is\n * encountered, the program jumps to -1 rather than the END label,\n * and the PopFrame opcode is not needed.\n */\nexport function Replayable(op: PushStatementOp, args: () => number, body: () => void): void {\n  // Start a new label frame, to give END and RETURN\n  // a unique meaning.\n\n  op(HighLevelBuilderOpcodes.StartLabels);\n  op(MachineOp.PushFrame);\n\n  // If the body invokes a block, its return will return to\n  // END. Otherwise, the return in RETURN will return to END.\n  op(MachineOp.ReturnTo, labelOperand('ENDINITIAL'));\n\n  // Push the arguments onto the stack. The args() function\n  // tells us how many stack elements to retain for re-execution\n  // when updating.\n  let count = args();\n\n  // Start a new updating closure, remembering `count` elements\n  // from the stack. Everything after this point, and before END,\n  // will execute both initially and to update the block.\n  //\n  // The enter and exit opcodes also track the area of the DOM\n  // associated with this block. If an assertion inside the block\n  // fails (for example, the test value changes from true to false\n  // in an #if), the DOM is cleared and the program is re-executed,\n  // restoring `count` elements to the stack and executing the\n  // instructions between the enter and exit.\n  op(Op.Enter, count);\n\n  // Evaluate the body of the block. The body of the block may\n  // return, which will jump execution to END during initial\n  // execution, and exit the updating routine.\n  body();\n\n  // All execution paths in the body should run the FINALLY once\n  // they are done. It is executed both during initial execution\n  // and during updating execution.\n  op(HighLevelBuilderOpcodes.Label, 'FINALLY');\n\n  // Finalize the DOM.\n  op(Op.Exit);\n\n  // In initial execution, this is a noop: it returns to the\n  // immediately following opcode. In updating execution, this\n  // exits the updating routine.\n  op(MachineOp.Return);\n\n  // Cleanup code for the block. Runs on initial execution\n  // but not on updating.\n  op(HighLevelBuilderOpcodes.Label, 'ENDINITIAL');\n  op(MachineOp.PopFrame);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\n/**\n * A specialized version of the `replayable` convenience that allows the\n * caller to provide different code based upon whether the item at\n * the top of the stack is true or false.\n *\n * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.\n *\n * During the initial execution, a `return` will continue execution\n * in the cleanup code, which finalizes the current DOM block and pops\n * the current frame.\n *\n * During the updating execution, a `return` will exit the updating\n * routine, as it can reuse the DOM block and is always only a single\n * frame deep.\n */\nexport function ReplayableIf(\n  op: PushStatementOp,\n  args: () => number,\n  ifTrue: () => void,\n  ifFalse?: () => void\n): void {\n  return Replayable(op, args, () => {\n    // If the conditional is false, jump to the ELSE label.\n    op(Op.JumpUnless, labelOperand('ELSE'));\n    // Otherwise, execute the code associated with the true branch.\n    ifTrue();\n    // We're done, so return. In the initial execution, this runs\n    // the cleanup code. In the updating VM, it exits the updating\n    // routine.\n    op(MachineOp.Jump, labelOperand('FINALLY'));\n    op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n    // If the conditional is false, and code associatied ith the\n    // false branch was provided, execute it. If there was no code\n    // associated with the false branch, jumping to the else statement\n    // has no other behavior.\n    if (ifFalse !== undefined) {\n      ifFalse();\n    }\n  });\n}\n","import type {\n  CapabilityMask,\n  CompilableProgram,\n  CompileTimeComponent,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from \"@glimmer/interfaces\";\nimport { hasCapability } from '@glimmer/manager';\nimport { EMPTY_STRING_ARRAY, reverse, unwrap } from '@glimmer/util';\nimport {\n  $s0,\n  $s1,\n  $sp,\n  InternalComponentCapabilities,\n  MachineOp,\n  Op,\n  type SavedRegister,\n} from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\nimport { namedBlocks } from '../../utils';\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { isStrictMode, labelOperand, layoutOperand, symbolTableOperand } from '../operands';\nimport { InvokeStaticBlock, PushYieldableBlock, YieldBlock } from './blocks';\nimport { Replayable } from './conditional';\nimport { expr } from './expr';\nimport { CompileArgs, CompilePositional } from './shared';\n\nexport const ATTRS_BLOCK = '&attrs';\n\ninterface AnyComponent {\n  elementBlock: Nullable<WireFormat.SerializedInlineBlock>;\n  positional: WireFormat.Core.Params;\n  named: WireFormat.Core.Hash;\n  blocks: NamedBlocks;\n}\n\n// {{component}}\nexport interface DynamicComponent extends AnyComponent {\n  definition: WireFormat.Expression;\n  atNames: boolean;\n  curried: boolean;\n}\n\n// <Component>\nexport interface StaticComponent extends AnyComponent {\n  capabilities: CapabilityMask;\n  layout: CompilableProgram;\n}\n\n// chokepoint\nexport interface Component extends AnyComponent {\n  // either we know the capabilities statically or we need to be conservative and assume\n  // that the component requires all capabilities\n  capabilities: CapabilityMask | true;\n\n  // are the arguments supplied as atNames?\n  atNames: boolean;\n\n  // do we have the layout statically or will we need to look it up at runtime?\n  layout?: CompilableProgram;\n}\n\nexport function InvokeComponent(\n  op: PushStatementOp,\n  component: CompileTimeComponent,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks\n): void {\n  let { compilable, capabilities, handle } = component;\n\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  if (compilable) {\n    op(Op.PushComponentDefinition, handle);\n    InvokeStaticComponent(op, {\n      capabilities: capabilities,\n      layout: compilable,\n      elementBlock,\n      positional,\n      named,\n      blocks,\n    });\n  } else {\n    op(Op.PushComponentDefinition, handle);\n    InvokeNonStaticComponent(op, {\n      capabilities: capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n    });\n  }\n}\n\nexport function InvokeDynamicComponent(\n  op: PushStatementOp,\n  definition: WireFormat.Core.Expression,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks,\n  atNames: boolean,\n  curried: boolean\n): void {\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  Replayable(\n    op,\n\n    () => {\n      expr(op, definition);\n      op(Op.Dup, $sp, 0);\n      return 2;\n    },\n\n    () => {\n      op(Op.JumpUnless, labelOperand('ELSE'));\n\n      if (curried) {\n        op(Op.ResolveCurriedComponent);\n      } else {\n        op(Op.ResolveDynamicComponent, isStrictMode());\n      }\n\n      op(Op.PushDynamicComponentInstance);\n      InvokeNonStaticComponent(op, {\n        capabilities: true,\n        elementBlock,\n        positional,\n        named,\n        atNames,\n        blocks,\n      });\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n    }\n  );\n}\n\nfunction InvokeStaticComponent(\n  op: PushStatementOp,\n  { capabilities, layout, elementBlock, positional, named, blocks }: StaticComponent\n): void {\n  let { symbolTable } = layout;\n\n  let bailOut =\n    symbolTable.hasEval || hasCapability(capabilities, InternalComponentCapabilities.prepareArgs);\n\n  if (bailOut) {\n    InvokeNonStaticComponent(op, {\n      capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n      layout,\n    });\n\n    return;\n  }\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n  op(MachineOp.PushFrame);\n\n  // Setup arguments\n  let { symbols } = symbolTable;\n\n  // As we push values onto the stack, we store the symbols associated  with them\n  // so that we can set them on the scope later on with SetVariable and SetBlock\n  let blockSymbols: number[] = [];\n  let argSymbols: number[] = [];\n  let argNames: string[] = [];\n\n  // First we push the blocks onto the stack\n  let blockNames = blocks.names;\n\n  // Starting with the attrs block, if it exists and is referenced in the component\n  if (elementBlock !== null) {\n    let symbol = symbols.indexOf(ATTRS_BLOCK);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, elementBlock);\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Followed by the other blocks, if they exist and are referenced in the component.\n  // Also store the index of the associated symbol.\n  for (const name of blockNames) {\n    let symbol = symbols.indexOf(`&${name}`);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, blocks.get(name));\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Next up we have arguments. If the component has the `createArgs` capability,\n  // then it wants access to the arguments in JavaScript. We can't know whether\n  // or not an argument is used, so we have to give access to all of them.\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    // First we push positional arguments\n    let count = CompilePositional(op, positional);\n\n    // setup the flags with the count of positionals, and to indicate that atNames\n    // are used\n    let flags = count << 4;\n    flags |= 0b1000;\n\n    let names: string[] = EMPTY_STRING_ARRAY;\n\n    // Next, if named args exist, push them all. If they have an associated symbol\n    // in the invoked component (e.g. they are used within its template), we push\n    // that symbol. If not, we still push the expression as it may be used, and\n    // we store the symbol as -1 (this is used later).\n    if (named !== null) {\n      names = named[0];\n      let val = named[1];\n\n      for (let i = 0; i < val.length; i++) {\n        let symbol = symbols.indexOf(unwrap(names[i]));\n\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n      }\n    }\n\n    // Finally, push the VM arguments themselves. These args won't need access\n    // to blocks (they aren't accessible from userland anyways), so we push an\n    // empty array instead of the actual block names.\n    op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n\n    // And push an extra pop operation to remove the args before we begin setting\n    // variables on the local context\n    argSymbols.push(-1);\n  } else if (named !== null) {\n    // If the component does not have the `createArgs` capability, then the only\n    // expressions we need to push onto the stack are those that are actually\n    // referenced in the template of the invoked component (e.g. have symbols).\n    let names = named[0];\n    let val = named[1];\n\n    for (let i = 0; i < val.length; i++) {\n      let name = unwrap(names[i]);\n      let symbol = symbols.indexOf(name);\n\n      if (symbol !== -1) {\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n        argNames.push(name);\n      }\n    }\n  }\n\n  op(Op.BeginComponentTransaction, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PushDynamicScope);\n  }\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createInstance)) {\n    op(Op.CreateComponent, (blocks.has('default') as any) | 0, $s0);\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    op(Op.GetComponentSelf, $s0);\n  } else {\n    op(Op.GetComponentSelf, $s0, argNames);\n  }\n\n  // Setup the new root scope for the component\n  op(Op.RootScope, symbols.length + 1, Object.keys(blocks).length > 0 ? 1 : 0);\n\n  // Pop the self reference off the stack and set it to the symbol for `this`\n  // in the new scope. This is why all subsequent symbols are increased by one.\n  op(Op.SetVariable, 0);\n\n  // Going in reverse, now we pop the args/blocks off the stack, starting with\n  // arguments, and assign them to their symbols in the new scope.\n  for (const symbol of reverse(argSymbols)) {\n    // for (let i = argSymbols.length - 1; i >= 0; i--) {\n    //   let symbol = argSymbols[i];\n\n    if (symbol === -1) {\n      // The expression was not bound to a local symbol, it was only pushed to be\n      // used with VM args in the javascript side\n      op(Op.Pop, 1);\n    } else {\n      op(Op.SetVariable, symbol + 1);\n    }\n  }\n\n  // if any positional params exist, pop them off the stack as well\n  if (positional !== null) {\n    op(Op.Pop, positional.length);\n  }\n\n  // Finish up by popping off and assigning blocks\n  for (const symbol of reverse(blockSymbols)) {\n    op(Op.SetBlock, symbol + 1);\n  }\n\n  op(Op.Constant, layoutOperand(layout));\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(Op.DidRenderLayout, $s0);\n\n  op(MachineOp.PopFrame);\n  op(Op.PopScope);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PopDynamicScope);\n  }\n\n  op(Op.CommitComponentTransaction);\n  op(Op.Load, $s0);\n}\n\nexport function InvokeNonStaticComponent(\n  op: PushStatementOp,\n  { capabilities, elementBlock, positional, named, atNames, blocks: namedBlocks, layout }: Component\n): void {\n  let bindableBlocks = !!namedBlocks;\n  let bindableAtNames =\n    capabilities === true ||\n    hasCapability(capabilities, InternalComponentCapabilities.prepareArgs) ||\n    !!(named && named[0].length !== 0);\n\n  let blocks = namedBlocks.with('attrs', elementBlock);\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  CompileArgs(op, positional, named, blocks, atNames);\n  op(Op.PrepareArgs, $s0);\n\n  invokePreparedComponent(op, blocks.has('default'), bindableBlocks, bindableAtNames, () => {\n    if (layout) {\n      op(Op.PushSymbolTable, symbolTableOperand(layout.symbolTable));\n      op(Op.Constant, layoutOperand(layout));\n      op(Op.CompileBlock);\n    } else {\n      op(Op.GetComponentLayout, $s0);\n    }\n\n    op(Op.PopulateLayout, $s0);\n  });\n\n  op(Op.Load, $s0);\n}\n\nexport function WrappedComponent(\n  op: PushStatementOp,\n  layout: LayoutWithContext,\n  attrsBlockNumber: number\n): void {\n  op(HighLevelBuilderOpcodes.StartLabels);\n  WithSavedRegister(op, $s1, () => {\n    op(Op.GetComponentTagName, $s0);\n    op(Op.PrimitiveReference);\n    op(Op.Dup, $sp, 0);\n  });\n  op(Op.JumpUnless, labelOperand('BODY'));\n  op(Op.Fetch, $s1);\n  op(Op.PutComponentOperations);\n  op(Op.OpenDynamicElement);\n  op(Op.DidCreateElement, $s0);\n  YieldBlock(op, attrsBlockNumber, null);\n  op(Op.FlushElement);\n  op(HighLevelBuilderOpcodes.Label, 'BODY');\n  InvokeStaticBlock(op, [layout.block[0], []]);\n  op(Op.Fetch, $s1);\n  op(Op.JumpUnless, labelOperand('END'));\n  op(Op.CloseElement);\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(Op.Load, $s1);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\nexport function invokePreparedComponent(\n  op: PushStatementOp,\n  hasBlock: boolean,\n  bindableBlocks: boolean,\n  bindableAtNames: boolean,\n  populateLayout: Nullable<() => void> = null\n): void {\n  op(Op.BeginComponentTransaction, $s0);\n  op(Op.PushDynamicScope);\n\n  op(Op.CreateComponent, (hasBlock as any) | 0, $s0);\n\n  // this has to run after createComponent to allow\n  // for late-bound layouts, but a caller is free\n  // to populate the layout earlier if it wants to\n  // and do nothing here.\n  if (populateLayout) {\n    populateLayout();\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n  op(Op.GetComponentSelf, $s0);\n\n  op(Op.VirtualRootScope, $s0);\n  op(Op.SetVariable, 0);\n  op(Op.SetupForEval, $s0);\n\n  if (bindableAtNames) op(Op.SetNamedVariables, $s0);\n  if (bindableBlocks) op(Op.SetBlocks, $s0);\n\n  op(Op.Pop, 1);\n  op(Op.InvokeComponentLayout, $s0);\n  op(Op.DidRenderLayout, $s0);\n  op(MachineOp.PopFrame);\n\n  op(Op.PopScope);\n  op(Op.PopDynamicScope);\n  op(Op.CommitComponentTransaction);\n}\n\nexport function InvokeBareComponent(op: PushStatementOp): void {\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  op(Op.PushEmptyArgs);\n  op(Op.PrepareArgs, $s0);\n  invokePreparedComponent(op, false, false, true, () => {\n    op(Op.GetComponentLayout, $s0);\n    op(Op.PopulateLayout, $s0);\n  });\n  op(Op.Load, $s0);\n}\n\nexport function WithSavedRegister(\n  op: PushExpressionOp,\n  register: SavedRegister,\n  block: () => void\n): void {\n  op(Op.Fetch, register);\n  block();\n  op(Op.Load, register);\n}\n","import type {\n  BuilderOp,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HighLevelOp,\n} from \"@glimmer/interfaces\";\nimport { $s0, ContentType, MachineOp, Op } from '@glimmer/vm';\n\nimport type { HighLevelStatementOp, PushStatementOp } from '../../syntax/compilers';\nimport { encodeOp, EncoderImpl } from '../encoder';\nimport { StdLib } from '../stdlib';\nimport { InvokeBareComponent, invokePreparedComponent } from './components';\nimport { SwitchCases } from './conditional';\nimport { CallDynamic } from './vm';\n\nexport function main(op: PushStatementOp): void {\n  op(Op.Main, $s0);\n  invokePreparedComponent(op, false, false, true);\n}\n\n/**\n * Append content to the DOM. This standard function triages content and does the\n * right thing based upon whether it's a string, safe string, component, fragment\n * or node.\n *\n * @param trusting whether to interpolate a string as raw HTML (corresponds to\n * triple curlies)\n */\nexport function StdAppend(\n  op: PushStatementOp,\n  trusting: boolean,\n  nonDynamicAppend: number | null\n): void {\n  SwitchCases(\n    op,\n    () => op(Op.ContentType),\n    (when) => {\n      when(ContentType.String, () => {\n        if (trusting) {\n          op(Op.AssertSame);\n          op(Op.AppendHTML);\n        } else {\n          op(Op.AppendText);\n        }\n      });\n\n      if (typeof nonDynamicAppend === 'number') {\n        when(ContentType.Component, () => {\n          op(Op.ResolveCurriedComponent);\n          op(Op.PushDynamicComponentInstance);\n          InvokeBareComponent(op);\n        });\n\n        when(ContentType.Helper, () => {\n          CallDynamic(op, null, null, () => {\n            op(MachineOp.InvokeStatic, nonDynamicAppend);\n          });\n        });\n      } else {\n        // when non-dynamic, we can no longer call the value (potentially because we've already called it)\n        // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.\n        when(ContentType.Component, () => {\n          op(Op.AppendText);\n        });\n\n        when(ContentType.Helper, () => {\n          op(Op.AppendText);\n        });\n      }\n\n      when(ContentType.SafeString, () => {\n        op(Op.AssertSame);\n        op(Op.AppendSafeHTML);\n      });\n\n      when(ContentType.Fragment, () => {\n        op(Op.AssertSame);\n        op(Op.AppendDocumentFragment);\n      });\n\n      when(ContentType.Node, () => {\n        op(Op.AssertSame);\n        op(Op.AppendNode);\n      });\n    }\n  );\n}\n\nexport function compileStd(context: CompileTimeCompilationContext): StdLib {\n  let mainHandle = build(context, (op) => main(op));\n  let trustingGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, true, null));\n  let cautiousGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, false, null));\n\n  let trustingGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, true, trustingGuardedNonDynamicAppend)\n  );\n  let cautiousGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, false, cautiousGuardedNonDynamicAppend)\n  );\n\n  return new StdLib(\n    mainHandle,\n    trustingGuardedDynamicAppend,\n    cautiousGuardedDynamicAppend,\n    trustingGuardedNonDynamicAppend,\n    cautiousGuardedNonDynamicAppend\n  );\n}\n\nexport const STDLIB_META: ContainingMetadata = {\n  evalSymbols: null,\n  upvars: null,\n  moduleName: 'stdlib',\n\n  // TODO: ??\n  scopeValues: null,\n  isStrictMode: true,\n  owner: null,\n  size: 0,\n};\n\nfunction build(\n  program: CompileTimeCompilationContext,\n  builder: (op: PushStatementOp) => void\n): number {\n  let { constants, heap, resolver } = program;\n  let encoder = new EncoderImpl(heap, STDLIB_META);\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, STDLIB_META, op as BuilderOp | HighLevelOp);\n  }\n\n  builder(pushOp);\n\n  let result = encoder.commit(0);\n\n  if (typeof result !== 'number') {\n    // This shouldn't be possible\n    throw new Error(`Unexpected errors compiling std`);\n  } else {\n    return result;\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  CreateRuntimeOp,\n  ResolutionTimeConstants,\n  STDLib,\n} from \"@glimmer/interfaces\";\n\nimport { compileStd } from './opcode-builder/helpers/stdlib';\n\nexport class CompileTimeCompilationContextImpl implements CompileTimeCompilationContext {\n  readonly constants: CompileTimeConstants & ResolutionTimeConstants;\n  readonly heap: CompileTimeHeap;\n  readonly stdlib: STDLib;\n\n  constructor(\n    { constants, heap }: CompileTimeArtifacts,\n    readonly resolver: CompileTimeResolver,\n    readonly createOp: CreateRuntimeOp\n  ) {\n    this.constants = constants;\n    this.heap = heap;\n    this.stdlib = compileStd(this);\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeResolver,\n  ContainingMetadata,\n  CreateRuntimeOp,\n  TemplateCompilationContext,\n} from \"@glimmer/interfaces\";\n\nimport { CompileTimeCompilationContextImpl } from '../program-context';\nimport { EncoderImpl } from './encoder';\n\nexport function programCompilationContext(\n  artifacts: CompileTimeArtifacts,\n  resolver: CompileTimeResolver,\n  createOp: CreateRuntimeOp\n): CompileTimeCompilationContext {\n  return new CompileTimeCompilationContextImpl(artifacts, resolver, createOp);\n}\n\nexport function templateCompilationContext(\n  program: CompileTimeCompilationContext,\n  meta: ContainingMetadata\n): TemplateCompilationContext {\n  let encoder = new EncoderImpl(program.heap, meta, program.stdlib);\n\n  return {\n    program,\n    encoder,\n    meta,\n  };\n}\n","import type {\n  CompileTimeComponent,\n  StatementSexpOpcode,\n  WellKnownAttrName,\n  WellKnownTagName,\n  WireFormat,\n} from \"@glimmer/interfaces\";\nimport { $fp, $sp, ContentType, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport {\n  InvokeStaticBlock,\n  InvokeStaticBlockWithStack,\n  YieldBlock,\n} from '../opcode-builder/helpers/blocks';\nimport {\n  InvokeComponent,\n  InvokeDynamicComponent,\n  InvokeNonStaticComponent,\n} from '../opcode-builder/helpers/components';\nimport { Replayable, ReplayableIf, SwitchCases } from '../opcode-builder/helpers/conditional';\nimport { expr } from '../opcode-builder/helpers/expr';\nimport {\n  isGetFreeComponent,\n  isGetFreeComponentOrHelper,\n  isGetFreeModifier,\n  isGetFreeOptionalComponentOrHelper,\n} from '../opcode-builder/helpers/resolution';\nimport { CompilePositional, SimpleArgs } from '../opcode-builder/helpers/shared';\nimport {\n  Call,\n  CallDynamic,\n  DynamicScope,\n  PushPrimitiveReference,\n} from '../opcode-builder/helpers/vm';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { debugSymbolsOperand, labelOperand, stdlibOperand } from '../opcode-builder/operands';\nimport { namedBlocks } from '../utils';\nimport { Compilers, type PushStatementOp } from './compilers';\n\nexport const STATEMENTS = new Compilers<PushStatementOp, StatementSexpOpcode>();\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n\nSTATEMENTS.add(SexpOpcodes.Comment, (op, sexp) => op(Op.Comment, sexp[1]));\nSTATEMENTS.add(SexpOpcodes.CloseElement, (op) => op(Op.CloseElement));\nSTATEMENTS.add(SexpOpcodes.FlushElement, (op) => op(Op.FlushElement));\n\nSTATEMENTS.add(SexpOpcodes.Modifier, (op, [, expression, positional, named]) => {\n  if (isGetFreeModifier(expression)) {\n    op(HighLevelResolutionOpcodes.Modifier, expression, (handle: number) => {\n      op(MachineOp.PushFrame);\n      SimpleArgs(op, positional, named, false);\n      op(Op.Modifier, handle);\n      op(MachineOp.PopFrame);\n    });\n  } else {\n    expr(op, expression);\n    op(MachineOp.PushFrame);\n    SimpleArgs(op, positional, named, false);\n    op(Op.Dup, $fp, 1);\n    op(Op.DynamicModifier);\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticComponentAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticComponentAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.DynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingDynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.ComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElement, (op, [, tag]) => {\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElementWithSplat, (op, [, tag]) => {\n  op(Op.PutComponentOperations);\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.Component, (op, [, expr, elementBlock, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, elementBlock, null, named, blocks);\n    });\n  } else {\n    // otherwise, the component name was an expression, so resolve the expression\n    // and invoke it as a dynamic component\n    InvokeDynamicComponent(op, expr, elementBlock, null, named, blocks, true, true);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Yield, (op, [, to, params]) => YieldBlock(op, to, params));\n\nSTATEMENTS.add(SexpOpcodes.AttrSplat, (op, [, to]) => YieldBlock(op, to, null));\n\nSTATEMENTS.add(SexpOpcodes.Debugger, (op, [, debugInfo]) =>\n  op(Op.Debugger, debugSymbolsOperand(), debugInfo)\n);\n\nSTATEMENTS.add(SexpOpcodes.Append, (op, [, value]) => {\n  // Special case for static values\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else if (isGetFreeOptionalComponentOrHelper(value)) {\n    op(HighLevelResolutionOpcodes.OptionalComponentOrHelper, value, {\n      ifComponent(component: CompileTimeComponent) {\n        InvokeComponent(op, component, null, null, null, null);\n      },\n\n      ifHelper(handle: number) {\n        op(MachineOp.PushFrame);\n        Call(op, handle, null, null);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n\n      ifValue(handle: number) {\n        op(MachineOp.PushFrame);\n        op(Op.ConstantReference, handle);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n    });\n  } else if (value[0] === SexpOpcodes.Call) {\n    let [, expression, positional, named] = value;\n\n    if (isGetFreeComponentOrHelper(expression)) {\n      op(HighLevelResolutionOpcodes.ComponentOrHelper, expression, {\n        ifComponent(component: CompileTimeComponent) {\n          InvokeComponent(op, component, null, positional, hashToArgs(named), null);\n        },\n        ifHelper(handle: number) {\n          op(MachineOp.PushFrame);\n          Call(op, handle, positional, named);\n          op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n          op(MachineOp.PopFrame);\n        },\n      });\n    } else {\n      SwitchCases(\n        op,\n        () => {\n          expr(op, expression);\n          op(Op.DynamicContentType);\n        },\n        (when) => {\n          when(ContentType.Component, () => {\n            op(Op.ResolveCurriedComponent);\n            op(Op.PushDynamicComponentInstance);\n            InvokeNonStaticComponent(op, {\n              capabilities: true,\n              elementBlock: null,\n              positional,\n              named,\n              atNames: false,\n              blocks: namedBlocks(null),\n            });\n          });\n\n          when(ContentType.Helper, () => {\n            CallDynamic(op, positional, named, () => {\n              op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n            });\n          });\n        }\n      );\n    }\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('cautious-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingAppend, (op, [, value]) => {\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('trusting-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Block, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InElement, (op, [, block, guid, destination, insertBefore]) => {\n  ReplayableIf(\n    op,\n\n    () => {\n      expr(op, guid);\n\n      if (insertBefore === undefined) {\n        PushPrimitiveReference(op, undefined);\n      } else {\n        expr(op, insertBefore);\n      }\n\n      expr(op, destination);\n      op(Op.Dup, $sp, 0);\n\n      return 4;\n    },\n\n    () => {\n      op(Op.PushRemoteElement);\n      InvokeStaticBlock(op, block);\n      op(Op.PopRemoteElement);\n    }\n  );\n});\n\nSTATEMENTS.add(SexpOpcodes.If, (op, [, condition, block, inverse]) =>\n  ReplayableIf(\n    op,\n    () => {\n      expr(op, condition);\n      op(Op.ToBoolean);\n\n      return 1;\n    },\n\n    () => {\n      InvokeStaticBlock(op, block);\n    },\n\n    inverse\n      ? () => {\n          InvokeStaticBlock(op, inverse);\n        }\n      : undefined\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Each, (op, [, value, key, block, inverse]) =>\n  Replayable(\n    op,\n\n    () => {\n      if (key) {\n        expr(op, key);\n      } else {\n        PushPrimitiveReference(op, null);\n      }\n\n      expr(op, value);\n\n      return 2;\n    },\n\n    () => {\n      op(Op.EnterList, labelOperand('BODY'), labelOperand('ELSE'));\n      op(MachineOp.PushFrame);\n      op(Op.Dup, $fp, 1);\n      op(MachineOp.ReturnTo, labelOperand('ITER'));\n      op(HighLevelBuilderOpcodes.Label, 'ITER');\n      op(Op.Iterate, labelOperand('BREAK'));\n      op(HighLevelBuilderOpcodes.Label, 'BODY');\n      InvokeStaticBlockWithStack(op, block, 2);\n      op(Op.Pop, 2);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'BREAK');\n      op(MachineOp.PopFrame);\n      op(Op.ExitList);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n      if (inverse) {\n        InvokeStaticBlock(op, inverse);\n      }\n    }\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.With, (op, [, value, block, inverse]) => {\n  ReplayableIf(\n    op,\n\n    () => {\n      expr(op, value);\n      op(Op.Dup, $sp, 0);\n      op(Op.ToBoolean);\n\n      return 2;\n    },\n\n    () => {\n      InvokeStaticBlockWithStack(op, block, 1);\n    },\n\n    () => {\n      if (inverse) {\n        InvokeStaticBlock(op, inverse);\n      }\n    }\n  );\n});\n\nSTATEMENTS.add(SexpOpcodes.Let, (op, [, positional, block]) => {\n  let count = CompilePositional(op, positional);\n  InvokeStaticBlockWithStack(op, block, count);\n});\n\nSTATEMENTS.add(SexpOpcodes.WithDynamicVars, (op, [, named, block]) => {\n  if (named) {\n    let [names, expressions] = named;\n\n    CompilePositional(op, expressions);\n    DynamicScope(op, names, () => {\n      InvokeStaticBlock(op, block);\n    });\n  } else {\n    InvokeStaticBlock(op, block);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InvokeComponent, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nfunction hashToArgs(hash: WireFormat.Core.Hash | null): WireFormat.Core.Hash | null {\n  if (hash === null) return null;\n  let names = hash[0].map((key) => `@${key}`);\n  return [names as [string, ...string[]], hash[1]];\n}\n","import type {\n  CompileTimeComponent,\n  InternalComponentCapabilities,\n  Nullable,\n} from \"@glimmer/interfaces\";\n\nexport const DEFAULT_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: true,\n  dynamicTag: true,\n  prepareArgs: true,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: true,\n  createCaller: false,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport const MINIMAL_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: false,\n  createCaller: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport interface ResolverDelegate<R = unknown> {\n  lookupHelper?(name: string, referrer: R): Nullable<number> | void;\n  lookupModifier?(name: string, referrer: R): Nullable<number> | void;\n  lookupComponent?(name: string, referrer: R): Nullable<CompileTimeComponent> | void;\n\n  // For debugging\n  resolve?(handle: number): R;\n}\n","import type {\n  BuilderOp,\n  CompilableProgram,\n  CompileTimeCompilationContext,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  ProgramSymbolTable,\n} from \"@glimmer/interfaces\";\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { ATTRS_BLOCK, WrappedComponent } from './opcode-builder/helpers/components';\nimport { meta } from './opcode-builder/helpers/shared';\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nexport class WrappedBuilder implements CompilableProgram {\n  public symbolTable: ProgramSymbolTable;\n  private compiled: Nullable<number> = null;\n  private attrsBlockNumber: number;\n\n  constructor(private layout: LayoutWithContext, public moduleName: string) {\n    let { block } = layout;\n    let [, symbols, hasEval] = block;\n\n    symbols = symbols.slice();\n\n    // ensure ATTRS_BLOCK is always included (only once) in the list of symbols\n    let attrsBlockIndex = symbols.indexOf(ATTRS_BLOCK);\n    if (attrsBlockIndex === -1) {\n      this.attrsBlockNumber = symbols.push(ATTRS_BLOCK);\n    } else {\n      this.attrsBlockNumber = attrsBlockIndex + 1;\n    }\n\n    this.symbolTable = {\n      hasEval,\n      symbols,\n    };\n  }\n\n  compile(syntax: CompileTimeCompilationContext): HandleResult {\n    if (this.compiled !== null) return this.compiled;\n\n    let m = meta(this.layout);\n    let context = templateCompilationContext(syntax, m);\n\n    let {\n      encoder,\n      program: { constants, resolver },\n    } = context;\n\n    function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n      encodeOp(encoder, constants, resolver, m, op as BuilderOp | HighLevelOp);\n    }\n\n    WrappedComponent(pushOp, this.layout, this.attrsBlockNumber);\n\n    let handle = context.encoder.commit(m.size);\n\n    if (typeof handle !== 'number') {\n      return handle;\n    }\n\n    this.compiled = handle;\n\n    if (LOCAL_SHOULD_LOG) {\n      debugCompiler(context, handle);\n    }\n\n    return handle;\n  }\n}\n","import type {\n  CompilableProgram,\n  LayoutWithContext,\n  Nullable,\n  Owner,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  Template,\n  TemplateFactory,\n  TemplateOk,\n} from \"@glimmer/interfaces\";\nimport { assign } from '@glimmer/util';\n\nimport { compilable } from './compilable-template';\nimport { WrappedBuilder } from './wrapped-component';\n\nlet clientId = 0;\n\nexport let templateCacheCounters = {\n  cacheHit: 0,\n  cacheMiss: 0,\n};\n\n// These interfaces are for backwards compatibility, some addons use these intimate APIs\nexport interface TemplateFactoryWithIdAndMeta extends TemplateFactory {\n  __id?: string;\n  __meta?: { moduleName: string };\n}\n\nexport interface TemplateWithIdAndReferrer extends TemplateOk {\n  id: string;\n  referrer: {\n    moduleName: string;\n    owner: Owner | null;\n  };\n}\n\n/**\n * Wraps a template js in a template module to change it into a factory\n * that handles lazy parsing the template and to create per env singletons\n * of the template.\n */\nexport default function templateFactory({\n  id: templateId,\n  moduleName,\n  block,\n  scope,\n  isStrictMode,\n}: SerializedTemplateWithLazyBlock): TemplateFactory {\n  // TODO(template-refactors): This should be removed in the near future, as it\n  // appears that id is unused. It is currently kept for backwards compat reasons.\n  let id = templateId || `client-${clientId++}`;\n\n  // TODO: This caches JSON serialized output once in case a template is\n  // compiled by multiple owners, but we haven't verified if this is actually\n  // helpful. We should benchmark this in the future.\n  let parsedBlock: SerializedTemplateBlock;\n\n  let ownerlessTemplate: Template | null = null;\n  let templateCache = new WeakMap<object, Template>();\n\n  let factory: TemplateFactoryWithIdAndMeta = (owner?: Owner) => {\n    if (parsedBlock === undefined) {\n      parsedBlock = JSON.parse(block);\n    }\n\n    if (owner === undefined) {\n      if (ownerlessTemplate === null) {\n        templateCacheCounters.cacheMiss++;\n        ownerlessTemplate = new TemplateImpl({\n          id,\n          block: parsedBlock,\n          moduleName,\n          owner: null,\n          scope,\n          isStrictMode,\n        });\n      } else {\n        templateCacheCounters.cacheHit++;\n      }\n\n      return ownerlessTemplate;\n    }\n\n    let result = templateCache.get(owner) as Template;\n\n    if (result === undefined) {\n      templateCacheCounters.cacheMiss++;\n      result = new TemplateImpl({ id, block: parsedBlock, moduleName, owner, scope, isStrictMode });\n      templateCache.set(owner, result);\n    } else {\n      templateCacheCounters.cacheHit++;\n    }\n\n    return result;\n  };\n\n  factory.__id = id;\n  factory.__meta = { moduleName };\n\n  return factory;\n}\n\nclass TemplateImpl implements TemplateWithIdAndReferrer {\n  readonly result = 'ok';\n\n  private layout: Nullable<CompilableProgram> = null;\n  private wrappedLayout: Nullable<CompilableProgram> = null;\n\n  constructor(private parsedLayout: LayoutWithContext) {}\n\n  get moduleName() {\n    return this.parsedLayout.moduleName;\n  }\n\n  get id() {\n    return this.parsedLayout.id;\n  }\n\n  // TODO(template-refactors): This should be removed in the near future, it is\n  // only being exposed for backwards compatibility\n  get referrer() {\n    return {\n      moduleName: this.parsedLayout.moduleName,\n      owner: this.parsedLayout.owner,\n    };\n  }\n\n  asLayout(): CompilableProgram {\n    if (this.layout) return this.layout;\n    return (this.layout = compilable(assign({}, this.parsedLayout), this.moduleName));\n  }\n\n  asWrappedLayout(): CompilableProgram {\n    if (this.wrappedLayout) return this.wrappedLayout;\n    return (this.wrappedLayout = new WrappedBuilder(\n      assign({}, this.parsedLayout),\n      this.moduleName\n    ));\n  }\n}\n"],"names":["LOCAL_SHOULD_LOG","window","location","test","search","debugCompiler","makeResolutionTypeVerifier","typeToVerify","opcode","Array","isArray","length","isGetLikeTuple","type","SexpOpcodes","GetStrictKeyword","GetLexicalSymbol","context","result","handle","extractHandle","heap","program","start","getaddr","end","sizeof","debugSlice","isGetFreeComponent","GetFreeAsComponentHead","isGetFreeModifier","GetFreeAsModifierHead","isGetFreeHelper","GetFreeAsHelperHead","isGetFreeComponentOrHelper","GetFreeAsComponentOrHelperHead","isGetFreeOptionalHelper","GetFreeAsHelperHeadOrThisFallback","isGetFreeOptionalComponentOrHelper","GetFreeAsComponentOrHelperHeadOrThisFallback","assertResolverInvariants","meta","upvars","Error","owner","resolveOptionalHelper","resolver","constants","_ref5","expr","ifHelper","assert","GetFreeAsDeprecatedHelperHeadOrThisFallback","name","unwrap","helper","lookupHelper","moduleName","lookupBuiltInHelper","HighLevelResolutionOpcodes","Modifier","Component","Helper","OptionalHelper","ComponentOrHelper","OptionalComponentOrHelper","Free","Local","TemplateLocal","HighLevelBuilderOpcodes","Label","StartLabels","StopLabels","Start","End","HighLevelOperands","IsStrictMode","DebugSymbols","Block","StdLib","NonSmallInt","SymbolTable","Layout","labelOperand","value","isStrictMode","undefined","stdlibOperand","symbolTableOperand","layoutOperand","Labels","labels","dict","targets","label","index","this","target","at","push","patch","address","getbyaddr","setbyaddr","encodeOp","encoder","op","isBuilderOpcode","operands","startLabels","stopLabels","_ref","then","scopeValues","definition","expect","component","lookupComponent","resolvedComponent","resolveComponent","_ref3","modifier","lookupBuiltInModifier","lookupModifier","resolveModifier","_ref2","resolveHelper","_ref4","ifComponent","debugToString","resolveComponentOrHelper","_ref6","ifValue","resolveOptionalComponentOrHelper","freeVar","andThen","valueIndex","upvarIndex","freeName","EncoderImpl","labelsStack","Stack","InstructionEncoderImpl","errors","constructor","stdlib","malloc","error","encode","Op","Primitive","commit","size","pushMachine","MachineOp","Return","finishMalloc","isPresentArray","TYPE_SIZE","first","isMachineOp","MACHINE_MASK","arguments","ARG_SHIFT","pushRaw","i","operand","encodeHandle","array","currentLabels","offset","evalSymbols","EMPTY_STRING_ARRAY","block","containing","CompilableTemplateImpl","parameters","EMPTY_ARRAY","current","pop","main","trustingGuardedAppend","cautiousGuardedAppend","trustingNonDynamicAppend","cautiousNonDynamicAppend","getAppend","trusting","NamedBlocksImpl","names","blocks","Object","keys","get","has","with","assign","hasAny","EMPTY_BLOCKS","namedBlocks","out","values","key","enumerate","PushPrimitiveReference","PushPrimitive","PrimitiveReference","primitive","p","isSmallInt","encodeImmediate","Call","positional","named","PushFrame","SimpleArgs","PopFrame","Fetch","$v0","CallDynamic","append","Dup","$fp","DynamicHelper","Pop","Curry","CaptureArgs","Compilers","funcs","add","func","compile","sexp","EXPRESSIONS","withPath","path","GetProperty","expression","atNames","PushEmptyArgs","flags","CompilePositional","val","PushArgs","layout","symbols","scope","hasEval","YieldBlock","to","GetBlock","SpreadBlock","CompileBlock","InvokeYield","PopScope","PushYieldableBlock","PushSymbolTable","PushBlockScope","PushCompilable","InvokeStaticBlock","InvokeVirtual","InvokeStaticBlockWithStack","callerCount","calleeCount","count","Math","min","ChildScope","SetVariable","_block","Constant","SwitchCases","bootstrap","matcher","clauses","match","callback","Enter","clause","slice","JumpEq","Jump","Exit","Replayable","args","body","ReturnTo","ReplayableIf","ifTrue","ifFalse","JumpUnless","Concat","parts","part","GetSymbol","sym","GetVariable","ConstantReference","_path","_handle","_name","arg","deprecate","id","Undefined","HasBlock","_ref7","HasBlockParams","_ref8","IfInline","_ref9","condition","truthy","falsy","Not","_ref10","GetDynamicVar","_ref11","Log","_ref12","ATTRS_BLOCK","InvokeComponent","_elementBlock","_blocks","compilable","capabilities","elementBlock","PushComponentDefinition","symbolTable","bailOut","hasCapability","InternalComponentCapabilities","prepareArgs","InvokeNonStaticComponent","$s0","$sp","Load","blockSymbols","argSymbols","argNames","blockNames","symbol","indexOf","createArgs","BeginComponentTransaction","dynamicScope","PushDynamicScope","createInstance","CreateComponent","RegisterComponentDestructor","GetComponentSelf","RootScope","reverse","SetBlock","DidRenderLayout","PopDynamicScope","CommitComponentTransaction","InvokeStaticComponent","InvokeDynamicComponent","curried","ResolveCurriedComponent","ResolveDynamicComponent","PushDynamicComponentInstance","bindableBlocks","bindableAtNames","CompileArgs","PrepareArgs","invokePreparedComponent","GetComponentLayout","PopulateLayout","WrappedComponent","attrsBlockNumber","register","WithSavedRegister","$s1","GetComponentTagName","PutComponentOperations","OpenDynamicElement","DidCreateElement","FlushElement","CloseElement","hasBlock","populateLayout","VirtualRootScope","SetupForEval","SetNamedVariables","SetBlocks","InvokeComponentLayout","StdAppend","nonDynamicAppend","ContentType","when","String","AssertSame","AppendHTML","AppendText","InvokeBareComponent","InvokeStatic","SafeString","AppendSafeHTML","Fragment","AppendDocumentFragment","Node","AppendNode","compileStd","mainHandle","build","Main","trustingGuardedNonDynamicAppend","cautiousGuardedNonDynamicAppend","trustingGuardedDynamicAppend","cautiousGuardedDynamicAppend","STDLIB_META","builder","_len","_key","CompileTimeCompilationContextImpl","createOp","programCompilationContext","artifacts","templateCompilationContext","STATEMENTS","INFLATE_ATTR_TABLE","INFLATE_TAG_TABLE","inflateTagName","tagName","inflateAttrName","attrName","hashToArgs","hash","map","Comment","DynamicModifier","StaticAttr","namespace","StaticComponentAttr","DynamicAttr","TrustingDynamicAttr","ComponentAttr","TrustingComponentAttr","OpenElement","tag","OpenElementWithSplat","Yield","params","AttrSplat","Debugger","_ref13","debugInfo","Append","_ref14","DynamicContentType","Text","TrustingAppend","_ref15","_ref16","InElement","_ref17","guid","destination","insertBefore","PushRemoteElement","PopRemoteElement","If","_ref18","inverse","ToBoolean","Each","_ref19","EnterList","Iterate","ExitList","With","_ref20","Let","_ref21","WithDynamicVars","_ref22","expressions","BindDynamicScope","DynamicScope","_ref23","compiled","statements","compileStatements","maybeCompile","syntaxContext","sCompiler","pushOp","statement","DEFAULT_CAPABILITIES","dynamicLayout","dynamicTag","attributeHook","elementHook","createCaller","updateHook","wrapped","willDestroy","hasSubOwner","MINIMAL_CAPABILITIES","WrappedBuilder","attrsBlockIndex","syntax","m","clientId","templateCacheCounters","cacheHit","cacheMiss","templateFactory","parsedBlock","templateId","ownerlessTemplate","templateCache","WeakMap","factory","JSON","parse","TemplateImpl","set","__id","__meta","wrappedLayout","parsedLayout","referrer","asLayout","asWrappedLayout"],"mappings":"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"}
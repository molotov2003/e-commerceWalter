import{assertNever as e,dict as t,expect as r,isPresentArray as n,values as a,assert as s,NS_XMLNS as l,NS_XML as o,NS_XLINK as i,exhausted as c,mapPresentArray as u,unreachable as p,getLast as m,LOCAL_LOGGER as d,assertPresentArray as h}from"@glimmer/util";import{VariableResolutionContext as f,SexpOpcodes as k,WellKnownTagNames as y,WellKnownAttrNames as g}from"@glimmer/wire-format";import{node as v,generateSyntaxError as w,ASTv2 as A,KEYWORDS_TYPES as b,isKeyword as x,SourceSlice as C,src as E,maybeLoc as B,normalize as O}from"@glimmer/syntax";import{CurriedTypes as H}from"@glimmer/vm";let S=function(e){return e.Block="Block",e.Call="Call",e.Element="Element",e.AppendPath="AppendPath",e.AppendExpr="AppendExpr",e.Literal="Literal",e.Modifier="Modifier",e.DynamicComponent="DynamicComponent",e.Comment="Comment",e.Splat="Splat",e.Keyword="Keyword",e}({}),P=function(e){return e.Local="Local",e.Free="Free",e.Arg="Arg",e.Block="Block",e.This="This",e}({});function L(n){if(Array.isArray(n))return function(e){if(!Array.isArray(e))return!1;const t=e[0];if("number"==typeof t)switch(t){case z.Literal:case z.Get:case z.Concat:case z.HasBlock:case z.HasBlockParams:return!0;default:return!1}if("("===t[0])return!0;return!1}(n)?U(n):function(e){if(Array.isArray(e)&&"string"==typeof e[0])switch(e[0][0]){case"(":case"#":case"<":case"!":return!0;default:return!1}return!1}(n)?function(e){const n=e[0];switch(n[0]){case"(":{let t=null,r=null;return 3===e.length?(t=Y(e[1]),r=X(e[2])):2===e.length&&(Array.isArray(e[1])?t=Y(e[1]):r=X(e[1])),{kind:S.Call,head:G(n),params:t,hash:r,trusted:!1}}case"#":{const{head:t,params:r,hash:n,blocks:a,blockParams:s}=D(e);return{kind:S.Block,head:t,params:r,hash:n,blocks:a,blockParams:s}}case"!":{const t=e[0].slice(1),{params:r,hash:n,blocks:a,blockParams:s}=D(e);return{kind:S.Keyword,name:t,params:r,hash:n,blocks:a,blockParams:s}}case"<":{let a=t(),s=[];return 3===e.length?(a=W(e[1]),s=_(e[2])):2===e.length&&(Array.isArray(e[1])?s=_(e[1]):a=W(e[1])),{kind:S.Element,name:r(q(n),`BUG: expected ${n} to look like a tag name`),attrs:a,block:s}}default:throw new Error(`Unreachable ${JSON.stringify(e)} in normalizeSugaryArrayStatement`)}}(n):function(e){switch(e[0]){case z.Literal:return{kind:S.Literal,value:e[1]};case z.Append:return U(e[1],e[2]);case z.Modifier:return{kind:S.Modifier,params:Y(e[1]),hash:X(e[2])};case z.DynamicComponent:return{kind:S.DynamicComponent,expr:J(e[1]),hash:X(e[2]),block:_(e[3])};case z.Comment:return{kind:S.Comment,value:e[1]}}}(n);if("string"==typeof n)return N(I(n),!1);throw e(n)}function N(e,t){return e.type===R.GetPath?{kind:S.AppendPath,path:e,trusted:t}:{kind:S.AppendExpr,expr:e,trusted:t}}function T(e){const t=/^(#|!)(.*)$/u.exec(e);if(null===t)throw new Error("Unexpected missing # in block head");return I(t[2])}function G(e){const t=/^\((.*)\)$/u.exec(e);if(null===t)throw new Error("Unexpected missing () in call head");return I(t[1])}function $(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=F(e);return n(t)?{type:R.GetPath,path:{head:r,tail:t}}:{type:R.GetVar,variable:r}}function I(e){const{kind:t,name:r}=F(e),[a,...s]=r.split("."),l={kind:t,name:a,mode:"loose"};return n(s)?{type:R.GetPath,path:{head:l,tail:s}}:{type:R.GetVar,variable:l}}function F(e){let t,r;if(/^this(?:\.|$)/u.test(e))return{kind:P.This,name:e,mode:"loose"};switch(e[0]){case"^":t=P.Free,r=e.slice(1);break;case"@":t=P.Arg,r=e.slice(1);break;case"&":t=P.Block,r=e.slice(1);break;default:t=P.Local,r=e}return{kind:t,name:r,mode:"loose"}}function D(e){const r=e[0];let n=t(),a=null,s=null,l=null;return 2===e.length?n=V(e[1]):3===e.length?(Array.isArray(e[1])?a=Y(e[1]):({hash:s,blockParams:l}=M(e[1])),n=V(e[2])):4===e.length&&(a=Y(e[1]),({hash:s,blockParams:l}=M(e[2])),n=V(e[3])),{head:T(r),params:a,hash:s,blockParams:l,blocks:n}}function M(e){if(null===e)return{hash:null,blockParams:null};let r=null,n=null;return function(e,t){Object.keys(e).forEach((r=>{const n=e[r];t(r,n)}))}(e,((e,a)=>{"as"===e?n=Array.isArray(a)?a:[a]:(r=r||t(),r[e]=J(a))})),{hash:r,blockParams:n}}function V(e){return Array.isArray(e)?{default:_(e)}:j(e,_)}function _(e){return e.map((e=>L(e)))}function W(e){return j(e,(e=>function(e){if("splat"===e)return{expr:S.Splat,trusted:!1};return{expr:J(e),trusted:!1}}(e).expr))}function j(e,r){const n=t();return Object.keys(e).forEach((t=>{n[t]=r(e[t],t)})),n}function q(e){const t=/^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(e);return t?.[1]??null}let z=function(e){return e[e.Literal=0]="Literal",e[e.Comment=1]="Comment",e[e.Append=2]="Append",e[e.Modifier=3]="Modifier",e[e.DynamicComponent=4]="DynamicComponent",e[e.Get=5]="Get",e[e.Concat=6]="Concat",e[e.HasBlock=7]="HasBlock",e[e.HasBlockParams=8]="HasBlockParams",e}({}),R=function(e){return e.Literal="Literal",e.Call="Call",e.GetPath="GetPath",e.GetVar="GetVar",e.Concat="Concat",e.HasBlock="HasBlock",e.HasBlockParams="HasBlockParams",e}({});function U(t){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(null==t)return{expr:{type:R.Literal,value:t},kind:S.AppendExpr,trusted:!1};if(Array.isArray(t))switch(t[0]){case z.Literal:return{expr:{type:R.Literal,value:t[1]},kind:S.AppendExpr,trusted:!1};case z.Get:return N($(t[1],t[2]),r);case z.Concat:return{expr:{type:R.Concat,params:Y(t.slice(1))},kind:S.AppendExpr,trusted:r};case z.HasBlock:return{expr:{type:R.HasBlock,name:t[1]},kind:S.AppendExpr,trusted:r};case z.HasBlockParams:return{expr:{type:R.HasBlockParams,name:t[1]},kind:S.AppendExpr,trusted:r};default:if(K(t))return{expr:Z(t),kind:S.AppendExpr,trusted:r};throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return N(I(t),r);case"boolean":case"number":return{expr:{type:R.Literal,value:t},kind:S.AppendExpr,trusted:!0};default:throw e(t)}}}function J(t){if(null==t)return{type:R.Literal,value:t};if(Array.isArray(t))switch(t[0]){case z.Literal:return{type:R.Literal,value:t[1]};case z.Get:return $(t[1],t[2]);case z.Concat:return{type:R.Concat,params:Y(t.slice(1))};case z.HasBlock:return{type:R.HasBlock,name:t[1]};case z.HasBlockParams:return{type:R.HasBlockParams,name:t[1]};default:if(K(t))return Z(t);throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return I(t);case"boolean":case"number":return{type:R.Literal,value:t};default:throw e(t)}}}function K(e){return"string"==typeof e[0]&&"("===e[0][0]}function Y(e){return e.map(J)}function X(e){return null===e?null:j(e,J)}function Z(e){switch(e.length){case 1:return{type:R.Call,head:G(e[0]),params:null,hash:null};case 2:return Array.isArray(e[1])?{type:R.Call,head:G(e[0]),params:Y(e[1]),hash:null}:{type:R.Call,head:G(e[0]),params:null,hash:X(e[1])};case 3:return{type:R.Call,head:G(e[0]),params:Y(e[1]),hash:X(e[2])}}}class Q{_freeVariables=[];_symbols=["this"];top=this;toSymbols(){return this._symbols.slice(1)}toUpvars(){return this._freeVariables}freeVar(e){return te(this._freeVariables,e)}block(e){return this.symbol(e)}arg(e){return te(this._symbols,e)}local(e){throw new Error(`No local ${e} was found. Maybe you meant ^${e} for upvar, or !${e} for keyword?`)}this(){return 0}hasLocal(e){return!1}symbol(e){return te(this._symbols,e)}child(e){return new ee(this,e)}}class ee{locals=t();constructor(e,t){this.parent=e;for(let r of t)this.locals[r]=e.top.symbol(r)}get paramSymbols(){return a(this.locals)}get top(){return this.parent.top}freeVar(e){return this.parent.freeVar(e)}arg(e){return this.parent.arg(e)}block(e){return this.parent.block(e)}local(e){return e in this.locals?this.locals[e]:this.parent.local(e)}this(){return this.parent.this()}hasLocal(e){return e in this.locals||this.parent.hasLocal(e)}child(e){return new ee(this,e)}}function te(e,t){let r=e.indexOf(t);return-1===r?(r=e.length,e.push(t),r):r}function re(e){return new Error(`unimplemented ${e}`)}function ne(e,t){let r=[];return e.forEach((e=>r.push(...se(L(e),t)))),r}function ae(e,t){let r=[];return e.forEach((e=>r.push(...se(e,t)))),r}function se(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Q;switch(t.kind){case S.AppendPath:return[[t.trusted?k.TrustingAppend:k.Append,ye(t.path,r)]];case S.AppendExpr:return[[t.trusted?k.TrustingAppend:k.Append,fe(t.expr,t.trusted?"TrustedAppend":"Append",r)]];case S.Call:{let{head:e,params:n,hash:a,trusted:s}=t,l=n?ve(n,r):null,o=a?Ae(a,r):null,i=ke(e,s?f.AmbiguousInvoke:f.AmbiguousAppendInvoke,r);return[[s?k.TrustingAppend:k.Append,[k.Call,i,l,o]]]}case S.Literal:return[[k.Append,t.value]];case S.Comment:return[[k.Comment,t.value]];case S.Block:{let e=function(e,t,r){let n=[],a=[];for(const[s,l]of Object.entries(e))if(n.push(s),"default"===s){let e=r.child(t||[]);a.push(be(l,e,e.paramSymbols))}else a.push(be(l,r,[]));return[n,a]}(t.blocks,t.blockParams,r),n=Ae(t.hash,r),a=ve(t.params,r),s=ke(t.head,f.ResolveAsComponentHead,r);return[[k.Block,s,a,n,e]]}case S.Keyword:return[ue(t,r)];case S.Element:return function(t,r){let{name:a,attrs:l,block:o}=t,i=[pe(l)?[k.OpenElementWithSplat,a]:[k.OpenElement,a]];if(l){let{params:e,args:t}=function(e,t){let r=[],a=[],s=[];for(const[n,l]of Object.entries(e))l===S.Splat?r.push([k.AttrSplat,t.block("&attrs")]):"@"===n[0]?(a.push(n),s.push(fe(l,"Strict",t))):r.push(...de(n,l,me(n),t));return{params:r,args:n(a)&&n(s)?[a,s]:null}}(l,r);i.push(...e),s(null===t,"Can't pass args to a simple element")}if(i.push([k.FlushElement]),Array.isArray(o))o.forEach((e=>i.push(...se(e,r))));else if(null!==o)throw e(o);return i.push([k.CloseElement]),i}(t,r);case S.Modifier:throw re("modifier");case S.DynamicComponent:throw re("dynamic component");default:throw e(t)}}function le(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];let a=e.reduce(((e,t,n)=>e+`${t}${r[n]?String(r[n]):""}`),"");return[z.Literal,a]}function oe(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];let a=e.reduce(((e,t,n)=>e+`${t}${r[n]?String(r[n]):""}`),"");return[z.Comment,a]}function ie(e){return String.fromCharCode(parseInt(e,16))}const ce="\n";function ue(e,t){let{name:n}=e,a=ve(e.params,t),s=t.child(e.blockParams||[]),l=be(e.blocks.default,s,s.paramSymbols),o=e.blocks.else?be(e.blocks.else,t,[]):null;switch(n){case"with":return[k.With,r(a,"with requires params")[0],l,o];case"if":return[k.If,r(a,"if requires params")[0],l,o];case"each":{let n=e.hash?e.hash.key:null,s=n?fe(n,"Strict",t):null;return[k.Each,r(a,"if requires params")[0],s,l,o]}default:throw new Error("unimplemented keyword")}}function pe(e){return null!==e&&Object.keys(e).some((t=>e[t]===S.Splat))}function me(e){if("xmlns"===e)return l;let t=/^([^:]*):([^:]*)$/u.exec(e);if(null===t)return null;switch(t[1]){case"xlink":return i;case"xml":return o;case"xmlns":return l}return null}function de(e,t,r,n){if(t.type===R.Literal){let n=t.value;if(!1===n)return[];if(!0===n)return[[k.StaticAttr,e,"",r??void 0]];if("string"==typeof n)return[[k.StaticAttr,e,n,r??void 0]];throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(n)}`)}return[[k.DynamicAttr,e,fe(t,"AttrValue",n),r??void 0]]}function he(e,t){switch(e){case"Append":return t?"AppendBare":"AppendInvoke";case"TrustedAppend":return t?"TrustedAppendBare":"TrustedAppendInvoke";case"AttrValue":return t?"AttrValueBare":"AttrValueInvoke";default:return e}}function fe(t,r,n){switch(t.type){case R.GetPath:return ye(t,n);case R.GetVar:return ge(t.variable,he(r,!0),n);case R.Concat:return[k.Concat,we(t.params,n)];case R.Call:{let e=ve(t.params,n),a=Ae(t.hash,n),s=ke(t.head,"Strict"===r?"SubExpression":he(r,!1),n);return[k.Call,s,e,a]}case R.HasBlock:return[k.HasBlock,ge({kind:P.Block,name:t.name,mode:"loose"},f.Strict,n)];case R.HasBlockParams:return[k.HasBlockParams,ge({kind:P.Block,name:t.name,mode:"loose"},f.Strict,n)];case R.Literal:return void 0===t.value?[k.Undefined]:t.value;default:e(t)}}function ke(e,t,r){return e.type===R.GetVar?ge(e.variable,t,r):ye(e,r)}function ye(e,t){return ge(e.path.head,f.Strict,t,e.path.tail)}function ge(e,t,r,n){let a,s=k.GetSymbol;if(e.kind===P.Free)s="Strict"===t?k.GetStrictKeyword:"AppendBare"===t?k.GetFreeAsComponentOrHelperHeadOrThisFallback:"AppendInvoke"===t?k.GetFreeAsComponentOrHelperHead:"TrustedAppendBare"===t?k.GetFreeAsHelperHeadOrThisFallback:"TrustedAppendInvoke"===t?k.GetFreeAsHelperHead:"AttrValueBare"===t?k.GetFreeAsHelperHeadOrThisFallback:"AttrValueInvoke"===t||"SubExpression"===t?k.GetFreeAsHelperHead:function(e){switch(e){case f.Strict:return k.GetStrictKeyword;case f.AmbiguousAppend:return k.GetFreeAsComponentOrHelperHeadOrThisFallback;case f.AmbiguousAppendInvoke:return k.GetFreeAsComponentOrHelperHead;case f.AmbiguousInvoke:return k.GetFreeAsHelperHeadOrThisFallback;case f.ResolveAsCallHead:return k.GetFreeAsHelperHead;case f.ResolveAsModifierHead:return k.GetFreeAsModifierHead;case f.ResolveAsComponentHead:return k.GetFreeAsComponentHead;default:return c(e)}}(t),a=r.freeVar(e.name);else s=k.GetSymbol,a=function(e,t,r){switch(e){case P.Arg:return t.arg(r);case P.Block:return t.block(r);case P.Local:return t.local(r);case P.This:return t.this();default:return c(e)}}(e.kind,r,e.name);return void 0===n||0===n.length?[s,a]:[s,a,n]}function ve(e,t){return null!==e&&n(e)?e.map((e=>fe(e,"Strict",t))):null}function we(e,t){return e.map((e=>fe(e,"AttrValue",t)))}function Ae(e,t){if(null===e)return null;let r=[[],[]];for(const[n,a]of Object.entries(e))r[0].push(n),r[1].push(fe(a,"Strict",t));return r}function be(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return[ae(e,t),r]}const xe=!("undefined"==typeof window||!window.location||!/[&?]enable_local_should_log/u.test(window.location.search));class Ce extends(v("Template").fields()){}class Ee extends(v("InElement").fields()){}class Be extends(v("Not").fields()){}class Oe extends(v("If").fields()){}class He extends(v("IfInline").fields()){}class Se extends(v("Each").fields()){}class Pe extends(v("With").fields()){}class Le extends(v("Let").fields()){}class Ne extends(v("WithDynamicVars").fields()){}class Te extends(v("GetDynamicVar").fields()){}class Ge extends(v("Log").fields()){}class $e extends(v("InvokeComponent").fields()){}class Ie extends(v("NamedBlocks").fields()){}class Fe extends(v("NamedBlock").fields()){}v("EndBlock").fields();class De extends(v("AppendTrustedHTML").fields()){}class Me extends(v("AppendTextNode").fields()){}class Ve extends(v("AppendComment").fields()){}class _e extends(v("Component").fields()){}class We extends(v("StaticAttr").fields()){}class je extends(v("DynamicAttr").fields()){}class qe extends(v("SimpleElement").fields()){}class ze extends(v("ElementParameters").fields()){}class Re extends(v("Yield").fields()){}class Ue extends(v("Debugger").fields()){}class Je extends(v("CallExpression").fields()){}class Ke extends(v("DeprecatedCallExpression").fields()){}class Ye extends(v("Modifier").fields()){}class Xe extends(v("InvokeBlock").fields()){}class Ze extends(v("SplatAttr").fields()){}class Qe extends(v("PathExpression").fields()){}v("GetWithResolver").fields();v("GetSymbol").fields();v("GetFreeWithContext").fields();v("GetFree").fields();class et extends(v("Missing").fields()){}class tt extends(v("InterpolateExpression").fields()){}class rt extends(v("HasBlock").fields()){}class nt extends(v("HasBlockParams").fields()){}class at extends(v("Curry").fields()){}class st extends(v("Positional").fields()){}class lt extends(v("NamedArguments").fields()){}class ot extends(v("NamedArgument").fields()){}class it extends(v("Args").fields()){}class ct extends(v("Tail").fields()){}class ut{constructor(e){this.list=e}toArray(){return this.list}map(e){let t=u(this.list,e);return new ut(t)}filter(e){let t=[];for(let r of this.list)e(r)&&t.push(r);return mt(t)}toPresentArray(){return this.list}into(e){let{ifPresent:t}=e;return t(this)}}class pt{list=[];map(e){return new pt}filter(e){return new pt}toArray(){return this.list}toPresentArray(){return null}into(e){let{ifEmpty:t}=e;return t()}}function mt(e){return n(e)?new ut(e):new pt}class dt{static all(){let e=[];for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];for(let t of r){if(t.isErr)return t.cast();e.push(t.value)}return yt(e)}}const ht=dt;class ft extends dt{isOk=!0;isErr=!1;constructor(e){super(),this.value=e}expect(e){return this.value}ifOk(e){return e(this.value),this}andThen(e){return e(this.value)}mapOk(e){return yt(e(this.value))}ifErr(e){return this}mapErr(e){return this}}class kt extends dt{isOk=!1;isErr=!0;constructor(e){super(),this.reason=e}expect(e){throw new Error(e||"expected an Ok, got Err")}andThen(e){return this.cast()}mapOk(e){return this.cast()}ifOk(e){return this}mapErr(e){return gt(e(this.reason))}ifErr(e){return e(this.reason),this}cast(){return this}}function yt(e){return new ft(e)}function gt(e){return new kt(e)}class vt{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.items=e}add(e){this.items.push(e)}toArray(){let e=this.items.filter((e=>e instanceof kt))[0];return void 0!==e?e.cast():yt(this.items.map((e=>e.value)))}toOptionalList(){return this.toArray().mapOk((e=>mt(e)))}}function wt(e){return"Path"===e.callee.type}function At(e){var t;if("Path"===(t=e).callee.type&&"Free"===t.callee.ref.type&&!A.isStrictResolution(t.callee.ref.resolution)&&!function(e){if("Path"===e.type){let{ref:t,tail:r}=e;return"Free"===t.type&&!A.isStrictResolution(t.resolution)&&0===r.length}return!1}(e.callee))throw w(`\`${bt(e.callee)}\` is not a valid name for a modifier`,e.loc)}function bt(e){switch(e.type){case"Literal":return JSON.stringify(e.value);case"Path":{let t=[xt(e.ref)];return t.push(...e.tail.map((e=>e.chars))),t.join(".")}case"Call":return`(${bt(e.callee)} ...)`;case"DeprecatedCall":return`${e.callee.name}`;case"Interpolate":throw p("a concat statement cannot appear as the head of an expression")}}function xt(e){switch(e.type){case"Arg":return e.name.chars;case"Free":case"Local":return e.name;case"This":return"this"}}function Ct(e){return"Path"===e.type&&"Free"===e.ref.type&&e.ref.name in b?new A.CallExpression({callee:e,args:A.Args.empty(e.loc),loc:e.loc}):e}const Et=new class{visit(e,t){switch(e.type){case"Literal":return yt(this.Literal(e));case"Interpolate":return this.Interpolate(e,t);case"Path":return this.PathExpression(e);case"Call":{let r=Ut.translate(e,t);return null!==r?r:this.CallExpression(e,t)}case"DeprecatedCall":return this.DeprecaedCallExpression(e,t)}}visitList(e,t){return new vt(e.map((e=>Et.visit(e,t)))).toOptionalList()}PathExpression(e){let t=this.VariableReference(e.ref),{tail:r}=e;if(n(r)){let n=r[0].loc.extend(m(r).loc);return yt(new Qe({loc:e.loc,head:t,tail:new ct({loc:n,members:r})}))}return yt(t)}VariableReference(e){return e}Literal(e){return e}Interpolate(e,t){let r=e.parts.map(Ct);return Et.visitList(r,t).mapOk((t=>new tt({loc:e.loc,parts:t})))}CallExpression(e,t){if(wt(e))return ht.all(Et.visit(e.callee,t),Et.Args(e.args,t)).mapOk((t=>{let[r,n]=t;return new Je({loc:e.loc,callee:r,args:n})}));throw new Error("unimplemented subexpression at the head of a subexpression")}DeprecaedCallExpression(e,t){let{arg:r,callee:n,loc:a}=e;return yt(new Ke({loc:a,arg:r,callee:n}))}Args(e,t){let{positional:r,named:n,loc:a}=e;return ht.all(this.Positional(r,t),this.NamedArguments(n,t)).mapOk((e=>{let[t,r]=e;return new it({loc:a,positional:t,named:r})}))}Positional(e,t){return Et.visitList(e.exprs,t).mapOk((t=>new st({loc:e.loc,list:t})))}NamedArguments(e,t){let r=e.entries.map((e=>{let r=Ct(e.value);return Et.visit(r,t).mapOk((t=>new ot({loc:e.loc,key:e.name,value:t})))}));return new vt(r).toOptionalList().mapOk((t=>new lt({loc:e.loc,entries:t})))}};class Bt{types;constructor(e,t,r){this.keyword=e,this.delegate=r;let n=new Set;for(let e of Ot[t])n.add(e);this.types=n}match(e){if(!this.types.has(e.type))return!1;let t=Ht(e);return null!==t&&"Path"===t.type&&"Free"===t.ref.type&&(!(t.tail.length>0&&"Loose"===t.ref.resolution.serialize())&&t.ref.name===this.keyword)}translate(e,t){if(this.match(e)){let r=Ht(e);return null!==r&&"Path"===r.type&&r.tail.length>0?gt(w(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${r.loc.asString()}\`, but it cannot be used with additional path segments. \n\nError caused by`,e.loc)):this.delegate.assert(e,t).andThen((r=>this.delegate.translate({node:e,state:t},r)))}return null}}const Ot={Call:["Call"],Block:["InvokeBlock"],Append:["AppendContent"],Modifier:["ElementModifier"]};function Ht(e){switch(e.type){case"Path":return e;case"AppendContent":return Ht(e.value);case"Call":case"InvokeBlock":case"ElementModifier":return e.callee;default:return null}}class St{_keywords=[];_type;constructor(e){this._type=e}kw(e,t){return this._keywords.push(function(e,t,r){return new Bt(e,t,r)}(e,this._type,t)),this}translate(e,t){for(let r of this._keywords){let n=r.translate(e,t);if(null!==n)return n}let r=Ht(e);if(r&&"Path"===r.type&&"Free"===r.ref.type&&x(r.ref.name)){let{name:t}=r.ref,n=this._type,a=b[t];if(!a.includes(n))return gt(w(`The \`${t}\` keyword was used incorrectly. It was used as ${Pt[n]}, but its valid usages are:\n\n${function(e,t){return t.map((t=>{switch(t){case"Append":return`- As an append statement, as in: {{${e}}}`;case"Block":return`- As a block statement, as in: {{#${e}}}{{/${e}}}`;case"Call":return`- As an expression, as in: (${e})`;case"Modifier":return`- As a modifier, as in: <div {{${e}}}></div>`;default:return c(t)}})).join("\n\n")}(t,a)}\n\nError caused by`,e.loc))}return null}}const Pt={Append:"an append statement",Block:"a block statement",Call:"a call expression",Modifier:"a modifier"};function Lt(e){return new St(e)}function Nt(e){let{assert:t,translate:r}=e;return{assert:t,translate(e,t){let{node:n,state:a}=e;return r({node:n,state:a},t).mapOk((e=>new Me({text:e,loc:n.loc})))}}}const Tt={[H.Component]:"component",[H.Helper]:"helper",[H.Modifier]:"modifier"};function Gt(e){return(t,r)=>{let n=Tt[e],a=e===H.Component,{args:s}=t,l=s.nth(0);if(null===l)return gt(w(`(${n}) requires a ${n} definition or identifier as its first positional parameter, did not receive any parameters.`,s.loc));if("Literal"===l.type){if(a&&r.isStrict)return gt(w(`(${n}) cannot resolve string values in strict mode templates`,t.loc));if(!a)return gt(w(`(${n}) cannot resolve string values, you must pass a ${n} definition directly`,t.loc))}return s=new A.Args({positional:new A.PositionalArguments({exprs:s.positional.exprs.slice(1),loc:s.positional.loc}),named:s.named,loc:s.loc}),yt({definition:l,args:s})}}function $t(e){return(t,r)=>{let{node:n,state:a}=t,{definition:s,args:l}=r,o=Et.visit(s,a),i=Et.Args(l,a);return ht.all(o,i).mapOk((t=>{let[r,a]=t;return new at({loc:n.loc,curriedType:e,definition:r,args:a})}))}}function It(e){return{assert:Gt(e),translate:$t(e)}}const Ft={assert:function(e){let t="AppendContent"===e.type?e.value:e,r="Call"===t.type?t.args.named:null,n="Call"===t.type?t.args.positional:null;if(r&&!r.isEmpty())return gt(w("(-get-dynamic-vars) does not take any named arguments",e.loc));let a=n?.nth(0);return a?n&&n.size>1?gt(w("(-get-dynamic-vars) only receives one positional arg",e.loc)):yt(a):gt(w("(-get-dynamic-vars) requires a var name to get",e.loc))},translate:function(e,t){let{node:r,state:n}=e;return Et.visit(t,n).mapOk((e=>new Te({name:e,loc:r.loc})))}};function Dt(e){return t=>{let r="AppendContent"===t.type?t.value:t,n="Call"===r.type?r.args.named:null,a="Call"===r.type?r.args.positional:null;if(n&&!n.isEmpty())return gt(w(`(${e}) does not take any named arguments`,r.loc));if(!a||a.isEmpty())return yt(C.synthetic("default"));if(1===a.exprs.length){let t=a.exprs[0];return A.isLiteral(t,"string")?yt(t.toSlice()):gt(w(`(${e}) can only receive a string literal as its first argument`,r.loc))}return gt(w(`(${e}) only takes a single positional argument`,r.loc))}}function Mt(e){return(t,r)=>{let{node:n,state:{scope:a}}=t;return yt("has-block"===e?new rt({loc:n.loc,target:r,symbol:a.allocateBlock(r.chars)}):new nt({loc:n.loc,target:r,symbol:a.allocateBlock(r.chars)}))}}function Vt(e){return{assert:Dt(e),translate:Mt(e)}}function _t(e){return t=>{let r="unless"===e,n="AppendContent"===t.type?t.value:t,a="Call"===n.type?n.args.named:null,s="Call"===n.type?n.args.positional:null;if(a&&!a.isEmpty())return gt(w(`(${e}) cannot receive named parameters, received ${a.entries.map((e=>e.name.chars)).join(", ")}`,t.loc));let l=s?.nth(0);if(!s||!l)return gt(w(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Did not receive any parameters`,t.loc));let o=s.nth(1),i=s.nth(2);return null===o?gt(w(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Received only one parameter, the condition`,t.loc)):s.size>3?gt(w(`When used inline, (${e}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${e}), 2. the value to return if the condition is ${r?"false":"true"}, and 3. the value to return if the condition is ${r?"true":"false"}. Received ${s?.size??0} parameters`,t.loc)):yt({condition:l,truthy:o,falsy:i})}}function Wt(e){let t="unless"===e;return(e,r)=>{let{node:n,state:a}=e,{condition:s,truthy:l,falsy:o}=r,i=Et.visit(s,a),c=Et.visit(l,a),u=o?Et.visit(o,a):yt(null);return ht.all(i,c,u).mapOk((e=>{let[r,a,s]=e;return t&&(r=new Be({value:r,loc:n.loc})),new He({loc:n.loc,condition:r,truthy:a,falsy:s})}))}}function jt(e){return{assert:_t(e),translate:Wt(e)}}const qt={assert:function(e){let{args:{named:t,positional:r}}=e;return t&&!t.isEmpty()?gt(w("(log) does not take any named arguments",e.loc)):yt(r)},translate:function(e,t){let{node:r,state:n}=e;return Et.Positional(t,n).mapOk((e=>new Ge({positional:e,loc:r.loc})))}},zt=Lt("Append").kw("has-block",Nt(Vt("has-block"))).kw("has-block-params",Nt(Vt("has-block-params"))).kw("-get-dynamic-var",Nt(Ft)).kw("log",Nt(qt)).kw("if",Nt(jt("if"))).kw("unless",Nt(jt("unless"))).kw("yield",{assert(e){let{args:t}=e;if(t.named.isEmpty())return yt({target:E.SourceSpan.synthetic("default").toSlice(),positional:t.positional});{let e=t.named.get("to");return t.named.size>1||null===e?gt(w("yield only takes a single named argument: 'to'",t.named.loc)):A.isLiteral(e,"string")?yt({target:e.toSlice(),positional:t.positional}):gt(w("you can only yield to a literal string value",e.loc))}},translate(e,t){let{node:r,state:n}=e,{target:a,positional:s}=t;return Et.Positional(s,n).mapOk((e=>new Re({loc:r.loc,target:a,to:n.scope.allocateBlock(a.chars),positional:e})))}}).kw("debugger",{assert(e){let{args:t}=e,{positional:r}=t;return t.isEmpty()?yt(void 0):r.isEmpty()?gt(w("debugger does not take any named arguments",e.loc)):gt(w("debugger does not take any positional arguments",e.loc))},translate(e){let{node:t,state:{scope:r}}=e;return r.setHasDebugger(),yt(new Ue({loc:t.loc,scope:r}))}}).kw("component",{assert:Gt(H.Component),translate(e,t){let{node:r,state:n}=e,{definition:a,args:s}=t,l=Et.visit(a,n),o=Et.Args(s,n);return ht.all(l,o).mapOk((e=>{let[t,n]=e;return new $e({loc:r.loc,definition:t,args:n,blocks:null})}))}}).kw("helper",{assert:Gt(H.Helper),translate(e,t){let{node:r,state:n}=e,{definition:a,args:s}=t,l=Et.visit(a,n),o=Et.Args(s,n);return ht.all(l,o).mapOk((e=>{let[t,n]=e,a=new Je({callee:t,args:n,loc:r.loc});return new Me({loc:r.loc,text:a})}))}}),Rt=Lt("Block").kw("in-element",{assert(e){let{args:t}=e,r=t.get("guid");if(r)return gt(w("Cannot pass `guid` to `{{#in-element}}`",r.loc));let n=t.get("insertBefore"),a=t.nth(0);return null===a?gt(w("{{#in-element}} requires a target element as its first positional parameter",t.loc)):yt({insertBefore:n,destination:a})},translate(e,t){let{node:r,state:n}=e,{insertBefore:a,destination:s}=t,l=r.blocks.get("default"),o=cr.NamedBlock(l,n),i=Et.visit(s,n);return ht.all(o,i).andThen((e=>{let[t,s]=e;return a?Et.visit(a,n).mapOk((e=>({body:t,destination:s,insertBefore:e}))):yt({body:t,destination:s,insertBefore:new et({loc:r.callee.loc.collapse("end")})})})).mapOk((e=>{let{body:t,destination:a,insertBefore:s}=e;return new Ee({loc:r.loc,block:t,insertBefore:s,guid:n.generateUniqueCursor(),destination:a})}))}}).kw("if",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return gt(w(`{{#if}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return gt(w(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?gt(w("{{#if}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):yt({condition:r})},translate(e,t){let{node:r,state:n}=e,{condition:a}=t,s=r.blocks.get("default"),l=r.blocks.get("else"),o=Et.visit(a,n),i=cr.NamedBlock(s,n),c=l?cr.NamedBlock(l,n):yt(null);return ht.all(o,i,c).mapOk((e=>{let[t,n,a]=e;return new Oe({loc:r.loc,condition:t,block:n,inverse:a})}))}}).kw("unless",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return gt(w(`{{#unless}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return gt(w(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?gt(w("{{#unless}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):yt({condition:r})},translate(e,t){let{node:r,state:n}=e,{condition:a}=t,s=r.blocks.get("default"),l=r.blocks.get("else"),o=Et.visit(a,n),i=cr.NamedBlock(s,n),c=l?cr.NamedBlock(l,n):yt(null);return ht.all(o,i,c).mapOk((e=>{let[t,n,a]=e;return new Oe({loc:r.loc,condition:new Be({value:t,loc:r.loc}),block:n,inverse:a})}))}}).kw("each",{assert(e){let{args:t}=e;if(!t.named.entries.every((e=>"key"===e.name.chars)))return gt(w(`{{#each}} can only receive the 'key' named parameter, received ${t.named.entries.filter((e=>"key"!==e.name.chars)).map((e=>e.name.chars)).join(", ")}`,t.named.loc));if(t.positional.size>1)return gt(w(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${t.positional.size} parameters`,t.positional.loc));let r=t.nth(0),n=t.get("key");return null===r?gt(w("{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters",t.loc)):yt({value:r,key:n})},translate(e,t){let{node:r,state:n}=e,{value:a,key:s}=t,l=r.blocks.get("default"),o=r.blocks.get("else"),i=Et.visit(a,n),c=s?Et.visit(s,n):yt(null),u=cr.NamedBlock(l,n),p=o?cr.NamedBlock(o,n):yt(null);return ht.all(i,c,u,p).mapOk((e=>{let[t,n,a,s]=e;return new Se({loc:r.loc,value:t,key:n,block:a,inverse:s})}))}}).kw("with",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return gt(w(`{{#with}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,t.named.loc));if(t.positional.size>1)return gt(w(`{{#with}} can only receive one positional parameter. Received ${t.positional.size} parameters`,t.positional.loc));let r=t.nth(0);return null===r?gt(w("{{#with}} requires a value as its first positional parameter, did not receive any parameters",t.loc)):yt({value:r})},translate(e,t){let{node:r,state:n}=e,{value:a}=t,s=r.blocks.get("default"),l=r.blocks.get("else"),o=Et.visit(a,n),i=cr.NamedBlock(s,n),c=l?cr.NamedBlock(l,n):yt(null);return ht.all(o,i,c).mapOk((e=>{let[t,n,a]=e;return new Pe({loc:r.loc,value:t,block:n,inverse:a})}))}}).kw("let",{assert(e){let{args:t}=e;return t.named.isEmpty()?0===t.positional.size?gt(w("{{#let}} requires at least one value as its first positional parameter, did not receive any parameters",t.positional.loc)):e.blocks.get("else")?gt(w("{{#let}} cannot receive an {{else}} block",t.positional.loc)):yt({positional:t.positional}):gt(w(`{{#let}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,t.named.loc))},translate(e,t){let{node:r,state:n}=e,{positional:a}=t,s=r.blocks.get("default"),l=Et.Positional(a,n),o=cr.NamedBlock(s,n);return ht.all(l,o).mapOk((e=>{let[t,n]=e;return new Le({loc:r.loc,positional:t,block:n})}))}}).kw("-with-dynamic-vars",{assert:e=>yt({named:e.args.named}),translate(e,t){let{node:r,state:n}=e,{named:a}=t,s=r.blocks.get("default"),l=Et.NamedArguments(a,n),o=cr.NamedBlock(s,n);return ht.all(l,o).mapOk((e=>{let[t,n]=e;return new Ne({loc:r.loc,named:t,block:n})}))}}).kw("component",{assert:Gt(H.Component),translate(e,t){let{node:r,state:n}=e,{definition:a,args:s}=t,l=Et.visit(a,n),o=Et.Args(s,n),i=cr.NamedBlocks(r.blocks,n);return ht.all(l,o,i).mapOk((e=>{let[t,n,a]=e;return new $e({loc:r.loc,definition:t,args:n,blocks:a})}))}}),Ut=Lt("Call").kw("has-block",Vt("has-block")).kw("has-block-params",Vt("has-block-params")).kw("-get-dynamic-var",Ft).kw("log",qt).kw("if",jt("if")).kw("unless",jt("unless")).kw("component",It(H.Component)).kw("helper",It(H.Helper)).kw("modifier",It(H.Modifier)),Jt=Lt("Modifier"),Kt="http://www.w3.org/1999/xlink",Yt="http://www.w3.org/XML/1998/namespace",Xt="http://www.w3.org/2000/xmlns/",Zt={"xlink:actuate":Kt,"xlink:arcrole":Kt,"xlink:href":Kt,"xlink:role":Kt,"xlink:show":Kt,"xlink:title":Kt,"xlink:type":Kt,"xml:base":Yt,"xml:lang":Yt,"xml:space":Yt,xmlns:Xt,"xmlns:xlink":Xt};const Qt={div:y.div,span:y.span,p:y.p,a:y.a},er=["div","span","p","a"];function tr(e){return"string"==typeof e?e:er[e]}const rr={class:g.class,id:g.id,value:g.value,name:g.name,type:g.type,style:g.style,href:g.href},nr=["class","id","value","name","type","style","href"];function ar(e){return rr[e]??e}function sr(e){return"string"==typeof e?e:nr[e]}class lr{delegate;constructor(e,t,r){this.element=e,this.state=r,this.delegate=t}toStatement(){return this.prepare().andThen((e=>this.delegate.toStatement(this,e)))}attr(e){let t=e.name,r=e.value,n=(a=t.chars,Zt[a]||void 0);var a;return A.isLiteral(r,"string")?yt(new We({loc:e.loc,name:t,value:r.toSlice(),namespace:n,kind:{component:this.delegate.dynamicFeatures}})):Et.visit(Ct(r),this.state).mapOk((r=>{let a=e.trusting;return new je({loc:e.loc,name:t,value:r,namespace:n,kind:{trusting:a,component:this.delegate.dynamicFeatures}})}))}modifier(e){(function(e){return!!wt(e)&&!e.args.isEmpty()})(e)&&At(e);let t=Jt.translate(e,this.state);if(null!==t)return t;let r=Et.visit(e.callee,this.state),n=Et.Args(e.args,this.state);return ht.all(r,n).mapOk((t=>{let[r,n]=t;return new Ye({loc:e.loc,callee:r,args:n})}))}attrs(){let e=new vt,t=new vt,r=null,n=0===this.element.attrs.filter((e=>"SplatAttr"===e.type)).length;for(let t of this.element.attrs)"SplatAttr"===t.type?e.add(yt(new Ze({loc:t.loc,symbol:this.state.scope.allocateBlock("attrs")}))):"type"===t.name.chars&&n?r=t:e.add(this.attr(t));for(let e of this.element.componentArgs)t.add(this.delegate.arg(e,this));return r&&e.add(this.attr(r)),ht.all(t.toArray(),e.toArray()).mapOk((e=>{let[t,r]=e;return{attrs:r,args:new lt({loc:B(t,E.SourceSpan.NON_EXISTENT),entries:mt(t)})}}))}prepare(){let e=this.attrs(),t=new vt(this.element.modifiers.map((e=>this.modifier(e)))).toArray();return ht.all(e,t).mapOk((e=>{let[t,r]=e,{attrs:n,args:a}=t,s=[...n,...r];return{args:a,params:new ze({loc:B(s,E.SourceSpan.NON_EXISTENT),body:mt(s)})}}))}}class or{dynamicFeatures=!0;constructor(e,t){this.tag=e,this.element=t}arg(e,t){let{state:r}=t,n=e.name;return Et.visit(Ct(e.value),r).mapOk((t=>new ot({loc:e.loc,key:n,value:t})))}toStatement(e,t){let{args:r,params:n}=t,{element:a,state:s}=e;return this.blocks(s).mapOk((e=>new _e({loc:a.loc,tag:this.tag,params:n,args:r,blocks:e})))}blocks(e){return cr.NamedBlocks(this.element.blocks,e)}}class ir{constructor(e,t,r){this.tag=e,this.element=t,this.dynamicFeatures=r}isComponent=!1;arg(e){return gt(w(`${e.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`,e.loc))}toStatement(e,t){let{params:r}=t,{state:n,element:a}=e;return cr.visitList(this.element.body,n).mapOk((e=>new qe({loc:a.loc,tag:this.tag,params:r,body:e.toArray(),dynamicFeatures:this.dynamicFeatures})))}}const cr=new class{visitList(e,t){return new vt(e.map((e=>cr.visit(e,t)))).toOptionalList().mapOk((e=>e.filter((e=>null!==e))))}visit(e,t){switch(e.type){case"GlimmerComment":return yt(null);case"AppendContent":return this.AppendContent(e,t);case"HtmlText":return yt(this.TextNode(e));case"HtmlComment":return yt(this.HtmlComment(e));case"InvokeBlock":return this.InvokeBlock(e,t);case"InvokeComponent":return this.Component(e,t);case"SimpleElement":return this.SimpleElement(e,t)}}InvokeBlock(e,t){let r=Rt.translate(e,t);if(null!==r)return r;let n=Et.visit(e.callee,t),a=Et.Args(e.args,t);return ht.all(n,a).andThen((r=>{let[n,a]=r;return this.NamedBlocks(e.blocks,t).mapOk((t=>new Xe({loc:e.loc,head:n,args:a,blocks:t})))}))}NamedBlocks(e,t){return new vt(e.blocks.map((e=>this.NamedBlock(e,t)))).toArray().mapOk((t=>new Ie({loc:e.loc,blocks:mt(t)})))}NamedBlock(e,t){return t.visitBlock(e.block).mapOk((t=>new Fe({loc:e.loc,name:e.name,body:t.toArray(),scope:e.block.scope})))}SimpleElement(e,t){return new lr(e,new ir(e.tag,e,function(e){let{attrs:t,modifiers:r}=e;return r.length>0||!!t.filter((e=>"SplatAttr"===e.type))[0]}(e)),t).toStatement()}Component(e,t){return Et.visit(e.callee,t).andThen((r=>new lr(e,new or(r,e),t).toStatement()))}AppendContent(e,t){let r=zt.translate(e,t);return null!==r?r:Et.visit(e.value,t).mapOk((t=>e.trusting?new De({loc:e.loc,html:t}):new Me({loc:e.loc,text:t})))}TextNode(e){return new Me({loc:e.loc,text:new A.LiteralExpression({loc:e.loc,value:e.chars})})}HtmlComment(e){return new Ve({loc:e.loc,value:e.text})}};class ur{_currentScope;_cursorCount=0;constructor(e,t){this.isStrict=t,this._currentScope=e}generateUniqueCursor(){return`%cursor:${this._cursorCount++}%`}get scope(){return this._currentScope}visitBlock(e){let t=this._currentScope;this._currentScope=e.scope;try{return cr.visitList(e.body,this)}finally{this._currentScope=t}}}class pr{upvars;symbols;constructor(e){let[t,r,n,a]=e;this.upvars=a,this.symbols=r}format(e){let t=[];for(let r of e[0])t.push(this.formatOpcode(r));return t}formatOpcode(e){if(!Array.isArray(e))return e;switch(e[0]){case k.Append:return["append",this.formatOpcode(e[1])];case k.TrustingAppend:return["trusting-append",this.formatOpcode(e[1])];case k.Block:return["block",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case k.InElement:return["in-element",e[1],this.formatOpcode(e[2]),e[3]?this.formatOpcode(e[3]):void 0];case k.OpenElement:return["open-element",tr(e[1])];case k.OpenElementWithSplat:return["open-element-with-splat",tr(e[1])];case k.CloseElement:return["close-element"];case k.FlushElement:return["flush-element"];case k.StaticAttr:return["static-attr",sr(e[1]),e[2],e[3]];case k.StaticComponentAttr:return["static-component-attr",sr(e[1]),e[2],e[3]];case k.DynamicAttr:return["dynamic-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.ComponentAttr:return["component-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.AttrSplat:return["attr-splat"];case k.Yield:return["yield",e[1],this.formatParams(e[2])];case k.DynamicArg:return["dynamic-arg",e[1],this.formatOpcode(e[2])];case k.StaticArg:return["static-arg",e[1],this.formatOpcode(e[2])];case k.TrustingDynamicAttr:return["trusting-dynamic-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.TrustingComponentAttr:return["trusting-component-attr",sr(e[1]),this.formatOpcode(e[2]),e[3]];case k.Debugger:return["debugger",e[1]];case k.Comment:return["comment",e[1]];case k.Modifier:return["modifier",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case k.Component:return["component",this.formatOpcode(e[1]),this.formatElementParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case k.HasBlock:return["has-block",this.formatOpcode(e[1])];case k.HasBlockParams:return["has-block-params",this.formatOpcode(e[1])];case k.Curry:return["curry",this.formatOpcode(e[1]),this.formatCurryType(e[2]),this.formatParams(e[3]),this.formatHash(e[4])];case k.Undefined:return["undefined"];case k.Call:return["call",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case k.Concat:return["concat",this.formatParams(e[1])];case k.GetStrictKeyword:return["get-strict-free",this.upvars[e[1]],e[2]];case k.GetFreeAsComponentOrHelperHeadOrThisFallback:return["GetFreeAsComponentOrHelperHeadOrThisFallback",this.upvars[e[1]],e[2]];case k.GetFreeAsComponentOrHelperHead:return["GetFreeAsComponentOrHelperHead",this.upvars[e[1]],e[2]];case k.GetFreeAsHelperHeadOrThisFallback:return["GetFreeAsHelperHeadOrThisFallback",this.upvars[e[1]],e[2]];case k.GetFreeAsDeprecatedHelperHeadOrThisFallback:return["GetFreeAsDeprecatedHelperHeadOrThisFallback",this.upvars[e[1]]];case k.GetFreeAsHelperHead:return["GetFreeAsHelperHead",this.upvars[e[1]],e[2]];case k.GetFreeAsComponentHead:return["GetFreeAsComponentHead",this.upvars[e[1]],e[2]];case k.GetFreeAsModifierHead:return["GetFreeAsModifierHead",this.upvars[e[1]],e[2]];case k.GetSymbol:return 0===e[1]?["get-symbol","this",e[2]]:["get-symbol",this.symbols[e[1]-1],e[2]];case k.GetLexicalSymbol:return["get-template-symbol",e[1],e[2]];case k.If:return["if",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case k.IfInline:return["if-inline"];case k.Not:return["not"];case k.Each:return["each",this.formatOpcode(e[1]),e[2]?this.formatOpcode(e[2]):null,this.formatBlock(e[3]),e[4]?this.formatBlock(e[4]):null];case k.With:return["with",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case k.Let:return["let",this.formatParams(e[1]),this.formatBlock(e[2])];case k.Log:return["log",this.formatParams(e[1])];case k.WithDynamicVars:return["-with-dynamic-vars",this.formatHash(e[1]),this.formatBlock(e[2])];case k.GetDynamicVar:return["-get-dynamic-vars",this.formatOpcode(e[1])];case k.InvokeComponent:return["component",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])]}}formatCurryType(e){switch(e){case H.Component:return"component";case H.Helper:return"helper";case H.Modifier:return"modifier";default:throw c(e)}}formatElementParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatHash(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatOpcode(e[1][n]),t)),t())}formatBlocks(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatBlock(e[1][n]),t)),t())}formatBlock(e){return{statements:e[0].map((e=>this.formatOpcode(e))),parameters:e[1]}}}const mr=new class{expr(e){switch(e.type){case"Missing":return;case"Literal":return this.Literal(e);case"CallExpression":return this.CallExpression(e);case"DeprecatedCallExpression":return this.DeprecatedCallExpression(e);case"PathExpression":return this.PathExpression(e);case"Arg":return[k.GetSymbol,e.symbol];case"Local":return this.Local(e);case"This":return[k.GetSymbol,0];case"Free":return[e.resolution.resolution(),e.symbol];case"HasBlock":return this.HasBlock(e);case"HasBlockParams":return this.HasBlockParams(e);case"Curry":return this.Curry(e);case"Not":return this.Not(e);case"IfInline":return this.IfInline(e);case"InterpolateExpression":return this.InterpolateExpression(e);case"GetDynamicVar":return this.GetDynamicVar(e);case"Log":return this.Log(e)}}Literal(e){let{value:t}=e;return void 0===t?[k.Undefined]:t}Missing(){}HasBlock(e){let{symbol:t}=e;return[k.HasBlock,[k.GetSymbol,t]]}HasBlockParams(e){let{symbol:t}=e;return[k.HasBlockParams,[k.GetSymbol,t]]}Curry(e){let{definition:t,curriedType:r,args:n}=e;return[k.Curry,mr.expr(t),r,mr.Positional(n.positional),mr.NamedArguments(n.named)]}Local(e){let{isTemplateLocal:t,symbol:r}=e;return[t?k.GetLexicalSymbol:k.GetSymbol,r]}GetWithResolver(e){let{symbol:t}=e;return[k.GetFreeAsComponentOrHelperHeadOrThisFallback,t]}PathExpression(e){let{head:t,tail:r}=e;return[...mr.expr(t),mr.Tail(r)]}InterpolateExpression(e){let{parts:t}=e;return[k.Concat,t.map((e=>mr.expr(e))).toArray()]}CallExpression(e){let{callee:t,args:r}=e;return[k.Call,mr.expr(t),...mr.Args(r)]}DeprecatedCallExpression(e){let{arg:t,callee:r}=e;return[k.GetFreeAsDeprecatedHelperHeadOrThisFallback,r.symbol,[t.chars]]}Tail(e){let{members:t}=e;return u(t,(e=>e.chars))}Args(e){let{positional:t,named:r}=e;return[this.Positional(t),this.NamedArguments(r)]}Positional(e){let{list:t}=e;return t.map((e=>mr.expr(e))).toPresentArray()}NamedArgument(e){let{key:t,value:r}=e;return[t.chars,mr.expr(r)]}NamedArguments(e){let{entries:t}=e,r=t.toArray();if(n(r)){let e=[],t=[];for(let n of r){let[r,a]=mr.NamedArgument(n);e.push(r),t.push(a)}return h(e),h(t),[e,t]}return null}Not(e){let{value:t}=e;return[k.Not,mr.expr(t)]}IfInline(e){let{condition:t,truthy:r,falsy:n}=e,a=[k.IfInline,mr.expr(t),mr.expr(r)];return n&&a.push(mr.expr(n)),a}GetDynamicVar(e){let{name:t}=e;return[k.GetDynamicVar,mr.expr(t)]}Log(e){let{positional:t}=e;return[k.Log,this.Positional(t)]}};class dr{constructor(e){this.statements=e}toArray(){return this.statements}}const hr=new class{list(e){let t=[];for(let r of e){let e=hr.content(r);e&&e instanceof dr?t.push(...e.toArray()):t.push(e)}return t}content(e){return xe&&d.log("encoding",e),this.visitContent(e)}visitContent(e){switch(e.type){case"Debugger":return[k.Debugger,e.scope.getDebugInfo()];case"AppendComment":return this.AppendComment(e);case"AppendTextNode":return this.AppendTextNode(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"Yield":return this.Yield(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InElement":return this.InElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"With":return this.With(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e);default:return c(e)}}Yield(e){let{to:t,positional:r}=e;return[k.Yield,t,mr.Positional(r)]}InElement(e){let{guid:t,insertBefore:r,destination:n,block:a}=e,s=hr.NamedBlock(a)[1],l=mr.expr(n),o=mr.expr(r);return void 0===o?[k.InElement,s,t,l]:[k.InElement,s,t,l,o]}InvokeBlock(e){let{head:t,args:r,blocks:n}=e;return[k.Block,mr.expr(t),...mr.Args(r),hr.NamedBlocks(n)]}AppendTrustedHTML(e){let{html:t}=e;return[k.TrustingAppend,mr.expr(t)]}AppendTextNode(e){let{text:t}=e;return[k.Append,mr.expr(t)]}AppendComment(e){let{value:t}=e;return[k.Comment,t.chars]}SimpleElement(e){let{tag:t,params:r,body:n,dynamicFeatures:a}=e,s=a?k.OpenElementWithSplat:k.OpenElement;return new dr([[s,(l=t.chars,Qt[l]??l)],...hr.ElementParameters(r).toArray(),[k.FlushElement],...hr.list(n),[k.CloseElement]]);var l}Component(e){let{tag:t,params:r,args:n,blocks:a}=e,s=mr.expr(t),l=hr.ElementParameters(r),o=mr.NamedArguments(n),i=hr.NamedBlocks(a);return[k.Component,s,l.toPresentArray(),o,i]}ElementParameters(e){let{body:t}=e;return t.map((e=>hr.ElementParameter(e)))}ElementParameter(e){switch(e.type){case"SplatAttr":return[k.AttrSplat,e.symbol];case"DynamicAttr":return[gr(e.kind),...kr(e)];case"StaticAttr":return[yr(e.kind),...fr(e)];case"Modifier":return[k.Modifier,mr.expr(e.callee),...mr.Args(e.args)]}}NamedBlocks(e){let{blocks:t}=e,r=[],n=[];for(let e of t.toArray()){let[t,a]=hr.NamedBlock(e);r.push(t),n.push(a)}return r.length>0?[r,n]:null}NamedBlock(e){let{name:t,body:r,scope:n}=e,a=t.chars;return"inverse"===a&&(a="else"),[a,[hr.list(r),n.slots]]}If(e){let{condition:t,block:r,inverse:n}=e;return[k.If,mr.expr(t),hr.NamedBlock(r)[1],n?hr.NamedBlock(n)[1]:null]}Each(e){let{value:t,key:r,block:n,inverse:a}=e;return[k.Each,mr.expr(t),r?mr.expr(r):null,hr.NamedBlock(n)[1],a?hr.NamedBlock(a)[1]:null]}With(e){let{value:t,block:r,inverse:n}=e;return[k.With,mr.expr(t),hr.NamedBlock(r)[1],n?hr.NamedBlock(n)[1]:null]}Let(e){let{positional:t,block:r}=e;return[k.Let,mr.Positional(t),hr.NamedBlock(r)[1]]}WithDynamicVars(e){let{named:t,block:r}=e;return[k.WithDynamicVars,mr.NamedArguments(t),hr.NamedBlock(r)[1]]}InvokeComponent(e){let{definition:t,args:r,blocks:n}=e;return[k.InvokeComponent,mr.expr(t),mr.Positional(r.positional),mr.NamedArguments(r.named),n?hr.NamedBlocks(n):null]}};function fr(e){let{name:t,value:r,namespace:n}=e,a=[ar(t.chars),r.chars];return n&&a.push(n),a}function kr(e){let{name:t,value:r,namespace:n}=e,a=[ar(t.chars),mr.expr(r)];return n&&a.push(n),a}function yr(e){return e.component?k.StaticComponentAttr:k.StaticAttr}function gr(e){return e.component?e.trusting?k.TrustingComponentAttr:k.ComponentAttr:e.trusting?k.TrustingDynamicAttr:k.DynamicAttr}const vr=(()=>{const e="object"==typeof module&&"function"==typeof module.require?module.require:globalThis.require;if(e)try{const t=e("crypto"),r=e=>{const r=t.createHash("sha1");return r.update(e,"utf8"),r.digest("base64").substring(0,8)};return r("test"),r}catch{}return function(){return null}})(),wr={id:vr};function Ar(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:wr;const r=new E.Source(e??"",t.meta?.moduleName),[n,a]=O(r,{lexicalScope:()=>!1,...t}),s=function(e,t,r){let n=new ur(t.table,r);xe&&(d.groupCollapsed("pass0: visiting"),d.log("symbols",t.table),d.log("source",e),d.groupEnd());let a=cr.visitList(t.body,n);return xe&&(a.isOk?d.log("-> pass0: out",a.value):d.log("-> pass0: error",a.reason)),a.mapOk((e=>new Ce({loc:t.loc,scope:t.table,body:e.toArray()})))}(r,n,t.strictMode??!1).mapOk((e=>function(e){let t=hr.list(e.body),r=e.scope,n=[t,r.symbols,r.hasEval,r.upvars];if(xe){let e=new pr(n);d.log("-> ",t.map((t=>e.formatOpcode(t))))}return n}(e)));if(xe&&d.log("Template ->",s),s.isOk)return[s.value,a];throw s.reason}const br="796d24e6-2450-4fb0-8cdf-b65638b5ef70";function xr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:wr;const[r,n]=Ar(e,t),a=t.meta?.moduleName,s=t.id||vr,l=JSON.stringify(r),o={id:s(JSON.stringify(t.meta)+l),block:l,moduleName:a??"(unknown template module)",scope:br,isStrictMode:t.strictMode??!1};0===n.length&&delete o.scope;let i=JSON.stringify(o);if(n.length>0){const e=`()=>[${n.join(",")}]`;i=i.replace(`"${br}"`,e)}return i}export{z as Builder,ce as NEWLINE,Q as ProgramSymbols,pr as WireFormatDebugger,se as buildStatement,ne as buildStatements,oe as c,vr as defaultId,xr as precompile,Ar as precompileJSON,le as s,ie as unicode};
//# sourceMappingURL=index.js.map

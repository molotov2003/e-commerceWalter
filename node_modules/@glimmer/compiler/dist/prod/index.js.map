{"version":3,"file":"index.js","sources":["../../lib/builder/builder-interface.ts","../../lib/builder/builder.ts","../../../local-debug-flags/index.ts","../../lib/passes/2-encoding/mir.ts","../../lib/shared/list.ts","../../lib/shared/result.ts","../../lib/passes/1-normalization/utils/is-node.ts","../../lib/passes/1-normalization/visitors/expressions.ts","../../lib/passes/1-normalization/keywords/impl.ts","../../lib/passes/1-normalization/keywords/utils/call-to-append.ts","../../lib/passes/1-normalization/keywords/utils/curry.ts","../../lib/passes/1-normalization/keywords/utils/dynamic-vars.ts","../../lib/passes/1-normalization/keywords/utils/has-block.ts","../../lib/passes/1-normalization/keywords/utils/if-unless.ts","../../lib/passes/1-normalization/keywords/utils/log.ts","../../lib/passes/1-normalization/keywords/append.ts","../../lib/passes/1-normalization/keywords/block.ts","../../lib/passes/1-normalization/keywords/call.ts","../../lib/passes/1-normalization/keywords/modifier.ts","../../lib/utils.ts","../../lib/passes/1-normalization/visitors/element/classified.ts","../../lib/passes/1-normalization/visitors/element/component.ts","../../lib/passes/1-normalization/visitors/element/simple-element.ts","../../lib/passes/1-normalization/visitors/statements.ts","../../lib/passes/1-normalization/context.ts","../../lib/wire-format-debug.ts","../../lib/passes/2-encoding/expressions.ts","../../lib/passes/2-encoding/content.ts","../../lib/compiler.ts","../../lib/passes/1-normalization/index.ts","../../lib/passes/2-encoding/index.ts"],"sourcesContent":["import type { Dict, DictValue, Nullable, PresentArray } from '@glimmer/interfaces';\nimport { assertNever, dict, expect, isPresentArray } from '@glimmer/util';\n\nexport type BuilderParams = BuilderExpression[];\nexport type BuilderHash = Nullable<Dict<BuilderExpression>>;\nexport type BuilderBlockHash = BuilderHash | { as: string | string[] };\nexport type BuilderBlocks = Dict<BuilderBlock>;\nexport type BuilderAttrs = Dict<BuilderAttr>;\n\nexport type NormalizedParams = NormalizedExpression[];\nexport type NormalizedHash = Dict<NormalizedExpression>;\nexport type NormalizedBlock = NormalizedStatement[];\nexport type NormalizedBlocks = Dict<NormalizedBlock>;\nexport type NormalizedAttrs = Dict<NormalizedAttr>;\nexport type NormalizedAttr = HeadKind.Splat | NormalizedExpression;\n\nexport interface NormalizedElement {\n  name: string;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport interface NormalizedAngleInvocation {\n  head: NormalizedExpression;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport enum HeadKind {\n  Block = 'Block',\n  Call = 'Call',\n  Element = 'Element',\n  AppendPath = 'AppendPath',\n  AppendExpr = 'AppendExpr',\n  Literal = 'Literal',\n  Modifier = 'Modifier',\n  DynamicComponent = 'DynamicComponent',\n  Comment = 'Comment',\n  Splat = 'Splat',\n  Keyword = 'Keyword',\n}\n\nexport enum VariableKind {\n  Local = 'Local',\n  Free = 'Free',\n  Arg = 'Arg',\n  Block = 'Block',\n  This = 'This',\n}\n\nexport interface Variable {\n  kind: VariableKind;\n  name: string;\n  /**\n   * Differences:\n   *\n   * - strict mode variables always refer to in-scope variables\n   * - loose mode variables use this algorithm:\n   *   1. otherwise, fall back to `this.<name>`\n   */\n  mode: 'loose' | 'strict';\n}\n\nexport interface Path {\n  head: Variable;\n  tail: PresentArray<string>;\n}\n\nexport interface AppendExpr {\n  kind: HeadKind.AppendExpr;\n  expr: NormalizedExpression;\n  trusted: boolean;\n}\n\nexport interface AppendPath {\n  kind: HeadKind.AppendPath;\n  path: NormalizedPath;\n  trusted: boolean;\n}\n\nexport interface NormalizedKeywordStatement {\n  kind: HeadKind.Keyword;\n  name: string;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport type NormalizedStatement =\n  | {\n      kind: HeadKind.Call;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      trusted: boolean;\n    }\n  | {\n      kind: HeadKind.Block;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      blockParams: Nullable<string[]>;\n      blocks: NormalizedBlocks;\n    }\n  | NormalizedKeywordStatement\n  | {\n      kind: HeadKind.Element;\n      name: string;\n      attrs: NormalizedAttrs;\n      block: NormalizedBlock;\n    }\n  | { kind: HeadKind.Comment; value: string }\n  | { kind: HeadKind.Literal; value: string }\n  | AppendPath\n  | AppendExpr\n  | { kind: HeadKind.Modifier; params: NormalizedParams; hash: Nullable<NormalizedHash> }\n  | {\n      kind: HeadKind.DynamicComponent;\n      expr: NormalizedExpression;\n      hash: Nullable<NormalizedHash>;\n      block: NormalizedBlock;\n    };\n\nexport function normalizeStatement(statement: BuilderStatement): NormalizedStatement {\n  if (Array.isArray(statement)) {\n    if (statementIsExpression(statement)) {\n      return normalizeAppendExpression(statement);\n    } else if (isSugaryArrayStatement(statement)) {\n      return normalizeSugaryArrayStatement(statement);\n    } else {\n      return normalizeVerboseStatement(statement);\n    }\n  } else if (typeof statement === 'string') {\n    return normalizeAppendHead(normalizeDottedPath(statement), false);\n  } else {\n    throw assertNever(statement);\n  }\n}\n\nexport function normalizeAppendHead(\n  head: NormalizedHead,\n  trusted: boolean\n): AppendExpr | AppendPath {\n  if (head.type === ExpressionKind.GetPath) {\n    return {\n      kind: HeadKind.AppendPath,\n      path: head,\n      trusted,\n    };\n  } else {\n    return {\n      kind: HeadKind.AppendExpr,\n      expr: head,\n      trusted,\n    };\n  }\n}\n\nfunction isSugaryArrayStatement(statement: BuilderStatement): statement is SugaryArrayStatement {\n  if (Array.isArray(statement) && typeof statement[0] === 'string') {\n    switch (statement[0][0]) {\n      case '(':\n      case '#':\n      case '<':\n      case '!':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\nexport type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;\n\nexport function normalizeSugaryArrayStatement(\n  statement: SugaryArrayStatement\n): NormalizedStatement {\n  const name = statement[0];\n\n  switch (name[0]) {\n    case '(': {\n      let params: Nullable<NormalizedParams> = null;\n      let hash: Nullable<NormalizedHash> = null;\n\n      if (statement.length === 3) {\n        params = normalizeParams(statement[1] as Params);\n        hash = normalizeHash(statement[2] as Hash);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          params = normalizeParams(statement[1] as Params);\n        } else {\n          hash = normalizeHash(statement[1] as Hash);\n        }\n      }\n\n      return {\n        kind: HeadKind.Call,\n        head: normalizeCallHead(name),\n        params,\n        hash,\n        trusted: false,\n      };\n    }\n\n    case '#': {\n      const {\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      } = normalizeBuilderBlockStatement(statement as BuilderBlockStatement);\n\n      return {\n        kind: HeadKind.Block,\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '!': {\n      const name = statement[0].slice(1);\n      const { params, hash, blocks, blockParams } = normalizeBuilderBlockStatement(\n        statement as BuilderBlockStatement\n      );\n\n      return {\n        kind: HeadKind.Keyword,\n        name,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '<': {\n      let attrs: NormalizedAttrs = dict();\n      let block: NormalizedBlock = [];\n\n      if (statement.length === 3) {\n        attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        block = normalizeBlock(statement[2] as BuilderBlock);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          block = normalizeBlock(statement[1] as BuilderBlock);\n        } else {\n          attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        }\n      }\n\n      return {\n        kind: HeadKind.Element,\n        name: expect(extractElement(name), `BUG: expected ${name} to look like a tag name`),\n        attrs,\n        block,\n      };\n    }\n\n    default:\n      throw new Error(`Unreachable ${JSON.stringify(statement)} in normalizeSugaryArrayStatement`);\n  }\n}\n\nfunction normalizeVerboseStatement(statement: VerboseStatement): NormalizedStatement {\n  switch (statement[0]) {\n    case Builder.Literal: {\n      return {\n        kind: HeadKind.Literal,\n        value: statement[1],\n      };\n    }\n\n    case Builder.Append: {\n      return normalizeAppendExpression(statement[1], statement[2]);\n    }\n\n    case Builder.Modifier: {\n      return {\n        kind: HeadKind.Modifier,\n        params: normalizeParams(statement[1]),\n        hash: normalizeHash(statement[2]),\n      };\n    }\n\n    case Builder.DynamicComponent: {\n      return {\n        kind: HeadKind.DynamicComponent,\n        expr: normalizeExpression(statement[1]),\n        hash: normalizeHash(statement[2]),\n        block: normalizeBlock(statement[3]),\n      };\n    }\n\n    case Builder.Comment: {\n      return {\n        kind: HeadKind.Comment,\n        value: statement[1],\n      };\n    }\n  }\n}\n\nfunction extractBlockHead(name: string): NormalizedHead {\n  const result = /^(#|!)(.*)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing # in block head`);\n  }\n\n  return normalizeDottedPath(result[2] as string);\n}\n\nfunction normalizeCallHead(name: string): NormalizedHead {\n  const result = /^\\((.*)\\)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing () in call head`);\n  }\n\n  return normalizeDottedPath(result[1] as string);\n}\n\nfunction normalizePath(head: string, tail: string[] = []): NormalizedHead {\n  const pathHead = normalizePathHead(head);\n\n  if (isPresentArray(tail)) {\n    return {\n      type: ExpressionKind.GetPath,\n      path: {\n        head: pathHead,\n        tail,\n      },\n    };\n  } else {\n    return {\n      type: ExpressionKind.GetVar,\n      variable: pathHead,\n    };\n  }\n}\n\nfunction normalizeDottedPath(whole: string): NormalizedHead {\n  const { kind, name: rest } = normalizePathHead(whole);\n\n  const [name, ...tail] = rest.split('.') as [string, ...string[]];\n\n  const variable: Variable = { kind, name, mode: 'loose' };\n\n  if (isPresentArray(tail)) {\n    return { type: ExpressionKind.GetPath, path: { head: variable, tail } };\n  } else {\n    return { type: ExpressionKind.GetVar, variable };\n  }\n}\n\nexport function normalizePathHead(whole: string): Variable {\n  let kind: VariableKind;\n  let name: string;\n\n  if (/^this(?:\\.|$)/u.test(whole)) {\n    return {\n      kind: VariableKind.This,\n      name: whole,\n      mode: 'loose',\n    };\n  }\n\n  switch (whole[0]) {\n    case '^':\n      kind = VariableKind.Free;\n      name = whole.slice(1);\n      break;\n\n    case '@':\n      kind = VariableKind.Arg;\n      name = whole.slice(1);\n      break;\n\n    case '&':\n      kind = VariableKind.Block;\n      name = whole.slice(1);\n      break;\n\n    default:\n      kind = VariableKind.Local;\n      name = whole;\n  }\n\n  return { kind, name, mode: 'loose' };\n}\n\nexport type BuilderBlockStatement =\n  | [string, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams | BuilderBlockHash, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams, BuilderBlockHash, BuilderBlock | BuilderBlocks];\n\nexport interface NormalizedBuilderBlockStatement {\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport function normalizeBuilderBlockStatement(\n  statement: BuilderBlockStatement\n): NormalizedBuilderBlockStatement {\n  const head = statement[0];\n  let blocks: NormalizedBlocks = dict();\n  let params: Nullable<NormalizedParams> = null;\n  let hash: Nullable<NormalizedHash> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  if (statement.length === 2) {\n    blocks = normalizeBlocks(statement[1]);\n  } else if (statement.length === 3) {\n    if (Array.isArray(statement[1])) {\n      params = normalizeParams(statement[1]);\n    } else {\n      ({ hash, blockParams } = normalizeBlockHash(statement[1]));\n    }\n\n    blocks = normalizeBlocks(statement[2]);\n  } else if (statement.length === 4) {\n    params = normalizeParams(statement[1]);\n    ({ hash, blockParams } = normalizeBlockHash(statement[2]));\n    blocks = normalizeBlocks(statement[3]);\n  }\n\n  return {\n    head: extractBlockHead(head),\n    params,\n    hash,\n    blockParams,\n    blocks,\n  };\n}\n\nfunction normalizeBlockHash(hash: BuilderBlockHash): {\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n} {\n  if (hash === null) {\n    return { hash: null, blockParams: null };\n  }\n\n  let out: Nullable<Dict<NormalizedExpression>> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  entries(hash, (key, value) => {\n    if (key === 'as') {\n      blockParams = Array.isArray(value) ? (value as string[]) : [value as string];\n    } else {\n      out = out || dict();\n      out[key] = normalizeExpression(value as BuilderExpression);\n    }\n  });\n\n  return { hash: out, blockParams };\n}\n\nexport function entries<D extends Dict>(\n  dict: D,\n  callback: <K extends keyof D>(key: K, value: D[K]) => void\n): void {\n  Object.keys(dict).forEach((key) => {\n    const value = dict[key];\n    callback(key, value as D[keyof D]);\n  });\n}\n\nfunction normalizeBlocks(value: BuilderBlock | BuilderBlocks): NormalizedBlocks {\n  if (Array.isArray(value)) {\n    return { default: normalizeBlock(value) };\n  } else {\n    return mapObject(value, normalizeBlock);\n  }\n}\n\nfunction normalizeBlock(block: BuilderBlock): NormalizedBlock {\n  return block.map((s) => normalizeStatement(s));\n}\n\nfunction normalizeAttrs(attrs: BuilderAttrs): NormalizedAttrs {\n  return mapObject(attrs, (a) => normalizeAttr(a).expr);\n}\n\nfunction normalizeAttr(attr: BuilderAttr): { expr: NormalizedAttr; trusted: boolean } {\n  if (attr === 'splat') {\n    return { expr: HeadKind.Splat, trusted: false };\n  } else {\n    const expr = normalizeExpression(attr);\n    return { expr, trusted: false };\n  }\n}\n\nfunction mapObject<T extends Dict<unknown>, Out>(\n  object: T,\n  mapper: (value: DictValue<T>, key: keyof T) => Out\n): { [P in keyof T]: Out } {\n  const out = dict() as { [P in keyof T]?: Out };\n\n  Object.keys(object).forEach(<K extends keyof T>(k: K) => {\n    out[k] = mapper(object[k] as DictValue<T>, k);\n  });\n\n  return out as { [P in keyof T]: Out };\n}\n\nexport type BuilderElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport type BuilderComment = [Builder.Comment, string];\n\nexport type InvocationElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport function isElement(input: [string, ...unknown[]]): input is BuilderElement {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function extractElement(input: string): Nullable<string> {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input);\n\n  return match?.[1] ?? null;\n}\n\nexport function isAngleInvocation(input: [string, ...unknown[]]): input is InvocationElement {\n  // TODO Paths\n  const match = /^<(@[\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function isBlock(input: [string, ...unknown[]]): input is BuilderBlockStatement {\n  // TODO Paths\n  const match = /^#[\\s\\S]?([\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport enum Builder {\n  Literal,\n  Comment,\n  Append,\n  Modifier,\n  DynamicComponent,\n  Get,\n  Concat,\n  HasBlock,\n  HasBlockParams,\n}\n\nexport type VerboseStatement =\n  | [Builder.Literal, string]\n  | [Builder.Comment, string]\n  | [Builder.Append, BuilderExpression, true]\n  | [Builder.Append, BuilderExpression]\n  | [Builder.Modifier, Params, Hash]\n  | [Builder.DynamicComponent, BuilderExpression, Hash, BuilderBlock];\n\nexport type BuilderStatement =\n  | VerboseStatement\n  | SugaryArrayStatement\n  | TupleBuilderExpression\n  | string;\n\nexport type BuilderAttr = 'splat' | BuilderExpression;\n\nexport type TupleBuilderExpression =\n  | [Builder.Literal, string | boolean | null | undefined]\n  | [Builder.Get, string]\n  | [Builder.Get, string, string[]]\n  | [Builder.Concat, ...BuilderExpression[]]\n  | [Builder.HasBlock, string]\n  | [Builder.HasBlockParams, string]\n  | BuilderCallExpression;\n\ntype Params = BuilderParams;\ntype Hash = Dict<BuilderExpression>;\n\nexport enum ExpressionKind {\n  Literal = 'Literal',\n  Call = 'Call',\n  GetPath = 'GetPath',\n  GetVar = 'GetVar',\n  Concat = 'Concat',\n  HasBlock = 'HasBlock',\n  HasBlockParams = 'HasBlockParams',\n}\n\nexport interface NormalizedCallExpression {\n  type: ExpressionKind.Call;\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n}\n\nexport interface NormalizedPath {\n  type: ExpressionKind.GetPath;\n  path: Path;\n}\n\nexport interface NormalizedVar {\n  type: ExpressionKind.GetVar;\n  variable: Variable;\n}\n\nexport type NormalizedHead = NormalizedPath | NormalizedVar;\n\nexport interface NormalizedConcat {\n  type: ExpressionKind.Concat;\n  params: [NormalizedExpression, ...NormalizedExpression[]];\n}\n\nexport type NormalizedExpression =\n  | {\n      type: ExpressionKind.Literal;\n      value: null | undefined | boolean | string | number;\n    }\n  | NormalizedCallExpression\n  | NormalizedPath\n  | NormalizedVar\n  | NormalizedConcat\n  | {\n      type: ExpressionKind.HasBlock;\n      name: string;\n    }\n  | {\n      type: ExpressionKind.HasBlockParams;\n      name: string;\n    };\n\nexport function normalizeAppendExpression(\n  expression: BuilderExpression,\n  forceTrusted = false\n): AppendExpr | AppendPath {\n  if (expression === null || expression === undefined) {\n    return {\n      expr: {\n        type: ExpressionKind.Literal,\n        value: expression,\n      },\n      kind: HeadKind.AppendExpr,\n      trusted: false,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression[1] },\n          kind: HeadKind.AppendExpr,\n          trusted: false,\n        };\n\n      case Builder.Get: {\n        return normalizeAppendHead(normalizePath(expression[1], expression[2]), forceTrusted);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[]\n          ],\n        };\n\n        return {\n          expr,\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n      }\n\n      case Builder.HasBlock:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlock,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlockParams,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return {\n            expr: normalizeCallExpression(expression),\n            kind: HeadKind.AppendExpr,\n            trusted: forceTrusted,\n          };\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeAppendHead(normalizeDottedPath(expression), forceTrusted);\n      }\n      case 'boolean':\n      case 'number':\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression },\n          kind: HeadKind.AppendExpr,\n          trusted: true,\n        };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\nexport function normalizeExpression(expression: BuilderExpression): NormalizedExpression {\n  if (expression === null || expression === undefined) {\n    return {\n      type: ExpressionKind.Literal,\n      value: expression,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return { type: ExpressionKind.Literal, value: expression[1] };\n\n      case Builder.Get: {\n        return normalizePath(expression[1], expression[2]);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[]\n          ],\n        };\n\n        return expr;\n      }\n\n      case Builder.HasBlock:\n        return {\n          type: ExpressionKind.HasBlock,\n          name: expression[1],\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          type: ExpressionKind.HasBlockParams,\n          name: expression[1],\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return normalizeCallExpression(expression);\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeDottedPath(expression);\n      }\n      case 'boolean':\n      case 'number':\n        return { type: ExpressionKind.Literal, value: expression };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\n// | [Builder.Get, string]\n// | [Builder.Get, string, string[]]\n// | [Builder.Concat, Params]\n// | [Builder.HasBlock, string]\n// | [Builder.HasBlockParams, string]\n\nexport type BuilderExpression =\n  | TupleBuilderExpression\n  | BuilderCallExpression\n  | null\n  | undefined\n  | boolean\n  | string\n  | number;\n\nexport function isBuilderExpression(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is TupleBuilderExpression | BuilderCallExpression {\n  return Array.isArray(expr);\n}\n\nexport function isLiteral(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is [Builder.Literal, string | boolean | undefined] {\n  return Array.isArray(expr) && expr[0] === 'literal';\n}\n\nexport function statementIsExpression(\n  statement: BuilderStatement\n): statement is TupleBuilderExpression {\n  if (!Array.isArray(statement)) {\n    return false;\n  }\n\n  const name = statement[0];\n\n  if (typeof name === 'number') {\n    switch (name) {\n      case Builder.Literal:\n      case Builder.Get:\n      case Builder.Concat:\n      case Builder.HasBlock:\n      case Builder.HasBlockParams:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  if (name[0] === '(') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isBuilderCallExpression(\n  value: TupleBuilderExpression | BuilderCallExpression\n): value is BuilderCallExpression {\n  return typeof value[0] === 'string' && value[0][0] === '(';\n}\n\nexport type MiniBuilderBlock = BuilderStatement[];\n\nexport type BuilderBlock = MiniBuilderBlock;\n\nexport type BuilderCallExpression = [string] | [string, Params | Hash] | [string, Params, Hash];\n\nexport function normalizeParams(input: Params): NormalizedParams {\n  return input.map(normalizeExpression);\n}\n\nexport function normalizeHash(input: Nullable<Hash>): Nullable<NormalizedHash> {\n  if (input === null) return null;\n  return mapObject(input, normalizeExpression);\n}\n\nexport function normalizeCallExpression(expr: BuilderCallExpression): NormalizedCallExpression {\n  switch (expr.length) {\n    case 1:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: null,\n        hash: null,\n      };\n    case 2: {\n      if (Array.isArray(expr[1])) {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: normalizeParams(expr[1]),\n          hash: null,\n        };\n      } else {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: null,\n          hash: normalizeHash(expr[1]),\n        };\n      }\n    }\n\n    case 3:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: normalizeParams(expr[1]),\n        hash: normalizeHash(expr[2]),\n      };\n  }\n}\n","import type {\n  AttrNamespace,\n  Dict,\n  Expressions,\n  GetContextualFreeOpcode,\n  Nullable,\n  PresentArray,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport {\n  assert,\n  assertNever,\n  dict,\n  exhausted,\n  expect,\n  isPresentArray,\n  NS_XLINK,\n  NS_XML,\n  NS_XMLNS,\n  values,\n} from '@glimmer/util';\nimport { SexpOpcodes as Op, VariableResolutionContext } from '@glimmer/wire-format';\n\nimport {\n  Builder,\n  type BuilderComment,\n  type BuilderStatement,\n  ExpressionKind,\n  HeadKind,\n  type NormalizedAngleInvocation,\n  type NormalizedAttrs,\n  type NormalizedBlock,\n  type NormalizedBlocks,\n  type NormalizedElement,\n  type NormalizedExpression,\n  type NormalizedHash,\n  type NormalizedHead,\n  type NormalizedKeywordStatement,\n  type NormalizedParams,\n  type NormalizedPath,\n  type NormalizedStatement,\n  normalizeStatement,\n  type Variable,\n  VariableKind,\n} from './builder-interface';\n\ninterface Symbols {\n  top: ProgramSymbols;\n  freeVar(name: string): number;\n  arg(name: string): number;\n  block(name: string): number;\n  local(name: string): number;\n  this(): number;\n\n  hasLocal(name: string): boolean;\n\n  child(params: string[]): LocalSymbols;\n}\n\nexport class ProgramSymbols implements Symbols {\n  _freeVariables: string[] = [];\n  _symbols: string[] = ['this'];\n\n  top = this;\n\n  toSymbols(): string[] {\n    return this._symbols.slice(1);\n  }\n\n  toUpvars(): string[] {\n    return this._freeVariables;\n  }\n\n  freeVar(name: string): number {\n    return addString(this._freeVariables, name);\n  }\n\n  block(name: string): number {\n    return this.symbol(name);\n  }\n\n  arg(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  local(name: string): never {\n    throw new Error(\n      `No local ${name} was found. Maybe you meant ^${name} for upvar, or !${name} for keyword?`\n    );\n  }\n\n  this(): number {\n    return 0;\n  }\n\n  hasLocal(_name: string): false {\n    return false;\n  }\n\n  // any symbol\n  symbol(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nclass LocalSymbols implements Symbols {\n  private locals: Dict<number> = dict();\n\n  constructor(private parent: Symbols, locals: string[]) {\n    for (let local of locals) {\n      this.locals[local] = parent.top.symbol(local);\n    }\n  }\n\n  get paramSymbols(): number[] {\n    return values(this.locals);\n  }\n\n  get top(): ProgramSymbols {\n    return this.parent.top;\n  }\n\n  freeVar(name: string): number {\n    return this.parent.freeVar(name);\n  }\n\n  arg(name: string): number {\n    return this.parent.arg(name);\n  }\n\n  block(name: string): number {\n    return this.parent.block(name);\n  }\n\n  local(name: string): number {\n    if (name in this.locals) {\n      return this.locals[name] as number;\n    } else {\n      return this.parent.local(name);\n    }\n  }\n\n  this(): number {\n    return this.parent.this();\n  }\n\n  hasLocal(name: string): boolean {\n    if (name in this.locals) {\n      return true;\n    } else {\n      return this.parent.hasLocal(name);\n    }\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nfunction addString(array: string[], item: string): number {\n  let index = array.indexOf(item);\n\n  if (index === -1) {\n    index = array.length;\n    array.push(item);\n    return index;\n  } else {\n    return index;\n  }\n}\n\nexport interface BuilderGetFree {\n  type: 'GetFree';\n  head: string;\n  tail: string[];\n}\n\nfunction unimpl(message: string): Error {\n  return new Error(`unimplemented ${message}`);\n}\n\nexport function buildStatements(\n  statements: BuilderStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(normalizeStatement(s), symbols)));\n\n  return out;\n}\n\nexport function buildNormalizedStatements(\n  statements: NormalizedStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(s, symbols)));\n\n  return out;\n}\n\nexport function buildStatement(\n  normalized: NormalizedStatement,\n  symbols: Symbols = new ProgramSymbols()\n): WireFormat.Statement[] {\n  switch (normalized.kind) {\n    case HeadKind.AppendPath: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildGetPath(normalized.path, symbols),\n        ],\n      ];\n    }\n\n    case HeadKind.AppendExpr: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildExpression(\n            normalized.expr,\n            normalized.trusted ? 'TrustedAppend' : 'Append',\n            symbols\n          ),\n        ],\n      ];\n    }\n\n    case HeadKind.Call: {\n      let { head: path, params, hash, trusted } = normalized;\n      let builtParams: Nullable<WireFormat.Core.Params> = params\n        ? buildParams(params, symbols)\n        : null;\n      let builtHash: WireFormat.Core.Hash = hash ? buildHash(hash, symbols) : null;\n      let builtExpr: WireFormat.Expression = buildCallHead(\n        path,\n        trusted\n          ? VariableResolutionContext.AmbiguousInvoke\n          : VariableResolutionContext.AmbiguousAppendInvoke,\n        symbols\n      );\n\n      return [\n        [trusted ? Op.TrustingAppend : Op.Append, [Op.Call, builtExpr, builtParams, builtHash]],\n      ];\n    }\n\n    case HeadKind.Literal: {\n      return [[Op.Append, normalized.value]];\n    }\n\n    case HeadKind.Comment: {\n      return [[Op.Comment, normalized.value]];\n    }\n\n    case HeadKind.Block: {\n      let blocks = buildBlocks(normalized.blocks, normalized.blockParams, symbols);\n      let hash = buildHash(normalized.hash, symbols);\n      let params = buildParams(normalized.params, symbols);\n      let path = buildCallHead(\n        normalized.head,\n        VariableResolutionContext.ResolveAsComponentHead,\n        symbols\n      );\n\n      return [[Op.Block, path, params, hash, blocks]];\n    }\n\n    case HeadKind.Keyword: {\n      return [buildKeyword(normalized, symbols)];\n    }\n\n    case HeadKind.Element:\n      return buildElement(normalized, symbols);\n\n    case HeadKind.Modifier:\n      throw unimpl('modifier');\n\n    case HeadKind.DynamicComponent:\n      throw unimpl('dynamic component');\n\n    default:\n      throw assertNever(normalized);\n  }\n}\n\nexport function s(\n  arr: TemplateStringsArray,\n  ...interpolated: unknown[]\n): [Builder.Literal, string] {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Literal, result];\n}\n\nexport function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Comment, result];\n}\n\nexport function unicode(charCode: string): string {\n  return String.fromCharCode(parseInt(charCode, 16));\n}\n\nexport const NEWLINE = '\\n';\n\nfunction buildKeyword(\n  normalized: NormalizedKeywordStatement,\n  symbols: Symbols\n): WireFormat.Statement {\n  let { name } = normalized;\n  let params = buildParams(normalized.params, symbols);\n  let childSymbols = symbols.child(normalized.blockParams || []);\n\n  let block = buildBlock(\n    normalized.blocks['default'] as NormalizedBlock,\n    childSymbols,\n    childSymbols.paramSymbols\n  );\n  let inverse = normalized.blocks['else']\n    ? buildBlock(normalized.blocks['else'], symbols, [])\n    : null;\n\n  switch (name) {\n    case 'with':\n      return [Op.With, expect(params, 'with requires params')[0], block, inverse];\n    case 'if':\n      return [Op.If, expect(params, 'if requires params')[0], block, inverse];\n    case 'each': {\n      let keyExpr = normalized.hash ? normalized.hash['key'] : null;\n      let key = keyExpr ? buildExpression(keyExpr, 'Strict', symbols) : null;\n      return [Op.Each, expect(params, 'if requires params')[0], key, block, inverse];\n    }\n\n    default:\n      throw new Error('unimplemented keyword');\n  }\n}\n\nfunction buildElement(\n  { name, attrs, block }: NormalizedElement,\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [\n    hasSplat(attrs) ? [Op.OpenElementWithSplat, name] : [Op.OpenElement, name],\n  ];\n  if (attrs) {\n    let { params, args } = buildElementParams(attrs, symbols);\n    out.push(...params);\n    assert(args === null, `Can't pass args to a simple element`);\n  }\n  out.push([Op.FlushElement]);\n\n  if (Array.isArray(block)) {\n    block.forEach((s) => out.push(...buildStatement(s, symbols)));\n  } else if (block === null) {\n    // do nothing\n  } else {\n    throw assertNever(block);\n  }\n\n  out.push([Op.CloseElement]);\n\n  return out;\n}\n\nfunction hasSplat(attrs: Nullable<NormalizedAttrs>): boolean {\n  if (attrs === null) return false;\n\n  return Object.keys(attrs).some((a) => attrs[a] === HeadKind.Splat);\n}\n\nexport function buildAngleInvocation(\n  { attrs, block, head }: NormalizedAngleInvocation,\n  symbols: Symbols\n): WireFormat.Statements.Component {\n  let paramList: WireFormat.ElementParameter[] = [];\n  let args: WireFormat.Core.Hash = null;\n  let blockList: WireFormat.Statement[] = [];\n\n  if (attrs) {\n    let built = buildElementParams(attrs, symbols);\n    paramList = built.params;\n    args = built.args;\n  }\n\n  if (block) blockList = buildNormalizedStatements(block, symbols);\n\n  return [\n    Op.Component,\n    buildExpression(head, VariableResolutionContext.ResolveAsComponentHead, symbols),\n    isPresentArray(paramList) ? paramList : null,\n    args,\n    [['default'], [[blockList, []]]],\n  ];\n}\n\nexport function buildElementParams(\n  attrs: NormalizedAttrs,\n  symbols: Symbols\n): { params: WireFormat.ElementParameter[]; args: WireFormat.Core.Hash } {\n  let params: WireFormat.ElementParameter[] = [];\n  let keys: string[] = [];\n  let values: WireFormat.Expression[] = [];\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (value === HeadKind.Splat) {\n      params.push([Op.AttrSplat, symbols.block('&attrs')]);\n    } else if (key[0] === '@') {\n      keys.push(key);\n      values.push(buildExpression(value, 'Strict', symbols));\n    } else {\n      params.push(\n        ...buildAttributeValue(\n          key,\n          value,\n          // TODO: extract namespace from key\n          extractNamespace(key),\n          symbols\n        )\n      );\n    }\n  }\n\n  return { params, args: isPresentArray(keys) && isPresentArray(values) ? [keys, values] : null };\n}\n\nexport function extractNamespace(name: string): Nullable<AttrNamespace> {\n  if (name === 'xmlns') {\n    return NS_XMLNS;\n  }\n\n  let match = /^([^:]*):([^:]*)$/u.exec(name);\n\n  if (match === null) {\n    return null;\n  }\n\n  let namespace = match[1];\n\n  switch (namespace) {\n    case 'xlink':\n      return NS_XLINK;\n    case 'xml':\n      return NS_XML;\n    case 'xmlns':\n      return NS_XMLNS;\n  }\n\n  return null;\n}\n\nexport function buildAttributeValue(\n  name: string,\n  value: NormalizedExpression,\n  namespace: Nullable<AttrNamespace>,\n  symbols: Symbols\n): WireFormat.Attribute[] {\n  switch (value.type) {\n    case ExpressionKind.Literal: {\n      let val = value.value;\n\n      if (val === false) {\n        return [];\n      } else if (val === true) {\n        return [[Op.StaticAttr, name, '', namespace ?? undefined]];\n      } else if (typeof val === 'string') {\n        return [[Op.StaticAttr, name, val, namespace ?? undefined]];\n      } else {\n        throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(val)}`);\n      }\n    }\n\n    default:\n      return [\n        [\n          Op.DynamicAttr,\n          name,\n          buildExpression(value, 'AttrValue', symbols),\n          namespace ?? undefined,\n        ],\n      ];\n  }\n}\n\ntype ExprResolution =\n  | VariableResolutionContext\n  | 'Append'\n  | 'TrustedAppend'\n  | 'AttrValue'\n  | 'SubExpression'\n  | 'Strict';\n\nfunction varContext(context: ExprResolution, bare: boolean): VarResolution {\n  switch (context) {\n    case 'Append':\n      return bare ? 'AppendBare' : 'AppendInvoke';\n    case 'TrustedAppend':\n      return bare ? 'TrustedAppendBare' : 'TrustedAppendInvoke';\n    case 'AttrValue':\n      return bare ? 'AttrValueBare' : 'AttrValueInvoke';\n    default:\n      return context;\n  }\n}\n\nexport function buildExpression(\n  expr: NormalizedExpression,\n  context: ExprResolution,\n  symbols: Symbols\n): WireFormat.Expression {\n  switch (expr.type) {\n    case ExpressionKind.GetPath: {\n      return buildGetPath(expr, symbols);\n    }\n\n    case ExpressionKind.GetVar: {\n      return buildVar(expr.variable, varContext(context, true), symbols);\n    }\n\n    case ExpressionKind.Concat: {\n      return [Op.Concat, buildConcat(expr.params, symbols)];\n    }\n\n    case ExpressionKind.Call: {\n      let builtParams = buildParams(expr.params, symbols);\n      let builtHash = buildHash(expr.hash, symbols);\n      let builtExpr = buildCallHead(\n        expr.head,\n        context === 'Strict' ? 'SubExpression' : varContext(context, false),\n        symbols\n      );\n\n      return [Op.Call, builtExpr, builtParams, builtHash];\n    }\n\n    case ExpressionKind.HasBlock: {\n      return [\n        Op.HasBlock,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.HasBlockParams: {\n      return [\n        Op.HasBlockParams,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.Literal: {\n      if (expr.value === undefined) {\n        return [Op.Undefined];\n      } else {\n        return expr.value;\n      }\n    }\n\n    default:\n      assertNever(expr);\n  }\n}\n\nexport function buildCallHead(\n  callHead: NormalizedHead,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar | Expressions.GetPath {\n  if (callHead.type === ExpressionKind.GetVar) {\n    return buildVar(callHead.variable, context, symbols);\n  } else {\n    return buildGetPath(callHead, symbols);\n  }\n}\n\nexport function buildGetPath(head: NormalizedPath, symbols: Symbols): Expressions.GetPath {\n  return buildVar(head.path.head, VariableResolutionContext.Strict, symbols, head.path.tail);\n}\n\ntype VarResolution =\n  | VariableResolutionContext\n  | 'AppendBare'\n  | 'AppendInvoke'\n  | 'TrustedAppendBare'\n  | 'TrustedAppendInvoke'\n  | 'AttrValueBare'\n  | 'AttrValueInvoke'\n  | 'SubExpression'\n  | 'Strict';\n\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path: PresentArray<string>\n): Expressions.GetPath;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path?: PresentArray<string>\n): Expressions.GetPath | Expressions.GetVar {\n  let op: Expressions.GetVar[0] = Op.GetSymbol;\n  let sym: number;\n  switch (head.kind) {\n    case VariableKind.Free:\n      if (context === 'Strict') {\n        op = Op.GetStrictKeyword;\n      } else if (context === 'AppendBare') {\n        op = Op.GetFreeAsComponentOrHelperHeadOrThisFallback;\n      } else if (context === 'AppendInvoke') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'TrustedAppendBare') {\n        op = Op.GetFreeAsHelperHeadOrThisFallback;\n      } else if (context === 'TrustedAppendInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueBare') {\n        op = Op.GetFreeAsHelperHeadOrThisFallback;\n      } else if (context === 'AttrValueInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'SubExpression') {\n        op = Op.GetFreeAsHelperHead;\n      } else {\n        op = expressionContextOp(context);\n      }\n      sym = symbols.freeVar(head.name);\n      break;\n    default:\n      op = Op.GetSymbol;\n      sym = getSymbolForVar(head.kind, symbols, head.name);\n  }\n\n  if (path === undefined || path.length === 0) {\n    return [op, sym];\n  } else {\n    return [op, sym, path];\n  }\n}\n\nfunction getSymbolForVar(\n  kind: Exclude<VariableKind, VariableKind.Free>,\n  symbols: Symbols,\n  name: string\n) {\n  switch (kind) {\n    case VariableKind.Arg:\n      return symbols.arg(name);\n    case VariableKind.Block:\n      return symbols.block(name);\n    case VariableKind.Local:\n      return symbols.local(name);\n    case VariableKind.This:\n      return symbols.this();\n    default:\n      return exhausted(kind);\n  }\n}\n\nexport function expressionContextOp(context: VariableResolutionContext): GetContextualFreeOpcode {\n  switch (context) {\n    case VariableResolutionContext.Strict:\n      return Op.GetStrictKeyword;\n    case VariableResolutionContext.AmbiguousAppend:\n      return Op.GetFreeAsComponentOrHelperHeadOrThisFallback;\n    case VariableResolutionContext.AmbiguousAppendInvoke:\n      return Op.GetFreeAsComponentOrHelperHead;\n    case VariableResolutionContext.AmbiguousInvoke:\n      return Op.GetFreeAsHelperHeadOrThisFallback;\n    case VariableResolutionContext.ResolveAsCallHead:\n      return Op.GetFreeAsHelperHead;\n    case VariableResolutionContext.ResolveAsModifierHead:\n      return Op.GetFreeAsModifierHead;\n    case VariableResolutionContext.ResolveAsComponentHead:\n      return Op.GetFreeAsComponentHead;\n    default:\n      return exhausted(context);\n  }\n}\n\nexport function buildParams(\n  exprs: Nullable<NormalizedParams>,\n  symbols: Symbols\n): Nullable<WireFormat.Core.Params> {\n  if (exprs === null || !isPresentArray(exprs)) return null;\n\n  return exprs.map((e) => buildExpression(e, 'Strict', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildConcat(\n  exprs: [NormalizedExpression, ...NormalizedExpression[]],\n  symbols: Symbols\n): WireFormat.Core.ConcatParams {\n  return exprs.map((e) => buildExpression(e, 'AttrValue', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildHash(exprs: Nullable<NormalizedHash>, symbols: Symbols): WireFormat.Core.Hash {\n  if (exprs === null) return null;\n\n  let out: [string[], WireFormat.Expression[]] = [[], []];\n\n  for (const [key, value] of Object.entries(exprs)) {\n    out[0].push(key);\n    out[1].push(buildExpression(value, 'Strict', symbols));\n  }\n\n  return out as WireFormat.Core.Hash;\n}\n\nexport function buildBlocks(\n  blocks: NormalizedBlocks,\n  blockParams: Nullable<string[]>,\n  parent: Symbols\n): WireFormat.Core.Blocks {\n  let keys: string[] = [];\n  let values: WireFormat.SerializedInlineBlock[] = [];\n\n  for (const [name, block] of Object.entries(blocks)) {\n    keys.push(name);\n\n    if (name === 'default') {\n      let symbols = parent.child(blockParams || []);\n\n      values.push(buildBlock(block, symbols, symbols.paramSymbols));\n    } else {\n      values.push(buildBlock(block, parent, []));\n    }\n  }\n\n  return [keys, values];\n}\n\nfunction buildBlock(\n  block: NormalizedBlock,\n  symbols: Symbols,\n  locals: number[] = []\n): WireFormat.SerializedInlineBlock {\n  return [buildNormalizedStatements(block, symbols), locals];\n}\n","\n\nexport const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import type { CurriedType, PresentArray } from '@glimmer/interfaces';\nimport {\n  type ASTv2,\n  type BlockSymbolTable,\n  node,\n  type ProgramSymbolTable,\n  type SourceSlice,\n  type SymbolTable,\n} from '@glimmer/syntax';\n\nimport type { AnyOptionalList, OptionalList, PresentList } from '../../shared/list';\n\nexport class Template extends node('Template').fields<{\n  scope: ProgramSymbolTable;\n  body: Statement[];\n}>() {}\n\nexport class InElement extends node('InElement').fields<{\n  guid: string;\n  insertBefore: ExpressionNode | Missing;\n  destination: ExpressionNode;\n  block: NamedBlock;\n}>() {}\n\nexport class Not extends node('Not').fields<{ value: ExpressionNode }>() {}\n\nexport class If extends node('If').fields<{\n  condition: ExpressionNode;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class IfInline extends node('IfInline').fields<{\n  condition: ExpressionNode;\n  truthy: ExpressionNode;\n  falsy: ExpressionNode | null;\n}>() {}\n\nexport class Each extends node('Each').fields<{\n  value: ExpressionNode;\n  key: ExpressionNode | null;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class With extends node('With').fields<{\n  value: ExpressionNode;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class Let extends node('Let').fields<{\n  positional: Positional;\n  block: NamedBlock;\n}>() {}\n\nexport class WithDynamicVars extends node('WithDynamicVars').fields<{\n  named: NamedArguments;\n  block: NamedBlock;\n}>() {}\n\nexport class GetDynamicVar extends node('GetDynamicVar').fields<{\n  name: ExpressionNode;\n}>() {}\n\nexport class Log extends node('Log').fields<{\n  positional: Positional;\n}>() {}\n\nexport class InvokeComponent extends node('InvokeComponent').fields<{\n  definition: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks | null;\n}>() {}\n\nexport class NamedBlocks extends node('NamedBlocks').fields<{\n  blocks: OptionalList<NamedBlock>;\n}>() {}\n\nexport class NamedBlock extends node('NamedBlock').fields<{\n  scope: BlockSymbolTable;\n  name: SourceSlice;\n  body: Statement[];\n}>() {}\nexport class EndBlock extends node('EndBlock').fields() {}\nexport class AppendTrustedHTML extends node('AppendTrustedHTML').fields<{\n  html: ExpressionNode;\n}>() {}\nexport class AppendTextNode extends node('AppendTextNode').fields<{ text: ExpressionNode }>() {}\nexport class AppendComment extends node('AppendComment').fields<{ value: SourceSlice }>() {}\n\nexport class Component extends node('Component').fields<{\n  tag: ExpressionNode;\n  params: ElementParameters;\n  args: NamedArguments;\n  blocks: NamedBlocks;\n}>() {}\n\nexport interface AttrKind {\n  // triple-curly\n  trusting: boolean;\n  // this attribute is on an element with component features:\n  //   - <CapCase ...>\n  //   - modifiers\n  //   - <dynamic.tag ...>\n  component: boolean;\n}\n\nexport class StaticAttr extends node('StaticAttr').fields<{\n  kind: { component: boolean };\n  name: SourceSlice;\n  value: SourceSlice;\n  namespace?: string | undefined;\n}>() {}\n\nexport class DynamicAttr extends node('DynamicAttr').fields<{\n  kind: AttrKind;\n  name: SourceSlice;\n  value: ExpressionNode;\n  namespace?: string | undefined;\n}>() {}\n\nexport class SimpleElement extends node('SimpleElement').fields<{\n  tag: SourceSlice;\n  params: ElementParameters;\n  body: Statement[];\n  dynamicFeatures: boolean;\n}>() {}\n\nexport class ElementParameters extends node('ElementParameters').fields<{\n  body: AnyOptionalList<ElementParameter>;\n}>() {}\n\nexport class Yield extends node('Yield').fields<{\n  target: SourceSlice;\n  to: number;\n  positional: Positional;\n}>() {}\nexport class Debugger extends node('Debugger').fields<{ scope: SymbolTable }>() {}\n\nexport class CallExpression extends node('CallExpression').fields<{\n  callee: ExpressionNode;\n  args: Args;\n}>() {}\nexport class DeprecatedCallExpression extends node('DeprecatedCallExpression').fields<{\n  arg: SourceSlice;\n  callee: ASTv2.FreeVarReference;\n}>() {}\n\nexport class Modifier extends node('Modifier').fields<{ callee: ExpressionNode; args: Args }>() {}\nexport class InvokeBlock extends node('InvokeBlock').fields<{\n  head: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks;\n}>() {}\nexport class SplatAttr extends node('SplatAttr').fields<{ symbol: number }>() {}\nexport class PathExpression extends node('PathExpression').fields<{\n  head: ExpressionNode;\n  tail: Tail;\n}>() {}\nexport class GetWithResolver extends node('GetWithResolver').fields<{\n  symbol: number;\n}>() {}\n\nexport class GetSymbol extends node('GetSymbol').fields<{ symbol: number }>() {}\nexport class GetFreeWithContext extends node('GetFreeWithContext').fields<{\n  symbol: number;\n  context: ASTv2.FreeVarResolution;\n}>() {}\n/** strict mode */\nexport class GetFree extends node('GetFree').fields<{\n  symbol: number;\n}>() {}\n\nexport class Missing extends node('Missing').fields() {}\nexport class InterpolateExpression extends node('InterpolateExpression').fields<{\n  parts: PresentList<ExpressionNode>;\n}>() {}\nexport class HasBlock extends node('HasBlock').fields<{ target: SourceSlice; symbol: number }>() {}\nexport class HasBlockParams extends node('HasBlockParams').fields<{\n  target: SourceSlice;\n  symbol: number;\n}>() {}\nexport class Curry extends node('Curry').fields<{\n  definition: ExpressionNode;\n  curriedType: CurriedType;\n  args: Args;\n}>() {}\nexport class Positional extends node('Positional').fields<{\n  list: OptionalList<ExpressionNode>;\n}>() {}\nexport class NamedArguments extends node('NamedArguments').fields<{\n  entries: OptionalList<NamedArgument>;\n}>() {}\nexport class NamedArgument extends node('NamedArgument').fields<{\n  key: SourceSlice;\n  value: ExpressionNode;\n}>() {}\nexport class Args extends node('Args').fields<{\n  positional: Positional;\n  named: NamedArguments;\n}>() {}\nexport class Tail extends node('Tail').fields<{ members: PresentArray<SourceSlice> }>() {}\n\nexport type ExpressionNode =\n  | ASTv2.LiteralExpression\n  | Missing\n  | PathExpression\n  | ASTv2.VariableReference\n  | InterpolateExpression\n  | CallExpression\n  | DeprecatedCallExpression\n  | Not\n  | IfInline\n  | HasBlock\n  | HasBlockParams\n  | Curry\n  | GetDynamicVar\n  | Log;\n\nexport type ElementParameter = StaticAttr | DynamicAttr | Modifier | SplatAttr;\n\nexport type Internal =\n  | Args\n  | Positional\n  | NamedArguments\n  | NamedArgument\n  | Tail\n  | NamedBlock\n  | NamedBlocks\n  | ElementParameters;\nexport type ExprLike = ExpressionNode | Internal;\nexport type Statement =\n  | InElement\n  | Debugger\n  | Yield\n  | AppendTrustedHTML\n  | AppendTextNode\n  | Component\n  | SimpleElement\n  | InvokeBlock\n  | AppendComment\n  | If\n  | Each\n  | With\n  | Let\n  | WithDynamicVars\n  | InvokeComponent;\n","import type { Nullable, PresentArray } from '@glimmer/interfaces';\nimport { isPresentArray, mapPresentArray } from '@glimmer/util';\n\nexport interface OptionalList<T> {\n  map<U>(callback: (input: T) => U): MapList<T, U, AnyOptionalList<T>>;\n  filter<S extends T>(\n    predicate: (value: T, index: number, array: T[]) => value is S\n  ): AnyOptionalList<S>;\n  toArray(): T[];\n  toPresentArray(): Nullable<PresentArray<T>>;\n  into<U, V>(options: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V;\n}\n\nexport class PresentList<T> implements OptionalList<T> {\n  constructor(readonly list: PresentArray<T>) {}\n\n  toArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  map<U>(callback: (input: T) => U): MapList<T, U, PresentList<T>> {\n    let result = mapPresentArray(this.list, callback);\n    return new PresentList(result) as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(predicate: (value: T) => value is S): AnyOptionalList<S> {\n    let out: S[] = [];\n\n    for (let item of this.list) {\n      if (predicate(item)) {\n        out.push(item);\n      }\n    }\n\n    return OptionalList(out);\n  }\n\n  toPresentArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  into<U, V>({ ifPresent }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifPresent(this);\n  }\n}\n\nexport class EmptyList<T> implements OptionalList<T> {\n  readonly list: T[] = [];\n\n  map<U>(_callback: (input: T) => U): MapList<T, U, EmptyList<T>> {\n    return new EmptyList() as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(_predicate: (value: T) => value is S): AnyOptionalList<S> {\n    return new EmptyList();\n  }\n\n  toArray(): T[] {\n    return this.list;\n  }\n\n  toPresentArray(): Nullable<PresentArray<T>> {\n    return null;\n  }\n\n  into<U, V>({ ifEmpty }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifEmpty();\n  }\n}\n\n// export type OptionalList<T> = PresentList<T> | EmptyList<T>;\n\nexport function OptionalList<T>(value: readonly T[]): AnyOptionalList<T> {\n  if (isPresentArray(value)) {\n    return new PresentList(value);\n  } else {\n    return new EmptyList<T>();\n  }\n}\n\nexport type AnyOptionalList<T> = (PresentList<T> | EmptyList<T>) & OptionalList<T>;\n\nexport type MapList<T, U, L extends OptionalList<T>> = L extends PresentList<T>\n  ? PresentList<U>\n  : L extends EmptyList<T>\n  ? EmptyList<U>\n  : never;\n","import type { GlimmerSyntaxError } from '@glimmer/syntax';\n\nimport { type AnyOptionalList, OptionalList } from './list';\n\nabstract class ResultImpl<T> {\n  static all<T extends Result<unknown>[]>(...results: T): MapAll<T> {\n    let out: unknown[] = [];\n\n    for (let result of results) {\n      if (result.isErr) {\n        return result.cast();\n      } else {\n        out.push(result.value);\n      }\n    }\n\n    return Ok(out as MapAllOk<T>);\n  }\n\n  abstract mapOk<U>(callback: (value: T) => U): Result<U>;\n  abstract readonly isOk: boolean;\n  abstract readonly isErr: boolean;\n}\n\nexport const Result = ResultImpl;\n\nclass OkImpl<T> extends ResultImpl<T> {\n  readonly isOk = true;\n  readonly isErr = false;\n\n  constructor(readonly value: T) {\n    super();\n  }\n\n  expect(_message?: string): T {\n    return this.value;\n  }\n\n  ifOk(callback: (value: T) => void): this {\n    callback(this.value);\n    return this;\n  }\n\n  andThen<U>(callback: (value: T) => Result<U>): Result<U> {\n    return callback(this.value);\n  }\n\n  mapOk<U>(callback: (value: T) => U): Result<U> {\n    return Ok(callback(this.value));\n  }\n\n  ifErr(_callback: (value: GlimmerSyntaxError) => void): this {\n    return this;\n  }\n\n  mapErr(_callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return this;\n  }\n}\n\nclass ErrImpl<T> extends ResultImpl<T> {\n  readonly isOk = false;\n  readonly isErr = true;\n\n  constructor(readonly reason: GlimmerSyntaxError) {\n    super();\n  }\n\n  expect(message?: string): T {\n    throw new Error(message || 'expected an Ok, got Err');\n  }\n\n  andThen<U>(_callback: (value: T) => Result<U>): Result<U> {\n    return this.cast<U>();\n  }\n\n  mapOk<U>(_callback: (value: T) => U): Result<U> {\n    return this.cast<U>();\n  }\n\n  ifOk(_callback: (value: T) => void): this {\n    return this;\n  }\n\n  mapErr(callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return Err(callback(this.reason));\n  }\n\n  ifErr(callback: (value: GlimmerSyntaxError) => void): this {\n    callback(this.reason);\n    return this;\n  }\n\n  cast<U>(): Result<U> {\n    return this as unknown as Result<U>;\n  }\n}\n\nexport function isResult<T>(input: MaybeResult<T>): input is Result<T> {\n  return input instanceof ResultImpl;\n}\n\nexport function intoResult<T>(input: MaybeResult<T>): Result<T> {\n  if (isResult(input)) {\n    return input;\n  } else {\n    return Ok(input);\n  }\n}\n\nexport type Result<T> = OkImpl<T> | ErrImpl<T>;\n\ntype MapAllOk<T extends Result<unknown>[]> = {\n  [P in keyof T]: T[P] extends Result<infer Inner> ? Inner : never;\n};\n\ntype MapAll<T extends Result<unknown>[]> = Result<MapAllOk<T>>;\n\nexport function Ok<T>(value: T): Result<T> {\n  return new OkImpl(value);\n}\n\nexport type Ok<T> = OkImpl<T>;\n\nexport function Err<T>(reason: GlimmerSyntaxError): Result<T> {\n  return new ErrImpl(reason);\n}\n\nexport type Err<T> = ErrImpl<T>;\n\nexport type MaybeResult<T> = T | Result<T>;\n\nexport class MapIntoResultArray<T> {\n  constructor(private items: T[]) {}\n\n  map<U>(mapper: (item: T) => Result<U>): Result<U[]> {\n    let out = new ResultArray<U>();\n\n    for (let item of this.items) {\n      out.add(mapper(item));\n    }\n\n    return out.toArray();\n  }\n}\n\nexport class ResultArray<T> {\n  constructor(private items: Result<T>[] = []) {}\n\n  add(item: Result<T>): void {\n    this.items.push(item);\n  }\n\n  toArray(): Result<T[]> {\n    let err = this.items.filter((item): item is ErrImpl<T> => item instanceof ErrImpl)[0];\n\n    if (err !== undefined) {\n      return err.cast<T[]>();\n    } else {\n      return Ok((this.items as OkImpl<T>[]).map((item) => item.value));\n    }\n  }\n\n  toOptionalList(): Result<AnyOptionalList<T>> {\n    return this.toArray().mapOk((arr) => OptionalList(arr));\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { ASTv2, generateSyntaxError, type SourceSlice } from '@glimmer/syntax';\nimport { unreachable } from '@glimmer/util';\n\nexport type HasPath<Node extends ASTv2.CallNode = ASTv2.CallNode> = Node & {\n  head: ASTv2.PathExpression;\n};\n\nexport type HasArguments =\n  | {\n      params: PresentArray<ASTv2.ExpressionNode>;\n    }\n  | {\n      hash: {\n        pairs: PresentArray<ASTv2.NamedArgument>;\n      };\n    };\n\nexport type HelperInvocation<Node extends ASTv2.CallNode = ASTv2.CallNode> = HasPath<Node> &\n  HasArguments;\n\nexport function hasPath<N extends ASTv2.CallNode>(node: N): node is HasPath<N> {\n  return node.callee.type === 'Path';\n}\n\nexport function isHelperInvocation<N extends ASTv2.CallNode>(\n  node: ASTv2.CallNode\n): node is HelperInvocation<N> {\n  if (!hasPath(node)) {\n    return false;\n  }\n\n  return !node.args.isEmpty();\n}\n\nexport interface SimplePath extends ASTv2.PathExpression {\n  tail: [SourceSlice];\n  data: false;\n  this: false;\n}\n\nexport type SimpleHelper<N extends HasPath> = N & {\n  path: SimplePath;\n};\n\nexport function isSimplePath(path: ASTv2.ExpressionNode): path is SimplePath {\n  if (path.type === 'Path') {\n    let { ref: head, tail: parts } = path;\n\n    return head.type === 'Free' && !ASTv2.isStrictResolution(head.resolution) && parts.length === 0;\n  } else {\n    return false;\n  }\n}\n\nexport function isStrictHelper(expr: HasPath): boolean {\n  if (expr.callee.type !== 'Path') {\n    return true;\n  }\n\n  if (expr.callee.ref.type !== 'Free') {\n    return true;\n  }\n\n  return ASTv2.isStrictResolution(expr.callee.ref.resolution);\n}\n\nexport function assertIsValidModifier<N extends HasPath>(\n  helper: N\n): asserts helper is SimpleHelper<N> {\n  if (isStrictHelper(helper) || isSimplePath(helper.callee)) {\n    return;\n  }\n\n  throw generateSyntaxError(\n    `\\`${printPath(helper.callee)}\\` is not a valid name for a modifier`,\n    helper.loc\n  );\n}\n\nfunction printPath(path: ASTv2.ExpressionNode): string {\n  switch (path.type) {\n    case 'Literal':\n      return JSON.stringify(path.value);\n    case 'Path': {\n      let printedPath = [printPathHead(path.ref)];\n      printedPath.push(...path.tail.map((t) => t.chars));\n      return printedPath.join('.');\n    }\n    case 'Call':\n      return `(${printPath(path.callee)} ...)`;\n    case 'DeprecatedCall':\n      return `${path.callee.name}`;\n    case 'Interpolate':\n      throw unreachable('a concat statement cannot appear as the head of an expression');\n  }\n}\n\nfunction printPathHead(head: ASTv2.VariableReference): string {\n  switch (head.type) {\n    case 'Arg':\n      return head.name.chars;\n    case 'Free':\n    case 'Local':\n      return head.name;\n    case 'This':\n      return 'this';\n  }\n}\n\n/**\n * This function is checking whether an AST node is a triple-curly, which means that it's\n * a \"trusting\" node. In the Handlebars AST, this is indicated by the `escaped` flag, which\n * is a bit of a double-negative, so we change the terminology here for clarity.\n */\nexport function isTrustingNode(\n  value: ASTv2.AppendContent | ASTv2.HtmlText | ASTv2.InterpolateExpression\n): boolean {\n  if (value.type === 'AppendContent') {\n    return value.trusting;\n  } else {\n    return false;\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { ASTv2, KEYWORDS_TYPES } from '@glimmer/syntax';\nimport { getLast, isPresentArray } from '@glimmer/util';\n\nimport type { AnyOptionalList, PresentList } from '../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport type { NormalizationState } from '../context';\nimport { CALL_KEYWORDS } from '../keywords';\nimport { hasPath } from '../utils/is-node';\n\nexport class NormalizeExpressions {\n  visit(node: ASTv2.ExpressionNode, state: NormalizationState): Result<mir.ExpressionNode> {\n    switch (node.type) {\n      case 'Literal':\n        return Ok(this.Literal(node));\n      case 'Interpolate':\n        return this.Interpolate(node, state);\n      case 'Path':\n        return this.PathExpression(node);\n      case 'Call': {\n        let translated = CALL_KEYWORDS.translate(node, state);\n\n        if (translated !== null) {\n          return translated;\n        }\n\n        return this.CallExpression(node, state);\n      }\n      case 'DeprecatedCall':\n        return this.DeprecaedCallExpression(node, state);\n    }\n  }\n\n  visitList(\n    nodes: PresentArray<ASTv2.ExpressionNode>,\n    state: NormalizationState\n  ): Result<PresentList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>> {\n    return new ResultArray(nodes.map((e) => VISIT_EXPRS.visit(e, state))).toOptionalList();\n  }\n\n  /**\n   * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.\n   *\n   * TODO since keywords don't support tails anyway, distinguish PathExpression from\n   * VariableReference in ASTv2.\n   */\n  PathExpression(path: ASTv2.PathExpression): Result<mir.ExpressionNode> {\n    let ref = this.VariableReference(path.ref);\n    let { tail } = path;\n\n    if (isPresentArray(tail)) {\n      let tailLoc = tail[0].loc.extend(getLast(tail).loc);\n      return Ok(\n        new mir.PathExpression({\n          loc: path.loc,\n          head: ref,\n          tail: new mir.Tail({ loc: tailLoc, members: tail }),\n        })\n      );\n    } else {\n      return Ok(ref);\n    }\n  }\n\n  VariableReference(ref: ASTv2.VariableReference): ASTv2.VariableReference {\n    return ref;\n  }\n\n  Literal(literal: ASTv2.LiteralExpression): ASTv2.LiteralExpression {\n    return literal;\n  }\n\n  Interpolate(\n    expr: ASTv2.InterpolateExpression,\n    state: NormalizationState\n  ): Result<mir.InterpolateExpression> {\n    let parts = expr.parts.map(convertPathToCallIfKeyword) as PresentArray<ASTv2.ExpressionNode>;\n\n    return VISIT_EXPRS.visitList(parts, state).mapOk(\n      (parts) => new mir.InterpolateExpression({ loc: expr.loc, parts: parts })\n    );\n  }\n\n  CallExpression(\n    expr: ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<mir.ExpressionNode> {\n    if (!hasPath(expr)) {\n      throw new Error(`unimplemented subexpression at the head of a subexpression`);\n    } else {\n      return Result.all(\n        VISIT_EXPRS.visit(expr.callee, state),\n        VISIT_EXPRS.Args(expr.args, state)\n      ).mapOk(\n        ([callee, args]) =>\n          new mir.CallExpression({\n            loc: expr.loc,\n            callee,\n            args,\n          })\n      );\n    }\n  }\n\n  DeprecaedCallExpression(\n    { arg, callee, loc }: ASTv2.DeprecatedCallExpression,\n    _state: NormalizationState\n  ): Result<mir.ExpressionNode> {\n    return Ok(new mir.DeprecatedCallExpression({ loc, arg, callee }));\n  }\n\n  Args({ positional, named, loc }: ASTv2.Args, state: NormalizationState): Result<mir.Args> {\n    return Result.all(this.Positional(positional, state), this.NamedArguments(named, state)).mapOk(\n      ([positional, named]) =>\n        new mir.Args({\n          loc,\n          positional,\n          named,\n        })\n    );\n  }\n\n  Positional(\n    positional: ASTv2.PositionalArguments,\n    state: NormalizationState\n  ): Result<mir.Positional> {\n    return VISIT_EXPRS.visitList(positional.exprs, state).mapOk(\n      (list) =>\n        new mir.Positional({\n          loc: positional.loc,\n          list,\n        })\n    );\n  }\n\n  NamedArguments(\n    named: ASTv2.NamedArguments,\n    state: NormalizationState\n  ): Result<mir.NamedArguments> {\n    let pairs = named.entries.map((arg) => {\n      let value = convertPathToCallIfKeyword(arg.value);\n\n      return VISIT_EXPRS.visit(value, state).mapOk(\n        (value) =>\n          new mir.NamedArgument({\n            loc: arg.loc,\n            key: arg.name,\n            value,\n          })\n      );\n    });\n\n    return new ResultArray(pairs)\n      .toOptionalList()\n      .mapOk((pairs) => new mir.NamedArguments({ loc: named.loc, entries: pairs }));\n  }\n}\n\nexport function convertPathToCallIfKeyword(path: ASTv2.ExpressionNode): ASTv2.ExpressionNode {\n  if (path.type === 'Path' && path.ref.type === 'Free' && path.ref.name in KEYWORDS_TYPES) {\n    return new ASTv2.CallExpression({\n      callee: path,\n      args: ASTv2.Args.empty(path.loc),\n      loc: path.loc,\n    });\n  }\n\n  return path;\n}\n\nexport const VISIT_EXPRS = new NormalizeExpressions();\n","import {\n  type ASTv2,\n  generateSyntaxError,\n  isKeyword,\n  KEYWORDS_TYPES,\n  type KeywordType,\n} from '@glimmer/syntax';\nimport { exhausted } from '@glimmer/util';\n\nimport { Err, type Result } from '../../../shared/result';\nimport type { NormalizationState } from '../context';\n\nexport interface KeywordDelegate<Match extends KeywordMatch, V, Out> {\n  assert(options: Match, state: NormalizationState): Result<V>;\n  translate(options: { node: Match; state: NormalizationState }, param: V): Result<Out>;\n}\n\nexport interface Keyword<K extends KeywordType = KeywordType, Out = unknown> {\n  translate(node: KeywordCandidates[K], state: NormalizationState): Result<Out> | null;\n}\n\nexport interface BlockKeyword<Out = unknown> {\n  translate(node: ASTv2.InvokeBlock, state: NormalizationState): Result<Out> | null;\n}\n\nclass KeywordImpl<\n  K extends KeywordType,\n  S extends string = string,\n  Param = unknown,\n  Out = unknown\n> {\n  protected types: Set<KeywordCandidates[K]['type']>;\n\n  constructor(\n    protected keyword: S,\n    type: KeywordType,\n    private delegate: KeywordDelegate<KeywordMatches[K], Param, Out>\n  ) {\n    let nodes = new Set<KeywordNode['type']>();\n    for (let nodeType of KEYWORD_NODES[type]) {\n      nodes.add(nodeType);\n    }\n\n    this.types = nodes;\n  }\n\n  protected match(node: KeywordCandidates[K]): node is KeywordMatches[K] {\n    if (!this.types.has(node.type)) {\n      return false;\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path !== null && path.type === 'Path' && path.ref.type === 'Free') {\n      if (path.tail.length > 0) {\n        if (path.ref.resolution.serialize() === 'Loose') {\n          // cannot be a keyword reference, keywords do not allow paths (must be\n          // relying on implicit this fallback)\n          return false;\n        }\n      }\n\n      return path.ref.name === this.keyword;\n    } else {\n      return false;\n    }\n  }\n\n  translate(node: KeywordMatches[K], state: NormalizationState): Result<Out> | null {\n    if (this.match(node)) {\n      let path = getCalleeExpression(node);\n\n      if (path !== null && path.type === 'Path' && path.tail.length > 0) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${\n              this.keyword\n            }\\` keyword was used incorrectly. It was used as \\`${path.loc.asString()}\\`, but it cannot be used with additional path segments. \\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n\n      let param = this.delegate.assert(node, state);\n      return param.andThen((param) => this.delegate.translate({ node, state }, param));\n    } else {\n      return null;\n    }\n  }\n}\n\nexport type PossibleNode =\n  | ASTv2.PathExpression\n  | ASTv2.AppendContent\n  | ASTv2.CallExpression\n  | ASTv2.InvokeBlock;\n\nexport const KEYWORD_NODES = {\n  Call: ['Call'],\n  Block: ['InvokeBlock'],\n  Append: ['AppendContent'],\n  Modifier: ['ElementModifier'],\n} as const;\n\nexport interface KeywordCandidates {\n  Call: ASTv2.ExpressionNode;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordCandidate = KeywordCandidates[keyof KeywordCandidates];\n\nexport interface KeywordMatches {\n  Call: ASTv2.CallExpression;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordMatch = KeywordMatches[keyof KeywordMatches];\n\n/**\n * A \"generic\" keyword is something like `has-block`, which makes sense in the context\n * of sub-expression or append\n */\nexport type GenericKeywordNode = ASTv2.AppendContent | ASTv2.CallExpression;\n\nexport type KeywordNode =\n  | GenericKeywordNode\n  | ASTv2.CallExpression\n  | ASTv2.InvokeBlock\n  | ASTv2.ElementModifier;\n\nexport function keyword<\n  K extends KeywordType,\n  D extends KeywordDelegate<KeywordMatches[K], unknown, Out>,\n  Out = unknown\n>(keyword: string, type: K, delegate: D): Keyword<K, Out> {\n  return new KeywordImpl(keyword, type, delegate as KeywordDelegate<KeywordMatch, unknown, Out>);\n}\n\nexport type PossibleKeyword = KeywordNode;\ntype OutFor<K extends Keyword | BlockKeyword> = K extends BlockKeyword<infer Out>\n  ? Out\n  : K extends Keyword<KeywordType, infer Out>\n  ? Out\n  : never;\n\nfunction getCalleeExpression(\n  node: KeywordNode | ASTv2.ExpressionNode\n): ASTv2.ExpressionNode | null {\n  switch (node.type) {\n    // This covers the inside of attributes and expressions, as well as the callee\n    // of call nodes\n    case 'Path':\n      return node;\n    case 'AppendContent':\n      return getCalleeExpression(node.value);\n    case 'Call':\n    case 'InvokeBlock':\n    case 'ElementModifier':\n      return node.callee;\n    default:\n      return null;\n  }\n}\n\nexport class Keywords<K extends KeywordType, KeywordList extends Keyword<K> = never>\n  implements Keyword<K, OutFor<KeywordList>>\n{\n  _keywords: Keyword[] = [];\n  _type: K;\n\n  constructor(type: K) {\n    this._type = type;\n  }\n\n  kw<S extends string = string, Out = unknown>(\n    name: S,\n    delegate: KeywordDelegate<KeywordMatches[K], unknown, Out>\n  ): Keywords<K, KeywordList | Keyword<K, Out>> {\n    this._keywords.push(keyword(name, this._type, delegate));\n\n    return this;\n  }\n\n  translate(\n    node: KeywordCandidates[K],\n    state: NormalizationState\n  ): Result<OutFor<KeywordList>> | null {\n    for (let keyword of this._keywords) {\n      let result = keyword.translate(node, state) as Result<OutFor<KeywordList>>;\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path && path.type === 'Path' && path.ref.type === 'Free' && isKeyword(path.ref.name)) {\n      let { name } = path.ref as { name: keyof typeof KEYWORDS_TYPES };\n\n      let usedType = this._type;\n      let validTypes: readonly KeywordType[] = KEYWORDS_TYPES[name];\n\n      if (!validTypes.includes(usedType)) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${name}\\` keyword was used incorrectly. It was used as ${\n              typesToReadableName[usedType]\n            }, but its valid usages are:\\n\\n${generateTypesMessage(\n              name,\n              validTypes\n            )}\\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    return null;\n  }\n}\n\nconst typesToReadableName = {\n  Append: 'an append statement',\n  Block: 'a block statement',\n  Call: 'a call expression',\n  Modifier: 'a modifier',\n};\n\nfunction generateTypesMessage(name: string, types: readonly KeywordType[]): string {\n  return types\n    .map((type) => {\n      switch (type) {\n        case 'Append':\n          return `- As an append statement, as in: {{${name}}}`;\n        case 'Block':\n          return `- As a block statement, as in: {{#${name}}}{{/${name}}}`;\n        case 'Call':\n          return `- As an expression, as in: (${name})`;\n        case 'Modifier':\n          return `- As a modifier, as in: <div {{${name}}}></div>`;\n        default:\n          return exhausted(type);\n      }\n    })\n    .join('\\n\\n');\n}\n\n/**\n * This function builds keyword definitions for a particular type of AST node (`KeywordType`).\n *\n * You can build keyword definitions for:\n *\n * - `Expr`: A `SubExpression` or `PathExpression`\n * - `Block`: A `BlockStatement`\n *   - A `BlockStatement` is a keyword candidate if its head is a\n *     `PathExpression`\n * - `Append`: An `AppendStatement`\n *\n * A node is a keyword candidate if:\n *\n * - A `PathExpression` is a keyword candidate if it has no tail, and its\n *   head expression is a `LocalVarHead` or `FreeVarHead` whose name is\n *   the keyword's name.\n * - A `SubExpression`, `AppendStatement`, or `BlockStatement` is a keyword\n *   candidate if its head is a keyword candidate.\n *\n * The keyword infrastructure guarantees that:\n *\n * - If a node is not a keyword candidate, it is never passed to any keyword's\n *   `assert` method.\n * - If a node is not the `KeywordType` for a particular keyword, it will not\n *   be passed to the keyword's `assert` method.\n *\n * `Expr` keywords are used in expression positions and should return HIR\n * expressions. `Block` and `Append` keywords are used in statement\n * positions and should return HIR statements.\n *\n * A keyword definition has two parts:\n *\n * - `match`, which determines whether an AST node matches the keyword, and can\n *   optionally return some information extracted from the AST node.\n * - `translate`, which takes a matching AST node as well as the extracted\n *   information and returns an appropriate HIR instruction.\n *\n * # Example\n *\n * This keyword:\n *\n * - turns `(hello)` into `\"hello\"`\n *   - as long as `hello` is not in scope\n * - makes it an error to pass any arguments (such as `(hello world)`)\n *\n * ```ts\n * keywords('SubExpr').kw('hello', {\n *   assert(node: ExprKeywordNode): Result<void> | false {\n *     // we don't want to transform `hello` as a `PathExpression`\n *     if (node.type !== 'SubExpression') {\n *       return false;\n *     }\n *\n *     // node.head would be `LocalVarHead` if `hello` was in scope\n *     if (node.head.type !== 'FreeVarHead') {\n *       return false;\n *     }\n *\n *     if (node.params.length || node.hash) {\n *       return Err(generateSyntaxError(`(hello) does not take any arguments`), node.loc);\n *     } else {\n *       return Ok();\n *     }\n *   },\n *\n *   translate(node: ASTv2.SubExpression): hir.Expression {\n *     return ASTv2.builders.literal(\"hello\", node.loc)\n *   }\n * })\n * ```\n *\n * The keyword infrastructure checks to make sure that the node is the right\n * type before calling `assert`, so you only need to consider `SubExpression`\n * and `PathExpression` here. It also checks to make sure that the node passed\n * to `assert` has the keyword name in the right place.\n *\n * Note the important difference between returning `false` from `assert`,\n * which just means that the node didn't match, and returning `Err`, which\n * means that the node matched, but there was a keyword-specific syntax\n * error.\n */\nexport function keywords<K extends KeywordType>(type: K): Keywords<K> {\n  return new Keywords(type);\n}\n","import type { Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nexport function toAppend<T>({\n  assert,\n  translate,\n}: KeywordDelegate<GenericKeywordNode, T, mir.ExpressionNode>): KeywordDelegate<\n  GenericKeywordNode,\n  T,\n  mir.AppendTextNode\n> {\n  return {\n    assert,\n    translate(\n      { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n      value: T\n    ): Result<mir.AppendTextNode> {\n      let result = translate({ node, state }, value);\n\n      return result.mapOk((text) => new mir.AppendTextNode({ text, loc: node.loc }));\n    },\n  };\n}\n","import type { CurriedType } from '@glimmer/interfaces';\nimport { ASTv2, generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\nimport type { KeywordDelegate } from '../impl';\n\nconst CurriedTypeToReadableType = {\n  [CurriedTypes.Component]: 'component',\n  [CurriedTypes.Helper]: 'helper',\n  [CurriedTypes.Modifier]: 'modifier',\n} as const;\n\nexport function assertCurryKeyword(curriedType: CurriedType) {\n  return (\n    node: ASTv2.AppendContent | ASTv2.InvokeBlock | ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<{\n    definition: ASTv2.ExpressionNode;\n    args: ASTv2.Args;\n  }> => {\n    let readableType = CurriedTypeToReadableType[curriedType];\n    let stringsAllowed = curriedType === CurriedTypes.Component;\n\n    let { args } = node;\n\n    let definition = args.nth(0);\n\n    if (definition === null) {\n      return Err(\n        generateSyntaxError(\n          `(${readableType}) requires a ${readableType} definition or identifier as its first positional parameter, did not receive any parameters.`,\n          args.loc\n        )\n      );\n    }\n\n    if (definition.type === 'Literal') {\n      if (stringsAllowed && state.isStrict) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values in strict mode templates`,\n            node.loc\n          )\n        );\n      } else if (!stringsAllowed) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values, you must pass a ${readableType} definition directly`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    args = new ASTv2.Args({\n      positional: new ASTv2.PositionalArguments({\n        exprs: args.positional.exprs.slice(1),\n        loc: args.positional.loc,\n      }),\n      named: args.named,\n      loc: args.loc,\n    });\n\n    return Ok({ definition, args });\n  };\n}\n\nfunction translateCurryKeyword(curriedType: CurriedType) {\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.CallExpression | ASTv2.AppendContent; state: NormalizationState },\n    { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n  ): Result<mir.Curry> => {\n    let definitionResult = VISIT_EXPRS.visit(definition, state);\n    let argsResult = VISIT_EXPRS.Args(args, state);\n\n    return Result.all(definitionResult, argsResult).mapOk(\n      ([definition, args]) =>\n        new mir.Curry({\n          loc: node.loc,\n          curriedType,\n          definition,\n          args,\n        })\n    );\n  };\n}\n\nexport function curryKeyword(\n  curriedType: CurriedType\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  { definition: ASTv2.ExpressionNode; args: ASTv2.Args },\n  mir.Curry\n> {\n  return {\n    assert: assertCurryKeyword(curriedType),\n    translate: translateCurryKeyword(curriedType),\n  };\n}\n","import { type ASTv2, generateSyntaxError } from '@glimmer/syntax';\n\nimport { Err, Ok, type Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nfunction assertGetDynamicVarKeyword(node: GenericKeywordNode): Result<ASTv2.ExpressionNode> {\n  let call = node.type === 'AppendContent' ? node.value : node;\n\n  let named = call.type === 'Call' ? call.args.named : null;\n  let positionals = call.type === 'Call' ? call.args.positional : null;\n\n  if (named && !named.isEmpty()) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) does not take any named arguments`, node.loc)\n    );\n  }\n\n  let varName = positionals?.nth(0);\n\n  if (!varName) {\n    return Err(generateSyntaxError(`(-get-dynamic-vars) requires a var name to get`, node.loc));\n  }\n\n  if (positionals && positionals.size > 1) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) only receives one positional arg`, node.loc)\n    );\n  }\n\n  return Ok(varName);\n}\n\nfunction translateGetDynamicVarKeyword(\n  { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n  name: ASTv2.ExpressionNode\n): Result<mir.GetDynamicVar> {\n  return VISIT_EXPRS.visit(name, state).mapOk(\n    (name) => new mir.GetDynamicVar({ name, loc: node.loc })\n  );\n}\n\nexport const getDynamicVarKeyword: KeywordDelegate<\n  GenericKeywordNode,\n  ASTv2.ExpressionNode,\n  mir.GetDynamicVar\n> = {\n  assert: assertGetDynamicVarKeyword,\n  translate: translateGetDynamicVarKeyword,\n};\n","import { ASTv2, generateSyntaxError, SourceSlice } from '@glimmer/syntax';\n\nimport { Err, Ok, type Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nfunction assertHasBlockKeyword(type: string) {\n  return (node: GenericKeywordNode): Result<SourceSlice> => {\n    let call = node.type === 'AppendContent' ? node.value : node;\n\n    let named = call.type === 'Call' ? call.args.named : null;\n    let positionals = call.type === 'Call' ? call.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(generateSyntaxError(`(${type}) does not take any named arguments`, call.loc));\n    }\n\n    if (!positionals || positionals.isEmpty()) {\n      return Ok(SourceSlice.synthetic('default'));\n    } else if (positionals.exprs.length === 1) {\n      let positional = positionals.exprs[0] as ASTv2.ExpressionNode;\n      if (ASTv2.isLiteral(positional, 'string')) {\n        return Ok(positional.toSlice());\n      } else {\n        return Err(\n          generateSyntaxError(\n            `(${type}) can only receive a string literal as its first argument`,\n            call.loc\n          )\n        );\n      }\n    } else {\n      return Err(\n        generateSyntaxError(`(${type}) only takes a single positional argument`, call.loc)\n      );\n    }\n  };\n}\n\nfunction translateHasBlockKeyword(type: string) {\n  return (\n    { node, state: { scope } }: { node: ASTv2.CallExpression; state: NormalizationState },\n    target: SourceSlice\n  ): Result<mir.HasBlock | mir.HasBlockParams> => {\n    let block =\n      type === 'has-block'\n        ? new mir.HasBlock({ loc: node.loc, target, symbol: scope.allocateBlock(target.chars) })\n        : new mir.HasBlockParams({\n            loc: node.loc,\n            target,\n            symbol: scope.allocateBlock(target.chars),\n          });\n\n    return Ok(block);\n  };\n}\n\nexport function hasBlockKeyword(\n  type: string\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  SourceSlice,\n  mir.HasBlock | mir.HasBlockParams\n> {\n  return {\n    assert: assertHasBlockKeyword(type),\n    translate: translateHasBlockKeyword(type),\n  };\n}\n","import { type ASTv2, generateSyntaxError } from '@glimmer/syntax';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\nimport type { KeywordDelegate } from '../impl';\n\nfunction assertIfUnlessInlineKeyword(type: string) {\n  return (\n    originalNode: ASTv2.AppendContent | ASTv2.ExpressionNode\n  ): Result<{\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  }> => {\n    let inverted = type === 'unless';\n\n    let node = originalNode.type === 'AppendContent' ? originalNode.value : originalNode;\n    let named = node.type === 'Call' ? node.args.named : null;\n    let positional = node.type === 'Call' ? node.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(\n        generateSyntaxError(\n          `(${type}) cannot receive named parameters, received ${named.entries\n            .map((e) => e.name.chars)\n            .join(', ')}`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let condition = positional?.nth(0);\n\n    if (!positional || !condition) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Did not receive any parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let truthy = positional.nth(1);\n    let falsy = positional.nth(2);\n\n    if (truthy === null) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Received only one parameter, the condition`,\n          originalNode.loc\n        )\n      );\n    }\n\n    if (positional.size > 3) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${type}), 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }, and 3. the value to return if the condition is ${\n            inverted ? 'true' : 'false'\n          }. Received ${positional?.size ?? 0} parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    return Ok({ condition, truthy, falsy });\n  };\n}\n\nfunction translateIfUnlessInlineKeyword(type: string) {\n  let inverted = type === 'unless';\n\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.AppendContent | ASTv2.ExpressionNode; state: NormalizationState },\n    {\n      condition,\n      truthy,\n      falsy,\n    }: {\n      condition: ASTv2.ExpressionNode;\n      truthy: ASTv2.ExpressionNode;\n      falsy: ASTv2.ExpressionNode | null;\n    }\n  ): Result<mir.IfInline> => {\n    let conditionResult = VISIT_EXPRS.visit(condition, state);\n    let truthyResult = VISIT_EXPRS.visit(truthy, state);\n    let falsyResult = falsy ? VISIT_EXPRS.visit(falsy, state) : Ok(null);\n\n    return Result.all(conditionResult, truthyResult, falsyResult).mapOk(\n      ([condition, truthy, falsy]) => {\n        if (inverted) {\n          condition = new mir.Not({ value: condition, loc: node.loc });\n        }\n\n        return new mir.IfInline({\n          loc: node.loc,\n          condition,\n          truthy,\n          falsy,\n        });\n      }\n    );\n  };\n}\n\nexport function ifUnlessInlineKeyword(type: string): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  {\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  },\n  mir.IfInline\n> {\n  return {\n    assert: assertIfUnlessInlineKeyword(type),\n    translate: translateIfUnlessInlineKeyword(type),\n  };\n}\n","import { type ASTv2, generateSyntaxError } from '@glimmer/syntax';\n\nimport { Err, Ok, type Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nfunction assertLogKeyword(node: GenericKeywordNode): Result<ASTv2.PositionalArguments> {\n  let {\n    args: { named, positional },\n  } = node;\n\n  if (named && !named.isEmpty()) {\n    return Err(generateSyntaxError(`(log) does not take any named arguments`, node.loc));\n  }\n\n  return Ok(positional);\n}\n\nfunction translateLogKeyword(\n  { node, state }: { node: ASTv2.CallExpression; state: NormalizationState },\n  positional: ASTv2.PositionalArguments\n): Result<mir.Log> {\n  return VISIT_EXPRS.Positional(positional, state).mapOk(\n    (positional) => new mir.Log({ positional, loc: node.loc })\n  );\n}\n\nexport const logKeyword: KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  ASTv2.PositionalArguments,\n  mir.Log\n> = {\n  assert: assertLogKeyword,\n  translate: translateLogKeyword,\n};\n","import { ASTv2, generateSyntaxError, src } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport type { NormalizationState } from '../context';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { keywords } from './impl';\nimport { toAppend } from './utils/call-to-append';\nimport { assertCurryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const APPEND_KEYWORDS = keywords('Append')\n  .kw('has-block', toAppend(hasBlockKeyword('has-block')))\n  .kw('has-block-params', toAppend(hasBlockKeyword('has-block-params')))\n  .kw('-get-dynamic-var', toAppend(getDynamicVarKeyword))\n  .kw('log', toAppend(logKeyword))\n  .kw('if', toAppend(ifUnlessInlineKeyword('if')))\n  .kw('unless', toAppend(ifUnlessInlineKeyword('unless')))\n  .kw('yield', {\n    assert(node: ASTv2.AppendContent): Result<{\n      target: src.SourceSlice;\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (args.named.isEmpty()) {\n        return Ok({\n          target: src.SourceSpan.synthetic('default').toSlice(),\n          positional: args.positional,\n        });\n      } else {\n        let target = args.named.get('to');\n\n        if (args.named.size > 1 || target === null) {\n          return Err(\n            generateSyntaxError(`yield only takes a single named argument: 'to'`, args.named.loc)\n          );\n        }\n\n        if (ASTv2.isLiteral(target, 'string')) {\n          return Ok({ target: target.toSlice(), positional: args.positional });\n        } else {\n          return Err(\n            generateSyntaxError(`you can only yield to a literal string value`, target.loc)\n          );\n        }\n      }\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      {\n        target,\n        positional,\n      }: {\n        target: src.SourceSlice;\n        positional: ASTv2.PositionalArguments;\n      }\n    ): Result<mir.Statement> {\n      return VISIT_EXPRS.Positional(positional, state).mapOk(\n        (positional) =>\n          new mir.Yield({\n            loc: node.loc,\n            target,\n            to: state.scope.allocateBlock(target.chars),\n            positional,\n          })\n      );\n    },\n  })\n  .kw('debugger', {\n    assert(node: ASTv2.AppendContent): Result<void> {\n      let { args } = node;\n      let { positional } = args;\n\n      if (args.isEmpty()) {\n        return Ok(undefined);\n      } else {\n        if (positional.isEmpty()) {\n          return Err(generateSyntaxError(`debugger does not take any named arguments`, node.loc));\n        } else {\n          return Err(\n            generateSyntaxError(`debugger does not take any positional arguments`, node.loc)\n          );\n        }\n      }\n    },\n\n    translate({\n      node,\n      state: { scope },\n    }: {\n      node: ASTv2.AppendContent;\n      state: NormalizationState;\n    }): Result<mir.Statement> {\n      scope.setHasDebugger();\n      return Ok(new mir.Debugger({ loc: node.loc, scope }));\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(\n        ([definition, args]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks: null,\n          })\n      );\n    },\n  })\n  .kw('helper', {\n    assert: assertCurryKeyword(CurriedTypes.Helper),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.AppendTextNode> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => {\n        let text = new mir.CallExpression({ callee: definition, args, loc: node.loc });\n\n        return new mir.AppendTextNode({\n          loc: node.loc,\n          text,\n        });\n      });\n    },\n  });\n","import { type ASTv2, generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport type { NormalizationState } from '../context';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { VISIT_STMTS } from '../visitors/statements';\nimport { keywords } from './impl';\nimport { assertCurryKeyword } from './utils/curry';\n\nexport const BLOCK_KEYWORDS = keywords('Block')\n  .kw('in-element', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      insertBefore: ASTv2.ExpressionNode | null;\n      destination: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      let guid = args.get('guid');\n\n      if (guid) {\n        return Err(generateSyntaxError(`Cannot pass \\`guid\\` to \\`{{#in-element}}\\``, guid.loc));\n      }\n\n      let insertBefore = args.get('insertBefore');\n      let destination = args.nth(0);\n\n      if (destination === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#in-element}} requires a target element as its first positional parameter`,\n            args.loc\n          )\n        );\n      }\n\n      // TODO Better syntax checks\n\n      return Ok({ insertBefore, destination });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      {\n        insertBefore,\n        destination,\n      }: { insertBefore: ASTv2.ExpressionNode | null; destination: ASTv2.ExpressionNode }\n    ): Result<mir.InElement> {\n      let named = node.blocks.get('default');\n      let body = VISIT_STMTS.NamedBlock(named, state);\n      let destinationResult = VISIT_EXPRS.visit(destination, state);\n\n      return Result.all(body, destinationResult)\n        .andThen(\n          ([body, destination]): Result<{\n            body: mir.NamedBlock;\n            destination: mir.ExpressionNode;\n            insertBefore: mir.ExpressionNode;\n          }> => {\n            if (insertBefore) {\n              return VISIT_EXPRS.visit(insertBefore, state).mapOk((insertBefore) => ({\n                body,\n                destination,\n                insertBefore,\n              }));\n            } else {\n              return Ok({\n                body,\n                destination,\n                insertBefore: new mir.Missing({\n                  loc: node.callee.loc.collapse('end'),\n                }),\n              });\n            }\n          }\n        )\n        .mapOk(\n          ({ body, destination, insertBefore }) =>\n            new mir.InElement({\n              loc: node.loc,\n              block: body,\n              insertBefore,\n              guid: state.generateUniqueCursor(),\n              destination,\n            })\n        );\n    },\n  })\n  .kw('if', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('unless', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition: new mir.Not({ value: condition, loc: node.loc }),\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('each', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      value: ASTv2.ExpressionNode;\n      key: ASTv2.ExpressionNode | null;\n    }> {\n      let { args } = node;\n\n      if (!args.named.entries.every((e) => e.name.chars === 'key')) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive the 'key' named parameter, received ${args.named.entries\n              .filter((e) => e.name.chars !== 'key')\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive one positional parameter, the collection being iterated. Received ${args.positional.size} parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      let value = args.nth(0);\n      let key = args.get('key');\n\n      if (value === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters`,\n            args.loc\n          )\n        );\n      }\n\n      return Ok({ value, key });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { value, key }: { value: ASTv2.ExpressionNode; key: ASTv2.ExpressionNode | null }\n    ): Result<mir.Each> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let valueResult = VISIT_EXPRS.visit(value, state);\n      let keyResult = key ? VISIT_EXPRS.visit(key, state) : Ok(null);\n\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(valueResult, keyResult, blockResult, inverseResult).mapOk(\n        ([value, key, block, inverse]) =>\n          new mir.Each({\n            loc: node.loc,\n            value,\n            key,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('with', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      value: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#with}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#with}} can only receive one positional parameter. Received ${args.positional.size} parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      let value = args.nth(0);\n\n      if (value === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#with}} requires a value as its first positional parameter, did not receive any parameters`,\n            args.loc\n          )\n        );\n      }\n\n      return Ok({ value });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { value }: { value: ASTv2.ExpressionNode }\n    ): Result<mir.With> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let valueResult = VISIT_EXPRS.visit(value, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(valueResult, blockResult, inverseResult).mapOk(\n        ([value, block, inverse]) =>\n          new mir.With({\n            loc: node.loc,\n            value,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('let', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size === 0) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} requires at least one value as its first positional parameter, did not receive any parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      if (node.blocks.get('else')) {\n        return Err(\n          generateSyntaxError(`{{#let}} cannot receive an {{else}} block`, args.positional.loc)\n        );\n      }\n\n      return Ok({ positional: args.positional });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { positional }: { positional: ASTv2.PositionalArguments }\n    ): Result<mir.Let> {\n      let block = node.blocks.get('default');\n\n      let positionalResult = VISIT_EXPRS.Positional(positional, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(positionalResult, blockResult).mapOk(\n        ([positional, block]) =>\n          new mir.Let({\n            loc: node.loc,\n            positional,\n            block,\n          })\n      );\n    },\n  })\n  .kw('-with-dynamic-vars', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      named: ASTv2.NamedArguments;\n    }> {\n      return Ok({ named: node.args.named });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { named }: { named: ASTv2.NamedArguments }\n    ): Result<mir.WithDynamicVars> {\n      let block = node.blocks.get('default');\n\n      let namedResult = VISIT_EXPRS.NamedArguments(named, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(namedResult, blockResult).mapOk(\n        ([named, block]) =>\n          new mir.WithDynamicVars({\n            loc: node.loc,\n            named,\n            block,\n          })\n      );\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n      let blocksResult = VISIT_STMTS.NamedBlocks(node.blocks, state);\n\n      return Result.all(definitionResult, argsResult, blocksResult).mapOk(\n        ([definition, args, blocks]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks,\n          })\n      );\n    },\n  });\n","import { CurriedTypes } from '@glimmer/vm';\n\nimport { keywords } from './impl';\nimport { curryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const CALL_KEYWORDS = keywords('Call')\n  .kw('has-block', hasBlockKeyword('has-block'))\n  .kw('has-block-params', hasBlockKeyword('has-block-params'))\n  .kw('-get-dynamic-var', getDynamicVarKeyword)\n  .kw('log', logKeyword)\n  .kw('if', ifUnlessInlineKeyword('if'))\n  .kw('unless', ifUnlessInlineKeyword('unless'))\n  .kw('component', curryKeyword(CurriedTypes.Component))\n  .kw('helper', curryKeyword(CurriedTypes.Helper))\n  .kw('modifier', curryKeyword(CurriedTypes.Modifier));\n","import { keywords } from './impl';\n\nexport const MODIFIER_KEYWORDS = keywords('Modifier');\n","import type { Dict, WellKnownAttrName, WellKnownTagName } from '@glimmer/interfaces';\nimport { WellKnownAttrNames, WellKnownTagNames } from '@glimmer/wire-format';\n\n// There is a small whitelist of namespaced attributes specially\n// enumerated in\n// https://www.w3.org/TR/html/syntax.html#attributes-0\n//\n// > When a foreign element has one of the namespaced attributes given by\n// > the local name and namespace of the first and second cells of a row\n// > from the following table, it must be written using the name given by\n// > the third cell from the same row.\n//\n// In all other cases, colons are interpreted as a regular character\n// with no special meaning:\n//\n// > No other namespaced attribute can be expressed in the HTML syntax.\n\nconst XLINK = 'http://www.w3.org/1999/xlink';\nconst XML = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\nconst WHITELIST: Dict<string | undefined> = {\n  'xlink:actuate': XLINK,\n  'xlink:arcrole': XLINK,\n  'xlink:href': XLINK,\n  'xlink:role': XLINK,\n  'xlink:show': XLINK,\n  'xlink:title': XLINK,\n  'xlink:type': XLINK,\n  'xml:base': XML,\n  'xml:lang': XML,\n  'xml:space': XML,\n  xmlns: XMLNS,\n  'xmlns:xlink': XMLNS,\n};\n\nexport function getAttrNamespace(attrName: string): string | undefined {\n  return WHITELIST[attrName];\n}\n\nconst DEFLATE_TAG_TABLE: {\n  [tagName: string]: WellKnownTagName | undefined;\n} = {\n  div: WellKnownTagNames.div,\n  span: WellKnownTagNames.span,\n  p: WellKnownTagNames.p,\n  a: WellKnownTagNames.a,\n};\n\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function deflateTagName(tagName: string): string | WellKnownTagName {\n  return DEFLATE_TAG_TABLE[tagName] ?? tagName;\n}\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nconst DEFLATE_ATTR_TABLE: {\n  [tagName: string]: WellKnownAttrName | undefined;\n} = {\n  class: WellKnownAttrNames.class,\n  id: WellKnownAttrNames.id,\n  value: WellKnownAttrNames.value,\n  name: WellKnownAttrNames.name,\n  type: WellKnownAttrNames.type,\n  style: WellKnownAttrNames.style,\n  href: WellKnownAttrNames.href,\n};\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\n\nexport function deflateAttrName(attrName: string): string | WellKnownAttrName {\n  return DEFLATE_ATTR_TABLE[attrName] ?? attrName;\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n","import { ASTv2, maybeLoc, src } from '@glimmer/syntax';\n\nimport { OptionalList } from '../../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../../shared/result';\nimport { getAttrNamespace } from '../../../../utils';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport { MODIFIER_KEYWORDS } from '../../keywords';\nimport { assertIsValidModifier, isHelperInvocation } from '../../utils/is-node';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\n\nexport type ValidAttr = mir.StaticAttr | mir.DynamicAttr | mir.SplatAttr;\n\ntype ProcessedAttributes = {\n  attrs: ValidAttr[];\n  args: mir.NamedArguments;\n};\n\nexport interface Classified {\n  readonly dynamicFeatures: boolean;\n\n  arg(attr: ASTv2.AttrNode, classified: ClassifiedElement): Result<mir.NamedArgument>;\n  toStatement(classified: ClassifiedElement, prepared: PreparedArgs): Result<mir.Statement>;\n}\n\nexport class ClassifiedElement {\n  readonly delegate: Classified;\n\n  constructor(\n    readonly element: ASTv2.ElementNode,\n    delegate: Classified,\n    readonly state: NormalizationState\n  ) {\n    this.delegate = delegate;\n  }\n\n  toStatement(): Result<mir.Statement> {\n    return this.prepare().andThen((prepared) => this.delegate.toStatement(this, prepared));\n  }\n\n  private attr(attr: ASTv2.HtmlAttr): Result<ValidAttr> {\n    let name = attr.name;\n    let rawValue = attr.value;\n    let namespace = getAttrNamespace(name.chars) || undefined;\n\n    if (ASTv2.isLiteral(rawValue, 'string')) {\n      return Ok(\n        new mir.StaticAttr({\n          loc: attr.loc,\n          name,\n          value: rawValue.toSlice(),\n          namespace,\n          kind: {\n            component: this.delegate.dynamicFeatures,\n          },\n        })\n      );\n    }\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk((value) => {\n      let isTrusting = attr.trusting;\n\n      return new mir.DynamicAttr({\n        loc: attr.loc,\n        name,\n        value: value,\n        namespace,\n        kind: {\n          trusting: isTrusting,\n          component: this.delegate.dynamicFeatures,\n        },\n      });\n    });\n  }\n\n  private modifier(modifier: ASTv2.ElementModifier): Result<mir.Modifier> {\n    if (isHelperInvocation(modifier)) {\n      assertIsValidModifier(modifier);\n    }\n\n    let translated = MODIFIER_KEYWORDS.translate(modifier, this.state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(modifier.callee, this.state);\n    let args = VISIT_EXPRS.Args(modifier.args, this.state);\n\n    return Result.all(head, args).mapOk(\n      ([head, args]) =>\n        new mir.Modifier({\n          loc: modifier.loc,\n          callee: head,\n          args,\n        })\n    );\n  }\n\n  private attrs(): Result<ProcessedAttributes> {\n    let attrs = new ResultArray<ValidAttr>();\n    let args = new ResultArray<mir.NamedArgument>();\n\n    // Unlike most attributes, the `type` attribute can change how\n    // subsequent attributes are interpreted by the browser. To address\n    // this, in simple cases, we special case the `type` attribute to be set\n    // last. For elements with splattributes, where attribute order affects\n    // precedence, this re-ordering happens at runtime instead.\n    // See https://github.com/glimmerjs/glimmer-vm/pull/726\n    let typeAttr: ASTv2.AttrNode | null = null;\n    let simple = this.element.attrs.filter((attr) => attr.type === 'SplatAttr').length === 0;\n\n    for (let attr of this.element.attrs) {\n      if (attr.type === 'SplatAttr') {\n        attrs.add(\n          Ok(new mir.SplatAttr({ loc: attr.loc, symbol: this.state.scope.allocateBlock('attrs') }))\n        );\n      } else if (attr.name.chars === 'type' && simple) {\n        typeAttr = attr;\n      } else {\n        attrs.add(this.attr(attr));\n      }\n    }\n\n    for (let arg of this.element.componentArgs) {\n      args.add(this.delegate.arg(arg, this));\n    }\n\n    if (typeAttr) {\n      attrs.add(this.attr(typeAttr));\n    }\n\n    return Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({\n      attrs,\n      args: new mir.NamedArguments({\n        loc: maybeLoc(args, src.SourceSpan.NON_EXISTENT),\n        entries: OptionalList(args),\n      }),\n    }));\n  }\n\n  private prepare(): Result<PreparedArgs> {\n    let attrs = this.attrs();\n    let modifiers = new ResultArray(this.element.modifiers.map((m) => this.modifier(m))).toArray();\n\n    return Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {\n      let { attrs, args } = result;\n\n      let elementParams = [...attrs, ...modifiers];\n\n      let params = new mir.ElementParameters({\n        loc: maybeLoc(elementParams, src.SourceSpan.NON_EXISTENT),\n        body: OptionalList(elementParams),\n      });\n\n      return { args, params };\n    });\n  }\n}\n\nexport interface PreparedArgs {\n  args: mir.NamedArguments;\n  params: mir.ElementParameters;\n}\n\nexport function hasDynamicFeatures({\n  attrs,\n  modifiers,\n}: Pick<ASTv2.ElementNode, 'attrs' | 'modifiers'>): boolean {\n  // ElementModifier needs the special ComponentOperations\n  if (modifiers.length > 0) {\n    return true;\n  }\n\n  // Splattributes need the special ComponentOperations to merge into\n  return !!attrs.filter((attr) => attr.type === 'SplatAttr')[0];\n}\n","import type { ASTv2 } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport type { NormalizationState } from '../../context';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\nimport { VISIT_STMTS } from '../statements';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nexport class ClassifiedComponent implements Classified {\n  readonly dynamicFeatures = true;\n\n  constructor(private tag: mir.ExpressionNode, private element: ASTv2.InvokeComponent) {}\n\n  arg(attr: ASTv2.ComponentArg, { state }: ClassifiedElement): Result<mir.NamedArgument> {\n    let name = attr.name;\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(attr.value), state).mapOk(\n      (value) =>\n        new mir.NamedArgument({\n          loc: attr.loc,\n          key: name,\n          value,\n        })\n    );\n  }\n\n  toStatement(component: ClassifiedElement, { args, params }: PreparedArgs): Result<mir.Statement> {\n    let { element, state } = component;\n\n    return this.blocks(state).mapOk(\n      (blocks) =>\n        new mir.Component({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          args,\n          blocks,\n        })\n    );\n  }\n\n  private blocks(state: NormalizationState): Result<mir.NamedBlocks> {\n    return VISIT_STMTS.NamedBlocks(this.element.blocks, state);\n  }\n}\n","import { type ASTv2, generateSyntaxError, type SourceSlice } from '@glimmer/syntax';\n\nimport { Err, type Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_STMTS } from '../statements';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nexport class ClassifiedSimpleElement implements Classified {\n  constructor(\n    private tag: SourceSlice,\n    private element: ASTv2.SimpleElement,\n    readonly dynamicFeatures: boolean\n  ) {}\n\n  readonly isComponent = false;\n\n  arg(attr: ASTv2.ComponentArg): Result<mir.NamedArgument> {\n    return Err(\n      generateSyntaxError(\n        `${attr.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\\`${this.tag.chars}\\`) is a regular, non-component HTML element.`,\n        attr.loc\n      )\n    );\n  }\n\n  toStatement(classified: ClassifiedElement, { params }: PreparedArgs): Result<mir.Statement> {\n    let { state, element } = classified;\n\n    let body = VISIT_STMTS.visitList(this.element.body, state);\n\n    return body.mapOk(\n      (body) =>\n        new mir.SimpleElement({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          body: body.toArray(),\n          dynamicFeatures: this.dynamicFeatures,\n        })\n    );\n  }\n}\n","import { ASTv2 } from '@glimmer/syntax';\n\nimport { OptionalList } from '../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport type { NormalizationState } from '../context';\nimport { BLOCK_KEYWORDS } from '../keywords';\nimport { APPEND_KEYWORDS } from '../keywords/append';\nimport { ClassifiedElement, hasDynamicFeatures } from './element/classified';\nimport { ClassifiedComponent } from './element/component';\nimport { ClassifiedSimpleElement } from './element/simple-element';\nimport { VISIT_EXPRS } from './expressions';\n\nclass NormalizationStatements {\n  visitList(\n    nodes: readonly ASTv2.ContentNode[],\n    state: NormalizationState\n  ): Result<OptionalList<mir.Statement>> {\n    return new ResultArray(nodes.map((e) => VISIT_STMTS.visit(e, state)))\n      .toOptionalList()\n      .mapOk((list) => list.filter((s: mir.Statement | null): s is mir.Statement => s !== null));\n  }\n\n  visit(node: ASTv2.ContentNode, state: NormalizationState): Result<mir.Statement | null> {\n    switch (node.type) {\n      case 'GlimmerComment':\n        return Ok(null);\n      case 'AppendContent':\n        return this.AppendContent(node, state);\n      case 'HtmlText':\n        return Ok(this.TextNode(node));\n      case 'HtmlComment':\n        return Ok(this.HtmlComment(node));\n      case 'InvokeBlock':\n        return this.InvokeBlock(node, state);\n      case 'InvokeComponent':\n        return this.Component(node, state);\n      case 'SimpleElement':\n        return this.SimpleElement(node, state);\n    }\n  }\n\n  InvokeBlock(node: ASTv2.InvokeBlock, state: NormalizationState): Result<mir.Statement> {\n    let translated = BLOCK_KEYWORDS.translate(node, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(node.callee, state);\n    let args = VISIT_EXPRS.Args(node.args, state);\n\n    return Result.all(head, args).andThen(([head, args]) =>\n      this.NamedBlocks(node.blocks, state).mapOk(\n        (blocks) =>\n          new mir.InvokeBlock({\n            loc: node.loc,\n            head,\n            args,\n            blocks,\n          })\n      )\n    );\n  }\n\n  NamedBlocks(blocks: ASTv2.NamedBlocks, state: NormalizationState): Result<mir.NamedBlocks> {\n    let list = new ResultArray(blocks.blocks.map((b) => this.NamedBlock(b, state)));\n\n    return list\n      .toArray()\n      .mapOk((list) => new mir.NamedBlocks({ loc: blocks.loc, blocks: OptionalList(list) }));\n  }\n\n  NamedBlock(named: ASTv2.NamedBlock, state: NormalizationState): Result<mir.NamedBlock> {\n    let body = state.visitBlock(named.block);\n\n    return body.mapOk((body) => {\n      return new mir.NamedBlock({\n        loc: named.loc,\n        name: named.name,\n        body: body.toArray(),\n        scope: named.block.scope,\n      });\n    });\n  }\n\n  SimpleElement(element: ASTv2.SimpleElement, state: NormalizationState): Result<mir.Statement> {\n    return new ClassifiedElement(\n      element,\n      new ClassifiedSimpleElement(element.tag, element, hasDynamicFeatures(element)),\n      state\n    ).toStatement();\n  }\n\n  Component(component: ASTv2.InvokeComponent, state: NormalizationState): Result<mir.Statement> {\n    return VISIT_EXPRS.visit(component.callee, state).andThen((callee) =>\n      new ClassifiedElement(\n        component,\n        new ClassifiedComponent(callee, component),\n        state\n      ).toStatement()\n    );\n  }\n\n  AppendContent(append: ASTv2.AppendContent, state: NormalizationState): Result<mir.Statement> {\n    let translated = APPEND_KEYWORDS.translate(append, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let value = VISIT_EXPRS.visit(append.value, state);\n\n    return value.mapOk((value) => {\n      if (append.trusting) {\n        return new mir.AppendTrustedHTML({\n          loc: append.loc,\n          html: value,\n        });\n      } else {\n        return new mir.AppendTextNode({\n          loc: append.loc,\n          text: value,\n        });\n      }\n    });\n  }\n\n  TextNode(text: ASTv2.HtmlText): mir.Statement {\n    return new mir.AppendTextNode({\n      loc: text.loc,\n      text: new ASTv2.LiteralExpression({ loc: text.loc, value: text.chars }),\n    });\n  }\n\n  HtmlComment(comment: ASTv2.HtmlComment): mir.Statement {\n    return new mir.AppendComment({\n      loc: comment.loc,\n      value: comment.text,\n    });\n  }\n}\n\nexport const VISIT_STMTS = new NormalizationStatements();\n","import type { ASTv2, SymbolTable } from '@glimmer/syntax';\n\nimport type { OptionalList } from '../../shared/list';\nimport type { Result } from '../../shared/result';\nimport type * as mir from '../2-encoding/mir';\nimport { VISIT_STMTS } from './visitors/statements';\n\n/**\n * This is the mutable state for this compiler pass.\n */\nexport class NormalizationState {\n  _currentScope: SymbolTable;\n  _cursorCount = 0;\n\n  constructor(block: SymbolTable, readonly isStrict: boolean) {\n    this._currentScope = block;\n  }\n\n  generateUniqueCursor(): string {\n    return `%cursor:${this._cursorCount++}%`;\n  }\n\n  get scope(): SymbolTable {\n    return this._currentScope;\n  }\n\n  visitBlock(block: ASTv2.Block): Result<OptionalList<mir.Statement>> {\n    let oldBlock = this._currentScope;\n    this._currentScope = block.scope;\n\n    try {\n      return VISIT_STMTS.visitList(block.body, this);\n    } finally {\n      this._currentScope = oldBlock;\n    }\n  }\n}\n","import type {\n  CurriedType,\n  Nullable,\n  SerializedInlineBlock,\n  SerializedTemplateBlock,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { dict, exhausted } from '@glimmer/util';\nimport { CurriedTypes } from '@glimmer/vm';\nimport { SexpOpcodes as Op } from '@glimmer/wire-format';\n\nimport { inflateAttrName, inflateTagName } from './utils';\n\nexport default class WireFormatDebugger {\n  private upvars: string[];\n  private symbols: string[];\n\n  constructor([_statements, symbols, _hasEval, upvars]: SerializedTemplateBlock) {\n    this.upvars = upvars;\n    this.symbols = symbols;\n  }\n\n  format(program: SerializedTemplateBlock): unknown {\n    let out = [];\n\n    for (let statement of program[0]) {\n      out.push(this.formatOpcode(statement));\n    }\n\n    return out;\n  }\n\n  formatOpcode(opcode: WireFormat.Syntax): unknown {\n    if (Array.isArray(opcode)) {\n      switch (opcode[0]) {\n        case Op.Append:\n          return ['append', this.formatOpcode(opcode[1])];\n        case Op.TrustingAppend:\n          return ['trusting-append', this.formatOpcode(opcode[1])];\n\n        case Op.Block:\n          return [\n            'block',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.InElement:\n          return [\n            'in-element',\n            opcode[1],\n            this.formatOpcode(opcode[2]),\n            opcode[3] ? this.formatOpcode(opcode[3]) : undefined,\n          ];\n\n        case Op.OpenElement:\n          return ['open-element', inflateTagName(opcode[1])];\n\n        case Op.OpenElementWithSplat:\n          return ['open-element-with-splat', inflateTagName(opcode[1])];\n\n        case Op.CloseElement:\n          return ['close-element'];\n\n        case Op.FlushElement:\n          return ['flush-element'];\n\n        case Op.StaticAttr:\n          return ['static-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.StaticComponentAttr:\n          return ['static-component-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.DynamicAttr:\n          return [\n            'dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.ComponentAttr:\n          return [\n            'component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.AttrSplat:\n          return ['attr-splat'];\n\n        case Op.Yield:\n          return ['yield', opcode[1], this.formatParams(opcode[2])];\n\n        case Op.DynamicArg:\n          return ['dynamic-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.StaticArg:\n          return ['static-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.TrustingDynamicAttr:\n          return [\n            'trusting-dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.TrustingComponentAttr:\n          return [\n            'trusting-component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.Debugger:\n          return ['debugger', opcode[1]];\n\n        case Op.Comment:\n          return ['comment', opcode[1]];\n\n        case Op.Modifier:\n          return [\n            'modifier',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Component:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatElementParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.HasBlock:\n          return ['has-block', this.formatOpcode(opcode[1])];\n\n        case Op.HasBlockParams:\n          return ['has-block-params', this.formatOpcode(opcode[1])];\n\n        case Op.Curry:\n          return [\n            'curry',\n            this.formatOpcode(opcode[1]),\n            this.formatCurryType(opcode[2]),\n            this.formatParams(opcode[3]),\n            this.formatHash(opcode[4]),\n          ];\n\n        case Op.Undefined:\n          return ['undefined'];\n\n        case Op.Call:\n          return [\n            'call',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Concat:\n          return ['concat', this.formatParams(opcode[1] as WireFormat.Core.Params)];\n\n        case Op.GetStrictKeyword:\n          return ['get-strict-free', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsComponentOrHelperHeadOrThisFallback:\n          return [\n            'GetFreeAsComponentOrHelperHeadOrThisFallback',\n            this.upvars[opcode[1]],\n            opcode[2],\n          ];\n\n        case Op.GetFreeAsComponentOrHelperHead:\n          return ['GetFreeAsComponentOrHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsHelperHeadOrThisFallback:\n          return ['GetFreeAsHelperHeadOrThisFallback', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsDeprecatedHelperHeadOrThisFallback:\n          return ['GetFreeAsDeprecatedHelperHeadOrThisFallback', this.upvars[opcode[1]]];\n\n        case Op.GetFreeAsHelperHead:\n          return ['GetFreeAsHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsComponentHead:\n          return ['GetFreeAsComponentHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsModifierHead:\n          return ['GetFreeAsModifierHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetSymbol: {\n          if (opcode[1] === 0) {\n            return ['get-symbol', 'this', opcode[2]];\n          } else {\n            return ['get-symbol', this.symbols[opcode[1] - 1], opcode[2]];\n          }\n        }\n\n        case Op.GetLexicalSymbol: {\n          return ['get-template-symbol', opcode[1], opcode[2]];\n        }\n\n        case Op.If:\n          return [\n            'if',\n            this.formatOpcode(opcode[1]),\n            this.formatBlock(opcode[2]),\n            opcode[3] ? this.formatBlock(opcode[3]) : null,\n          ];\n\n        case Op.IfInline:\n          return ['if-inline'];\n\n        case Op.Not:\n          return ['not'];\n\n        case Op.Each:\n          return [\n            'each',\n            this.formatOpcode(opcode[1]),\n            opcode[2] ? this.formatOpcode(opcode[2]) : null,\n            this.formatBlock(opcode[3]),\n            opcode[4] ? this.formatBlock(opcode[4]) : null,\n          ];\n\n        case Op.With:\n          return [\n            'with',\n            this.formatOpcode(opcode[1]),\n            this.formatBlock(opcode[2]),\n            opcode[3] ? this.formatBlock(opcode[3]) : null,\n          ];\n\n        case Op.Let:\n          return ['let', this.formatParams(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.Log:\n          return ['log', this.formatParams(opcode[1])];\n\n        case Op.WithDynamicVars:\n          return ['-with-dynamic-vars', this.formatHash(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.GetDynamicVar:\n          return ['-get-dynamic-vars', this.formatOpcode(opcode[1])];\n\n        case Op.InvokeComponent:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n      }\n    } else {\n      return opcode;\n    }\n  }\n\n  private formatCurryType(value: CurriedType) {\n    switch (value) {\n      case CurriedTypes.Component:\n        return 'component';\n      case CurriedTypes.Helper:\n        return 'helper';\n      case CurriedTypes.Modifier:\n        return 'modifier';\n      default:\n        throw exhausted(value);\n    }\n  }\n\n  private formatElementParams(opcodes: Nullable<WireFormat.ElementParameter[]>): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatParams(opcodes: Nullable<WireFormat.Expression[]>): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatHash(hash: WireFormat.Core.Hash): Nullable<object> {\n    if (hash === null) return null;\n\n    return hash[0].reduce((accum, key, index) => {\n      accum[key] = this.formatOpcode(hash[1][index]);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlocks(blocks: WireFormat.Core.Blocks): Nullable<object> {\n    if (blocks === null) return null;\n\n    return blocks[0].reduce((accum, key, index) => {\n      accum[key] = this.formatBlock(blocks[1][index] as SerializedInlineBlock);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlock(block: SerializedInlineBlock): object {\n    return {\n      statements: block[0].map((s) => this.formatOpcode(s)),\n      parameters: block[1],\n    };\n  }\n}\n","import type { PresentArray, WireFormat } from '@glimmer/interfaces';\nimport type { ASTv2 } from '@glimmer/syntax';\nimport { assertPresentArray, isPresentArray, mapPresentArray } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type * as mir from './mir';\n\nexport type HashPair = [string, WireFormat.Expression];\n\nexport class ExpressionEncoder {\n  expr(expr: mir.ExpressionNode): WireFormat.Expression {\n    switch (expr.type) {\n      case 'Missing':\n        return undefined;\n      case 'Literal':\n        return this.Literal(expr);\n      case 'CallExpression':\n        return this.CallExpression(expr);\n      case 'DeprecatedCallExpression':\n        return this.DeprecatedCallExpression(expr);\n      case 'PathExpression':\n        return this.PathExpression(expr);\n      case 'Arg':\n        return [SexpOpcodes.GetSymbol, expr.symbol];\n      case 'Local':\n        return this.Local(expr);\n      case 'This':\n        return [SexpOpcodes.GetSymbol, 0];\n      case 'Free':\n        return [expr.resolution.resolution(), expr.symbol];\n      case 'HasBlock':\n        return this.HasBlock(expr);\n      case 'HasBlockParams':\n        return this.HasBlockParams(expr);\n      case 'Curry':\n        return this.Curry(expr);\n      case 'Not':\n        return this.Not(expr);\n      case 'IfInline':\n        return this.IfInline(expr);\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expr);\n      case 'GetDynamicVar':\n        return this.GetDynamicVar(expr);\n      case 'Log':\n        return this.Log(expr);\n    }\n  }\n\n  Literal({\n    value,\n  }: ASTv2.LiteralExpression): WireFormat.Expressions.Value | WireFormat.Expressions.Undefined {\n    if (value === undefined) {\n      return [SexpOpcodes.Undefined];\n    } else {\n      return value;\n    }\n  }\n\n  Missing(): undefined {\n    return undefined;\n  }\n\n  HasBlock({ symbol }: mir.HasBlock): WireFormat.Expressions.HasBlock {\n    return [SexpOpcodes.HasBlock, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  HasBlockParams({ symbol }: mir.HasBlockParams): WireFormat.Expressions.HasBlockParams {\n    return [SexpOpcodes.HasBlockParams, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  Curry({ definition, curriedType, args }: mir.Curry): WireFormat.Expressions.Curry {\n    return [\n      SexpOpcodes.Curry,\n      EXPR.expr(definition),\n      curriedType,\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n    ];\n  }\n\n  Local({\n    isTemplateLocal,\n    symbol,\n  }: ASTv2.LocalVarReference):\n    | WireFormat.Expressions.GetSymbol\n    | WireFormat.Expressions.GetLexicalSymbol {\n    return [isTemplateLocal ? SexpOpcodes.GetLexicalSymbol : SexpOpcodes.GetSymbol, symbol];\n  }\n\n  GetWithResolver({ symbol }: mir.GetWithResolver): WireFormat.Expressions.GetContextualFree {\n    return [SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback, symbol];\n  }\n\n  PathExpression({ head, tail }: mir.PathExpression): WireFormat.Expressions.GetPath {\n    let getOp = EXPR.expr(head) as WireFormat.Expressions.GetVar;\n\n    return [...getOp, EXPR.Tail(tail)];\n  }\n\n  InterpolateExpression({ parts }: mir.InterpolateExpression): WireFormat.Expressions.Concat {\n    return [SexpOpcodes.Concat, parts.map((e) => EXPR.expr(e)).toArray()];\n  }\n\n  CallExpression({ callee, args }: mir.CallExpression): WireFormat.Expressions.Helper {\n    return [SexpOpcodes.Call, EXPR.expr(callee), ...EXPR.Args(args)];\n  }\n\n  DeprecatedCallExpression({\n    arg,\n    callee,\n  }: mir.DeprecatedCallExpression): WireFormat.Expressions.GetPathFreeAsDeprecatedHelperHeadOrThisFallback {\n    return [SexpOpcodes.GetFreeAsDeprecatedHelperHeadOrThisFallback, callee.symbol, [arg.chars]];\n  }\n\n  Tail({ members }: mir.Tail): PresentArray<string> {\n    return mapPresentArray(members, (member) => member.chars);\n  }\n\n  Args({ positional, named }: mir.Args): WireFormat.Core.Args {\n    return [this.Positional(positional), this.NamedArguments(named)];\n  }\n\n  Positional({ list }: mir.Positional): WireFormat.Core.Params {\n    return list.map((l) => EXPR.expr(l)).toPresentArray();\n  }\n\n  NamedArgument({ key, value }: mir.NamedArgument): HashPair {\n    return [key.chars, EXPR.expr(value)];\n  }\n\n  NamedArguments({ entries: pairs }: mir.NamedArguments): WireFormat.Core.Hash {\n    let list = pairs.toArray();\n\n    if (isPresentArray(list)) {\n      let names: string[] = [];\n      let values: WireFormat.Expression[] = [];\n\n      for (let pair of list) {\n        let [name, value] = EXPR.NamedArgument(pair);\n        names.push(name);\n        values.push(value);\n      }\n\n      assertPresentArray(names);\n      assertPresentArray(values);\n\n      return [names, values];\n    } else {\n      return null;\n    }\n  }\n\n  Not({ value }: mir.Not): WireFormat.Expressions.Not {\n    return [SexpOpcodes.Not, EXPR.expr(value)];\n  }\n\n  IfInline({ condition, truthy, falsy }: mir.IfInline): WireFormat.Expressions.IfInline {\n    let expr = [SexpOpcodes.IfInline, EXPR.expr(condition), EXPR.expr(truthy)];\n\n    if (falsy) {\n      expr.push(EXPR.expr(falsy));\n    }\n\n    return expr as WireFormat.Expressions.IfInline;\n  }\n\n  GetDynamicVar({ name }: mir.GetDynamicVar): WireFormat.Expressions.GetDynamicVar {\n    return [SexpOpcodes.GetDynamicVar, EXPR.expr(name)];\n  }\n\n  Log({ positional }: mir.Log): WireFormat.Expressions.Log {\n    return [SexpOpcodes.Log, this.Positional(positional)];\n  }\n}\n\nexport const EXPR = new ExpressionEncoder();\n","import type {\n  AttrOpcode,\n  ComponentAttrOpcode,\n  DynamicAttrOpcode,\n  StaticAttrOpcode,\n  StaticComponentAttrOpcode,\n  TrustingComponentAttrOpcode,\n  TrustingDynamicAttrOpcode,\n  WellKnownAttrName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { exhausted, LOCAL_LOGGER } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { OptionalList } from '../../shared/list';\nimport { deflateAttrName, deflateTagName } from '../../utils';\nimport { EXPR } from './expressions';\nimport type * as mir from './mir';\n\nclass WireStatements<S extends WireFormat.Statement = WireFormat.Statement> {\n  constructor(private statements: readonly S[]) {}\n\n  toArray(): readonly S[] {\n    return this.statements;\n  }\n}\n\nexport class ContentEncoder {\n  list(statements: mir.Statement[]): WireFormat.Statement[] {\n    let out: WireFormat.Statement[] = [];\n\n    for (let statement of statements) {\n      let result = CONTENT.content(statement);\n\n      if (result && result instanceof WireStatements) {\n        out.push(...result.toArray());\n      } else {\n        out.push(result);\n      }\n    }\n\n    return out;\n  }\n\n  content(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    if (LOCAL_SHOULD_LOG) {\n      LOCAL_LOGGER.log(`encoding`, stmt);\n    }\n\n    return this.visitContent(stmt);\n  }\n\n  private visitContent(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    switch (stmt.type) {\n      case 'Debugger':\n        return [SexpOpcodes.Debugger, stmt.scope.getDebugInfo()];\n      case 'AppendComment':\n        return this.AppendComment(stmt);\n      case 'AppendTextNode':\n        return this.AppendTextNode(stmt);\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(stmt);\n      case 'Yield':\n        return this.Yield(stmt);\n      case 'Component':\n        return this.Component(stmt);\n      case 'SimpleElement':\n        return this.SimpleElement(stmt);\n      case 'InElement':\n        return this.InElement(stmt);\n      case 'InvokeBlock':\n        return this.InvokeBlock(stmt);\n      case 'If':\n        return this.If(stmt);\n      case 'Each':\n        return this.Each(stmt);\n      case 'With':\n        return this.With(stmt);\n      case 'Let':\n        return this.Let(stmt);\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(stmt);\n      case 'InvokeComponent':\n        return this.InvokeComponent(stmt);\n      default:\n        return exhausted(stmt);\n    }\n  }\n\n  Yield({ to, positional }: mir.Yield): WireFormat.Statements.Yield {\n    return [SexpOpcodes.Yield, to, EXPR.Positional(positional)];\n  }\n\n  InElement({\n    guid,\n    insertBefore,\n    destination,\n    block,\n  }: mir.InElement): WireFormat.Statements.InElement {\n    let wireBlock = CONTENT.NamedBlock(block)[1];\n    // let guid = args.guid;\n    let wireDestination = EXPR.expr(destination);\n    let wireInsertBefore = EXPR.expr(insertBefore);\n\n    if (wireInsertBefore === undefined) {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination];\n    } else {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination, wireInsertBefore];\n    }\n  }\n\n  InvokeBlock({ head, args, blocks }: mir.InvokeBlock): WireFormat.Statements.Block {\n    return [SexpOpcodes.Block, EXPR.expr(head), ...EXPR.Args(args), CONTENT.NamedBlocks(blocks)];\n  }\n\n  AppendTrustedHTML({ html }: mir.AppendTrustedHTML): WireFormat.Statements.TrustingAppend {\n    return [SexpOpcodes.TrustingAppend, EXPR.expr(html)];\n  }\n\n  AppendTextNode({ text }: mir.AppendTextNode): WireFormat.Statements.Append {\n    return [SexpOpcodes.Append, EXPR.expr(text)];\n  }\n\n  AppendComment({ value }: mir.AppendComment): WireFormat.Statements.Comment {\n    return [SexpOpcodes.Comment, value.chars];\n  }\n\n  SimpleElement({ tag, params, body, dynamicFeatures }: mir.SimpleElement): WireStatements {\n    let op = dynamicFeatures ? SexpOpcodes.OpenElementWithSplat : SexpOpcodes.OpenElement;\n    return new WireStatements<WireFormat.Statement | WireFormat.ElementParameter>([\n      [op, deflateTagName(tag.chars)],\n      ...CONTENT.ElementParameters(params).toArray(),\n      [SexpOpcodes.FlushElement],\n      ...CONTENT.list(body),\n      [SexpOpcodes.CloseElement],\n    ]);\n  }\n\n  Component({ tag, params, args, blocks }: mir.Component): WireFormat.Statements.Component {\n    let wireTag = EXPR.expr(tag);\n    let wirePositional = CONTENT.ElementParameters(params);\n    let wireNamed = EXPR.NamedArguments(args);\n\n    let wireNamedBlocks = CONTENT.NamedBlocks(blocks);\n\n    return [\n      SexpOpcodes.Component,\n      wireTag,\n      wirePositional.toPresentArray(),\n      wireNamed,\n      wireNamedBlocks,\n    ];\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): OptionalList<WireFormat.ElementParameter> {\n    return body.map((p) => CONTENT.ElementParameter(p));\n  }\n\n  ElementParameter(param: mir.ElementParameter): WireFormat.ElementParameter {\n    switch (param.type) {\n      case 'SplatAttr':\n        return [SexpOpcodes.AttrSplat, param.symbol];\n      case 'DynamicAttr':\n        return [dynamicAttrOp(param.kind), ...dynamicAttr(param)];\n      case 'StaticAttr':\n        return [staticAttrOp(param.kind), ...staticAttr(param)];\n      case 'Modifier':\n        return [SexpOpcodes.Modifier, EXPR.expr(param.callee), ...EXPR.Args(param.args)];\n    }\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): WireFormat.Core.Blocks {\n    let names: string[] = [];\n    let serializedBlocks: WireFormat.SerializedInlineBlock[] = [];\n\n    for (let block of blocks.toArray()) {\n      let [name, serializedBlock] = CONTENT.NamedBlock(block);\n\n      names.push(name);\n      serializedBlocks.push(serializedBlock);\n    }\n\n    return names.length > 0 ? [names, serializedBlocks] : null;\n  }\n\n  NamedBlock({ name, body, scope }: mir.NamedBlock): WireFormat.Core.NamedBlock {\n    let nameChars = name.chars;\n    if (nameChars === 'inverse') {\n      nameChars = 'else';\n    }\n    return [nameChars, [CONTENT.list(body), scope.slots]];\n  }\n\n  If({ condition, block, inverse }: mir.If): WireFormat.Statements.If {\n    return [\n      SexpOpcodes.If,\n      EXPR.expr(condition),\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Each({ value, key, block, inverse }: mir.Each): WireFormat.Statements.Each {\n    return [\n      SexpOpcodes.Each,\n      EXPR.expr(value),\n      key ? EXPR.expr(key) : null,\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  With({ value, block, inverse }: mir.With): WireFormat.Statements.With {\n    return [\n      SexpOpcodes.With,\n      EXPR.expr(value),\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Let({ positional, block }: mir.Let): WireFormat.Statements.Let {\n    return [SexpOpcodes.Let, EXPR.Positional(positional), CONTENT.NamedBlock(block)[1]];\n  }\n\n  WithDynamicVars({ named, block }: mir.WithDynamicVars): WireFormat.Statements.WithDynamicVars {\n    return [SexpOpcodes.WithDynamicVars, EXPR.NamedArguments(named), CONTENT.NamedBlock(block)[1]];\n  }\n\n  InvokeComponent({\n    definition,\n    args,\n    blocks,\n  }: mir.InvokeComponent): WireFormat.Statements.InvokeComponent {\n    return [\n      SexpOpcodes.InvokeComponent,\n      EXPR.expr(definition),\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n      blocks ? CONTENT.NamedBlocks(blocks) : null,\n    ];\n  }\n}\n\nexport const CONTENT = new ContentEncoder();\n\nexport type StaticAttrArgs = [name: string | WellKnownAttrName, value: string, namespace?: string];\n\nfunction staticAttr({ name, value, namespace }: mir.StaticAttr): StaticAttrArgs {\n  let out: StaticAttrArgs = [deflateAttrName(name.chars), value.chars];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nexport type DynamicAttrArgs = [\n  name: string | WellKnownAttrName,\n  value: WireFormat.Expression,\n  namespace?: string\n];\n\nfunction dynamicAttr({ name, value, namespace }: mir.DynamicAttr): DynamicAttrArgs {\n  let out: DynamicAttrArgs = [deflateAttrName(name.chars), EXPR.expr(value)];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nfunction staticAttrOp(kind: { component: boolean }): StaticAttrOpcode | StaticComponentAttrOpcode;\nfunction staticAttrOp(kind: { component: boolean }): AttrOpcode {\n  if (kind.component) {\n    return SexpOpcodes.StaticComponentAttr;\n  } else {\n    return SexpOpcodes.StaticAttr;\n  }\n}\n\nfunction dynamicAttrOp(\n  kind: mir.AttrKind\n):\n  | TrustingComponentAttrOpcode\n  | TrustingDynamicAttrOpcode\n  | ComponentAttrOpcode\n  | DynamicAttrOpcode {\n  if (kind.component) {\n    return kind.trusting ? SexpOpcodes.TrustingComponentAttr : SexpOpcodes.ComponentAttr;\n  } else {\n    return kind.trusting ? SexpOpcodes.TrustingDynamicAttr : SexpOpcodes.DynamicAttr;\n  }\n}\n","import type {\n  Nullable,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  TemplateJavascript,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport {\n  normalize,\n  type PrecompileOptions,\n  type PrecompileOptionsWithLexicalScope,\n  src,\n  type TemplateIdFn,\n} from '@glimmer/syntax';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport pass0 from './passes/1-normalization/index';\nimport { visit as pass2 } from './passes/2-encoding/index';\n\ndeclare function require(id: 'crypto'): Crypto;\ndeclare function require(id: string): unknown;\n\ninterface Crypto {\n  createHash(alg: 'sha1'): {\n    update(src: string, encoding: 'utf8'): void;\n    digest(encoding: 'base64'): string;\n  };\n}\n\nexport const defaultId: TemplateIdFn = (() => {\n  const req: typeof require | undefined =\n    typeof module === 'object' && typeof module.require === 'function'\n      ? module.require\n      : globalThis.require;\n\n  if (req) {\n    try {\n      const crypto = req('crypto');\n\n      const idFn: TemplateIdFn = (src) => {\n        const hash = crypto.createHash('sha1');\n        hash.update(src, 'utf8');\n        // trim to 6 bytes of data (2^48 - 1)\n        return hash.digest('base64').substring(0, 8);\n      };\n\n      idFn('test');\n\n      return idFn;\n    } catch {\n      // do nothing\n    }\n  }\n\n  return function idFn() {\n    return null;\n  };\n})();\n\nconst defaultOptions: PrecompileOptions = {\n  id: defaultId,\n};\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompileJSON(\n  string: Nullable<string>,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): [block: SerializedTemplateBlock, usedLocals: string[]] {\n  const source = new src.Source(string ?? '', options.meta?.moduleName);\n  const [ast, locals] = normalize(source, { lexicalScope: () => false, ...options });\n  const block = pass0(source, ast, options.strictMode ?? false).mapOk((pass2In) => {\n    return pass2(pass2In);\n  });\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.log(`Template ->`, block);\n  }\n\n  if (block.isOk) {\n    return [block.value, locals];\n  } else {\n    throw block.reason;\n  }\n}\n\n// UUID used as a unique placeholder for placing a snippet of JS code into\n// the otherwise JSON stringified value below.\nconst SCOPE_PLACEHOLDER = '796d24e6-2450-4fb0-8cdf-b65638b5ef70';\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompile(\n  source: string,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): TemplateJavascript {\n  const [block, usedLocals] = precompileJSON(source, options);\n\n  const moduleName = options.meta?.moduleName;\n  const idFn = options.id || defaultId;\n  const blockJSON = JSON.stringify(block);\n  const templateJSONObject: SerializedTemplateWithLazyBlock = {\n    id: idFn(JSON.stringify(options.meta) + blockJSON),\n    block: blockJSON,\n    moduleName: moduleName ?? '(unknown template module)',\n    // lying to the type checker here because we're going to\n    // replace it just below, after stringification\n    scope: SCOPE_PLACEHOLDER as unknown as null,\n    isStrictMode: options.strictMode ?? false,\n  };\n\n  if (usedLocals.length === 0) {\n    delete templateJSONObject.scope;\n  }\n\n  // JSON is javascript\n  let stringified = JSON.stringify(templateJSONObject);\n\n  if (usedLocals.length > 0) {\n    const scopeFn = `()=>[${usedLocals.join(',')}]`;\n\n    stringified = stringified.replace(`\"${SCOPE_PLACEHOLDER}\"`, scopeFn);\n  }\n\n  return stringified;\n}\n\nexport type { PrecompileOptions };\n","import { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport type { ASTv2, src } from '@glimmer/syntax';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type { Result } from '../../shared/result';\nimport * as mir from '../2-encoding/mir';\nimport { NormalizationState } from './context';\nimport { VISIT_STMTS } from './visitors/statements';\n\n/**\n * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special\n * instructions for keywords like `{{yield}}`, `(has-block)` and\n * `{{#in-element}}`.\n *\n * Most importantly, it also classifies HTML element syntax into:\n *\n * 1. simple HTML element (with optional splattributes)\n * 2. component invocation\n *\n * Because the @glimmer/syntax AST gives us a string for an element's tag,\n * this pass also normalizes that string into an expression.\n *\n * ```\n * // normalized into a path expression whose head is `this` and tail is\n * // `[\"x\"]`\n * <this.x />\n *\n * {{#let expr as |t|}}\n *   // `\"t\"` is normalized into a variable lookup.\n *   <t />\n *\n *   // normalized into a path expression whose head is the variable lookup\n *   // `t` and tail is `[\"input\"]`.\n *   <t.input />\n * {{/let}}\n *\n * // normalized into a free variable lookup for `SomeComponent` (with the\n * // context `ComponentHead`).\n * <SomeComponent />\n *\n * // normalized into a path expression whose head is the free variable\n * // `notInScope` (with the context `Expression`), and whose tail is\n * // `[\"SomeComponent\"]`. In resolver mode, this path will be rejected later,\n * // since it cannot serve as an input to the resolver.\n * <notInScope.SomeComponent />\n * ```\n */\nexport default function normalize(\n  source: src.Source,\n  root: ASTv2.Template,\n  isStrict: boolean\n): Result<mir.Template> {\n  // create a new context for the normalization pass\n  let state = new NormalizationState(root.table, isStrict);\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.groupCollapsed(`pass0: visiting`);\n    LOCAL_LOGGER.log('symbols', root.table);\n    LOCAL_LOGGER.log('source', source);\n    LOCAL_LOGGER.groupEnd();\n  }\n\n  let body = VISIT_STMTS.visitList(root.body, state);\n\n  if (LOCAL_SHOULD_LOG) {\n    if (body.isOk) {\n      LOCAL_LOGGER.log('-> pass0: out', body.value);\n    } else {\n      LOCAL_LOGGER.log('-> pass0: error', body.reason);\n    }\n  }\n\n  return body.mapOk(\n    (body) => new mir.Template({ loc: root.loc, scope: root.table, body: body.toArray() })\n  );\n}\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport WireFormatDebugger from '../../wire-format-debug';\nimport { CONTENT } from './content';\nimport type * as mir from './mir';\n\nexport function visit(template: mir.Template): WireFormat.SerializedTemplateBlock {\n  let statements = CONTENT.list(template.body);\n  let scope = template.scope;\n  let block: WireFormat.SerializedTemplateBlock = [\n    statements,\n    scope.symbols,\n    scope.hasEval,\n    scope.upvars,\n  ];\n\n  if (LOCAL_SHOULD_LOG) {\n    let debug = new WireFormatDebugger(block);\n    LOCAL_LOGGER.log(\n      `-> `,\n      statements.map((s) => debug.formatOpcode(s))\n    );\n  }\n\n  return block;\n}\n"],"names":["HeadKind","VariableKind","normalizeStatement","statement","Array","isArray","name","Builder","Literal","Get","Concat","HasBlock","HasBlockParams","statementIsExpression","normalizeAppendExpression","isSugaryArrayStatement","params","hash","length","normalizeParams","normalizeHash","kind","Call","head","normalizeCallHead","trusted","path","blocks","blockParams","normalizeBuilderBlockStatement","Block","slice","Keyword","attrs","dict","block","normalizeAttrs","normalizeBlock","Element","expect","extractElement","Error","JSON","stringify","normalizeSugaryArrayStatement","value","Append","Modifier","DynamicComponent","expr","normalizeExpression","Comment","normalizeVerboseStatement","normalizeAppendHead","normalizeDottedPath","assertNever","type","ExpressionKind","GetPath","AppendPath","AppendExpr","extractBlockHead","result","exec","normalizePath","tail","arguments","undefined","pathHead","normalizePathHead","isPresentArray","GetVar","variable","whole","rest","split","mode","test","This","Free","Arg","Local","normalizeBlocks","normalizeBlockHash","out","callback","Object","keys","forEach","key","entries","default","mapObject","map","s","a","attr","Splat","normalizeAttr","object","mapper","k","input","match","expression","forceTrusted","isBuilderCallExpression","normalizeCallExpression","ProgramSymbols","_freeVariables","_symbols","top","this","toSymbols","toUpvars","freeVar","addString","symbol","arg","local","hasLocal","_name","child","locals","LocalSymbols","constructor","parent","paramSymbols","values","array","item","index","indexOf","push","unimpl","message","buildStatements","statements","symbols","buildStatement","buildNormalizedStatements","normalized","Op","TrustingAppend","buildGetPath","buildExpression","builtParams","buildParams","builtHash","buildHash","builtExpr","buildCallHead","VariableResolutionContext","AmbiguousInvoke","AmbiguousAppendInvoke","buildBlock","buildBlocks","ResolveAsComponentHead","buildKeyword","_ref","hasSplat","OpenElementWithSplat","OpenElement","args","AttrSplat","buildAttributeValue","extractNamespace","buildElementParams","assert","FlushElement","CloseElement","buildElement","arr","_len","interpolated","_key","reduce","string","i","String","c","_len2","_key2","unicode","charCode","fromCharCode","parseInt","NEWLINE","childSymbols","inverse","With","If","keyExpr","Each","some","NS_XMLNS","NS_XLINK","NS_XML","namespace","val","StaticAttr","DynamicAttr","varContext","context","bare","buildVar","buildConcat","Strict","Undefined","callHead","sym","op","GetSymbol","GetStrictKeyword","GetFreeAsComponentOrHelperHeadOrThisFallback","GetFreeAsComponentOrHelperHead","GetFreeAsHelperHeadOrThisFallback","GetFreeAsHelperHead","AmbiguousAppend","ResolveAsCallHead","ResolveAsModifierHead","GetFreeAsModifierHead","GetFreeAsComponentHead","exhausted","expressionContextOp","getSymbolForVar","exprs","e","LOCAL_SHOULD_LOG","window","location","search","Template","node","fields","InElement","Not","IfInline","Let","WithDynamicVars","GetDynamicVar","Log","InvokeComponent","NamedBlocks","NamedBlock","AppendTrustedHTML","AppendTextNode","AppendComment","Component","SimpleElement","ElementParameters","Yield","Debugger","CallExpression","DeprecatedCallExpression","InvokeBlock","SplatAttr","PathExpression","Missing","InterpolateExpression","Curry","Positional","NamedArguments","NamedArgument","Args","Tail","PresentList","list","toArray","mapPresentArray","filter","predicate","OptionalList","toPresentArray","into","ifPresent","EmptyList","_callback","_predicate","_ref2","ifEmpty","ResultImpl","all","results","isErr","cast","Ok","Result","OkImpl","isOk","super","_message","ifOk","andThen","mapOk","ifErr","mapErr","ErrImpl","reason","Err","ResultArray","items","add","err","toOptionalList","hasPath","callee","assertIsValidModifier","helper","ref","ASTv2","isStrictResolution","resolution","parts","isSimplePath","generateSyntaxError","printPath","loc","printedPath","printPathHead","t","chars","join","unreachable","convertPathToCallIfKeyword","KEYWORDS_TYPES","empty","VISIT_EXPRS","visit","state","Interpolate","translated","CALL_KEYWORDS","translate","DeprecaedCallExpression","visitList","nodes","VariableReference","tailLoc","extend","getLast","mir","members","literal","_state","_ref3","positional","named","_ref4","pairs","KeywordImpl","types","keyword","delegate","Set","nodeType","KEYWORD_NODES","has","getCalleeExpression","serialize","asString","param","Keywords","_keywords","_type","kw","isKeyword","usedType","validTypes","includes","typesToReadableName","generateTypesMessage","keywords","toAppend","text","CurriedTypeToReadableType","CurriedTypes","Helper","assertCurryKeyword","curriedType","readableType","stringsAllowed","definition","nth","isStrict","PositionalArguments","translateCurryKeyword","definitionResult","argsResult","curryKeyword","getDynamicVarKeyword","call","positionals","isEmpty","varName","size","assertHasBlockKeyword","SourceSlice","synthetic","isLiteral","toSlice","translateHasBlockKeyword","target","scope","allocateBlock","hasBlockKeyword","assertIfUnlessInlineKeyword","originalNode","inverted","condition","truthy","falsy","translateIfUnlessInlineKeyword","conditionResult","truthyResult","falsyResult","ifUnlessInlineKeyword","logKeyword","APPEND_KEYWORDS","src","SourceSpan","get","to","setHasDebugger","_ref5","_ref6","_ref7","_ref8","_ref9","BLOCK_KEYWORDS","guid","insertBefore","destination","body","VISIT_STMTS","destinationResult","collapse","generateUniqueCursor","blockResult","inverseResult","_ref10","every","_ref11","_ref12","valueResult","keyResult","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","positionalResult","_ref19","_ref20","_ref21","namedResult","_ref22","_ref23","_ref24","blocksResult","_ref25","MODIFIER_KEYWORDS","XLINK","XML","XMLNS","WHITELIST","xmlns","DEFLATE_TAG_TABLE","div","WellKnownTagNames","span","p","INFLATE_TAG_TABLE","inflateTagName","tagName","DEFLATE_ATTR_TABLE","class","WellKnownAttrNames","id","style","href","INFLATE_ATTR_TABLE","deflateAttrName","attrName","inflateAttrName","ClassifiedElement","element","toStatement","prepare","prepared","rawValue","component","dynamicFeatures","isTrusting","trusting","modifier","isHelperInvocation","typeAttr","simple","componentArgs","maybeLoc","NON_EXISTENT","modifiers","m","elementParams","ClassifiedComponent","tag","ClassifiedSimpleElement","isComponent","classified","AppendContent","TextNode","HtmlComment","b","visitBlock","hasDynamicFeatures","append","html","LiteralExpression","comment","NormalizationState","_currentScope","_cursorCount","oldBlock","WireFormatDebugger","upvars","_statements","_hasEval","format","program","formatOpcode","opcode","formatParams","formatHash","formatBlocks","StaticComponentAttr","ComponentAttr","DynamicArg","StaticArg","TrustingDynamicAttr","TrustingComponentAttr","formatElementParams","formatCurryType","GetFreeAsDeprecatedHelperHeadOrThisFallback","GetLexicalSymbol","formatBlock","opcodes","o","accum","parameters","EXPR","SexpOpcodes","isTemplateLocal","GetWithResolver","member","l","names","pair","assertPresentArray","WireStatements","CONTENT","content","stmt","LOCAL_LOGGER","log","visitContent","getDebugInfo","wireBlock","wireDestination","wireInsertBefore","wireTag","wirePositional","wireNamed","wireNamedBlocks","ElementParameter","dynamicAttrOp","dynamicAttr","staticAttrOp","staticAttr","serializedBlocks","serializedBlock","nameChars","slots","defaultId","req","module","require","globalThis","crypto","idFn","createHash","update","digest","substring","defaultOptions","precompileJSON","options","source","Source","meta","moduleName","ast","normalize","lexicalScope","root","table","groupCollapsed","groupEnd","pass0","strictMode","pass2In","template","hasEval","debug","pass2","SCOPE_PLACEHOLDER","precompile","usedLocals","blockJSON","templateJSONObject","isStrictMode","stringified","scopeFn","replace"],"mappings":"mlBA4BYA,IAAAA,WAAAA,GAAQ,OAARA,EAAQ,MAAA,QAARA,EAAQ,KAAA,OAARA,EAAQ,QAAA,UAARA,EAAQ,WAAA,aAARA,EAAQ,WAAA,aAARA,EAAQ,QAAA,UAARA,EAAQ,SAAA,WAARA,EAAQ,iBAAA,mBAARA,EAAQ,QAAA,UAARA,EAAQ,MAAA,QAARA,EAAQ,QAAA,UAARA,CAAQ,EAAA,CAAA,GAcRC,WAAAA,GAAY,OAAZA,EAAY,MAAA,QAAZA,EAAY,KAAA,OAAZA,EAAY,IAAA,MAAZA,EAAY,MAAA,QAAZA,EAAY,KAAA,OAAZA,CAAY,EAAA,CAAA,GAkFjB,SAASC,EAAmBC,GACjC,GAAIC,MAAMC,QAAQF,GAChB,OA4sBG,SACLA,GAEA,IAAKC,MAAMC,QAAQF,GACjB,OAAO,EAGT,MAAMG,EAAOH,EAAU,GAEvB,GAAoB,iBAATG,EACT,OAAQA,GACN,KAAKC,EAAQC,QACb,KAAKD,EAAQE,IACb,KAAKF,EAAQG,OACb,KAAKH,EAAQI,SACb,KAAKJ,EAAQK,eACX,OAAO,EACT,QACE,OAAO,EAIb,GAAgB,MAAZN,EAAK,GACP,OAAO,EAGT,OAAO,CACT,CAvuBQO,CAAsBV,GACjBW,EAA0BX,GAgCvC,SAAgCA,GAC9B,GAAIC,MAAMC,QAAQF,IAAsC,iBAAjBA,EAAU,GAC/C,OAAQA,EAAU,GAAG,IACnB,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACH,OAAO,EACT,QACE,OAAO,EAIb,OAAO,CACT,CA7CeY,CAAuBZ,GAiD/B,SACLA,GAEA,MAAMG,EAAOH,EAAU,GAEvB,OAAQG,EAAK,IACX,IAAK,IAAK,CACR,IAAIU,EAAqC,KACrCC,EAAiC,KAarC,OAXyB,IAArBd,EAAUe,QACZF,EAASG,EAAgBhB,EAAU,IACnCc,EAAOG,EAAcjB,EAAU,KACD,IAArBA,EAAUe,SACfd,MAAMC,QAAQF,EAAU,IAC1Ba,EAASG,EAAgBhB,EAAU,IAEnCc,EAAOG,EAAcjB,EAAU,KAI5B,CACLkB,KAAMrB,EAASsB,KACfC,KAAMC,EAAkBlB,GACxBU,SACAC,OACAQ,SAAS,EAEb,CAEA,IAAK,IAAK,CACR,MACEF,KAAMG,EAAIV,OACVA,EAAMC,KACNA,EAAIU,OACJA,EAAMC,YACNA,GACEC,EAA+B1B,GAEnC,MAAO,CACLkB,KAAMrB,EAAS8B,MACfP,KAAMG,EACNV,SACAC,OACAU,SACAC,cAEJ,CAEA,IAAK,IAAK,CACR,MAAMtB,EAAOH,EAAU,GAAG4B,MAAM,IAC1Bf,OAAEA,EAAMC,KAAEA,EAAIU,OAAEA,EAAMC,YAAEA,GAAgBC,EAC5C1B,GAGF,MAAO,CACLkB,KAAMrB,EAASgC,QACf1B,OACAU,SACAC,OACAU,SACAC,cAEJ,CAEA,IAAK,IAAK,CACR,IAAIK,EAAyBC,IACzBC,EAAyB,GAa7B,OAXyB,IAArBhC,EAAUe,QACZe,EAAQG,EAAejC,EAAU,IACjCgC,EAAQE,EAAelC,EAAU,KACH,IAArBA,EAAUe,SACfd,MAAMC,QAAQF,EAAU,IAC1BgC,EAAQE,EAAelC,EAAU,IAEjC8B,EAAQG,EAAejC,EAAU,KAI9B,CACLkB,KAAMrB,EAASsC,QACfhC,KAAMiC,EAAOC,EAAelC,GAAQ,iBAAgBA,6BACpD2B,QACAE,QAEJ,CAEA,QACE,MAAM,IAAIM,MAAO,eAAcC,KAAKC,UAAUxC,uCAEpD,CA3IayC,CAA8BzC,GA6I3C,SAAmCA,GACjC,OAAQA,EAAU,IAChB,KAAKI,EAAQC,QACX,MAAO,CACLa,KAAMrB,EAASQ,QACfqC,MAAO1C,EAAU,IAIrB,KAAKI,EAAQuC,OACX,OAAOhC,EAA0BX,EAAU,GAAIA,EAAU,IAG3D,KAAKI,EAAQwC,SACX,MAAO,CACL1B,KAAMrB,EAAS+C,SACf/B,OAAQG,EAAgBhB,EAAU,IAClCc,KAAMG,EAAcjB,EAAU,KAIlC,KAAKI,EAAQyC,iBACX,MAAO,CACL3B,KAAMrB,EAASgD,iBACfC,KAAMC,EAAoB/C,EAAU,IACpCc,KAAMG,EAAcjB,EAAU,IAC9BgC,MAAOE,EAAelC,EAAU,KAIpC,KAAKI,EAAQ4C,QACX,MAAO,CACL9B,KAAMrB,EAASmD,QACfN,MAAO1C,EAAU,IAIzB,CAhLaiD,CAA0BjD,GAE9B,GAAyB,iBAAdA,EAChB,OAAOkD,EAAoBC,EAAoBnD,IAAY,GAE3D,MAAMoD,EAAYpD,EAEtB,CAEO,SAASkD,EACd9B,EACAE,GAEA,OAAIF,EAAKiC,OAASC,EAAeC,QACxB,CACLrC,KAAMrB,EAAS2D,WACfjC,KAAMH,EACNE,WAGK,CACLJ,KAAMrB,EAAS4D,WACfX,KAAM1B,EACNE,UAGN,CAwJA,SAASoC,EAAiBvD,GACxB,MAAMwD,EAAS,eAAeC,KAAKzD,GAEnC,GAAe,OAAXwD,EACF,MAAM,IAAIrB,MAAO,sCAGnB,OAAOa,EAAoBQ,EAAO,GACpC,CAEA,SAAStC,EAAkBlB,GACzB,MAAMwD,EAAS,cAAcC,KAAKzD,GAElC,GAAe,OAAXwD,EACF,MAAM,IAAIrB,MAAO,sCAGnB,OAAOa,EAAoBQ,EAAO,GACpC,CAEA,SAASE,EAAczC,GAAmD,IAArC0C,EAAcC,UAAAhD,OAAA,QAAAiD,IAAAD,UAAA,GAAAA,UAAA,GAAG,GACpD,MAAME,EAAWC,EAAkB9C,GAEnC,OAAI+C,EAAeL,GACV,CACLT,KAAMC,EAAeC,QACrBhC,KAAM,CACJH,KAAM6C,EACNH,SAIG,CACLT,KAAMC,EAAec,OACrBC,SAAUJ,EAGhB,CAEA,SAASd,EAAoBmB,GAC3B,MAAMpD,KAAEA,EAAMf,KAAMoE,GAASL,EAAkBI,IAExCnE,KAAS2D,GAAQS,EAAKC,MAAM,KAE7BH,EAAqB,CAAEnD,OAAMf,OAAMsE,KAAM,SAE/C,OAAIN,EAAeL,GACV,CAAET,KAAMC,EAAeC,QAAShC,KAAM,CAAEH,KAAMiD,EAAUP,SAExD,CAAET,KAAMC,EAAec,OAAQC,WAE1C,CAEO,SAASH,EAAkBI,GAChC,IAAIpD,EACAf,EAEJ,GAAI,iBAAiBuE,KAAKJ,GACxB,MAAO,CACLpD,KAAMpB,EAAa6E,KACnBxE,KAAMmE,EACNG,KAAM,SAIV,OAAQH,EAAM,IACZ,IAAK,IACHpD,EAAOpB,EAAa8E,KACpBzE,EAAOmE,EAAM1C,MAAM,GACnB,MAEF,IAAK,IACHV,EAAOpB,EAAa+E,IACpB1E,EAAOmE,EAAM1C,MAAM,GACnB,MAEF,IAAK,IACHV,EAAOpB,EAAa6B,MACpBxB,EAAOmE,EAAM1C,MAAM,GACnB,MAEF,QACEV,EAAOpB,EAAagF,MACpB3E,EAAOmE,EAGX,MAAO,CAAEpD,OAAMf,OAAMsE,KAAM,QAC7B,CAeO,SAAS/C,EACd1B,GAEA,MAAMoB,EAAOpB,EAAU,GACvB,IAAIwB,EAA2BO,IAC3BlB,EAAqC,KACrCC,EAAiC,KACjCW,EAAkC,KAkBtC,OAhByB,IAArBzB,EAAUe,OACZS,EAASuD,EAAgB/E,EAAU,IACL,IAArBA,EAAUe,QACfd,MAAMC,QAAQF,EAAU,IAC1Ba,EAASG,EAAgBhB,EAAU,MAEhCc,OAAMW,eAAgBuD,EAAmBhF,EAAU,KAGxDwB,EAASuD,EAAgB/E,EAAU,KACL,IAArBA,EAAUe,SACnBF,EAASG,EAAgBhB,EAAU,MAChCc,OAAMW,eAAgBuD,EAAmBhF,EAAU,KACtDwB,EAASuD,EAAgB/E,EAAU,KAG9B,CACLoB,KAAMsC,EAAiBtC,GACvBP,SACAC,OACAW,cACAD,SAEJ,CAEA,SAASwD,EAAmBlE,GAI1B,GAAa,OAATA,EACF,MAAO,CAAEA,KAAM,KAAMW,YAAa,MAGpC,IAAIwD,EAA4C,KAC5CxD,EAAkC,KAWtC,OAGK,SACLM,EACAmD,GAEAC,OAAOC,KAAKrD,GAAMsD,SAASC,IACzB,MAAM5C,EAAQX,EAAKuD,GACnBJ,EAASI,EAAK5C,EAAoB,GAEtC,CApBE6C,CAAQzE,GAAM,CAACwE,EAAK5C,KACN,OAAR4C,EACF7D,EAAcxB,MAAMC,QAAQwC,GAAUA,EAAqB,CAACA,IAE5DuC,EAAMA,GAAOlD,IACbkD,EAAIK,GAAOvC,EAAoBL,GACjC,IAGK,CAAE5B,KAAMmE,EAAKxD,cACtB,CAYA,SAASsD,EAAgBrC,GACvB,OAAIzC,MAAMC,QAAQwC,GACT,CAAE8C,QAAStD,EAAeQ,IAE1B+C,EAAU/C,EAAOR,EAE5B,CAEA,SAASA,EAAeF,GACtB,OAAOA,EAAM0D,KAAKC,GAAM5F,EAAmB4F,IAC7C,CAEA,SAAS1D,EAAeH,GACtB,OAAO2D,EAAU3D,GAAQ8D,GAG3B,SAAuBC,GACrB,GAAa,UAATA,EACF,MAAO,CAAE/C,KAAMjD,EAASiG,MAAOxE,SAAS,GAGxC,MAAO,CAAEwB,KADIC,EAAoB8C,GAClBvE,SAAS,EAE5B,CAViCyE,CAAcH,GAAG9C,MAClD,CAWA,SAAS2C,EACPO,EACAC,GAEA,MAAMhB,EAAMlD,IAMZ,OAJAoD,OAAOC,KAAKY,GAAQX,SAA4Ba,IAC9CjB,EAAIiB,GAAKD,EAAOD,EAAOE,GAAoBA,EAAE,IAGxCjB,CACT,CAsBO,SAAS5C,EAAe8D,GAC7B,MAAMC,EAAQ,gCAAgCxC,KAAKuC,GAEnD,OAAOC,IAAQ,IAAM,IACvB,CAgBYhG,IAAAA,WAAAA,GAAO,OAAPA,EAAAA,EAAO,QAAA,GAAA,UAAPA,EAAAA,EAAO,QAAA,GAAA,UAAPA,EAAAA,EAAO,OAAA,GAAA,SAAPA,EAAAA,EAAO,SAAA,GAAA,WAAPA,EAAAA,EAAO,iBAAA,GAAA,mBAAPA,EAAAA,EAAO,IAAA,GAAA,MAAPA,EAAAA,EAAO,OAAA,GAAA,SAAPA,EAAAA,EAAO,SAAA,GAAA,WAAPA,EAAAA,EAAO,eAAA,GAAA,iBAAPA,CAAO,EAAA,IAwCPkD,WAAAA,GAAc,OAAdA,EAAc,QAAA,UAAdA,EAAc,KAAA,OAAdA,EAAc,QAAA,UAAdA,EAAc,OAAA,SAAdA,EAAc,OAAA,SAAdA,EAAc,SAAA,WAAdA,EAAc,eAAA,iBAAdA,CAAc,EAAA,CAAA,GAoDnB,SAAS3C,EACd0F,GAEyB,IADzBC,EAAYvC,UAAAhD,OAAA,QAAAiD,IAAAD,UAAA,IAAAA,UAAA,GAEZ,GAAIsC,QACF,MAAO,CACLvD,KAAM,CACJO,KAAMC,EAAejD,QACrBqC,MAAO2D,GAETnF,KAAMrB,EAAS4D,WACfnC,SAAS,GAEN,GAAIrB,MAAMC,QAAQmG,GACvB,OAAQA,EAAW,IACjB,KAAKjG,EAAQC,QACX,MAAO,CACLyC,KAAM,CAAEO,KAAMC,EAAejD,QAASqC,MAAO2D,EAAW,IACxDnF,KAAMrB,EAAS4D,WACfnC,SAAS,GAGb,KAAKlB,EAAQE,IACX,OAAO4C,EAAoBW,EAAcwC,EAAW,GAAIA,EAAW,IAAKC,GAE1E,KAAKlG,EAAQG,OASX,MAAO,CACLuC,KAT6B,CAC7BO,KAAMC,EAAe/C,OACrBM,OAAQG,EAAgBqF,EAAWzE,MAAM,KAQzCV,KAAMrB,EAAS4D,WACfnC,QAASgF,GAIb,KAAKlG,EAAQI,SACX,MAAO,CACLsC,KAAM,CACJO,KAAMC,EAAe9C,SACrBL,KAAMkG,EAAW,IAEnBnF,KAAMrB,EAAS4D,WACfnC,QAASgF,GAGb,KAAKlG,EAAQK,eACX,MAAO,CACLqC,KAAM,CACJO,KAAMC,EAAe7C,eACrBN,KAAMkG,EAAW,IAEnBnF,KAAMrB,EAAS4D,WACfnC,QAASgF,GAGb,QACE,GAAIC,EAAwBF,GAC1B,MAAO,CACLvD,KAAM0D,EAAwBH,GAC9BnF,KAAMrB,EAAS4D,WACfnC,QAASgF,GAGX,MAAM,IAAIhE,MACP,0EACC+D,EAAW,oDACqC9D,KAAKC,UAAU6D,UAMpE,IAA0B,iBAAfA,EAiBhB,MAAMjD,EAAYiD,GAhBlB,cAAeA,GACb,IAAK,SACH,OAAOnD,EAAoBC,EAAoBkD,GAAaC,GAE9D,IAAK,UACL,IAAK,SACH,MAAO,CACLxD,KAAM,CAAEO,KAAMC,EAAejD,QAASqC,MAAO2D,GAC7CnF,KAAMrB,EAAS4D,WACfnC,SAAS,GAGb,QACE,MAAM8B,EAAYiD,GAIxB,CACF,CAEO,SAAStD,EAAoBsD,GAClC,GAAIA,QACF,MAAO,CACLhD,KAAMC,EAAejD,QACrBqC,MAAO2D,GAEJ,GAAIpG,MAAMC,QAAQmG,GACvB,OAAQA,EAAW,IACjB,KAAKjG,EAAQC,QACX,MAAO,CAAEgD,KAAMC,EAAejD,QAASqC,MAAO2D,EAAW,IAE3D,KAAKjG,EAAQE,IACX,OAAOuD,EAAcwC,EAAW,GAAIA,EAAW,IAEjD,KAAKjG,EAAQG,OASX,MAR+B,CAC7B8C,KAAMC,EAAe/C,OACrBM,OAAQG,EAAgBqF,EAAWzE,MAAM,KAS7C,KAAKxB,EAAQI,SACX,MAAO,CACL6C,KAAMC,EAAe9C,SACrBL,KAAMkG,EAAW,IAGrB,KAAKjG,EAAQK,eACX,MAAO,CACL4C,KAAMC,EAAe7C,eACrBN,KAAMkG,EAAW,IAGrB,QACE,GAAIE,EAAwBF,GAC1B,OAAOG,EAAwBH,GAE/B,MAAM,IAAI/D,MACP,0EACC+D,EAAW,oDACqC9D,KAAKC,UAAU6D,UAMpE,IAA0B,iBAAfA,EAahB,MAAMjD,EAAYiD,GAZlB,cAAeA,GACb,IAAK,SACH,OAAOlD,EAAoBkD,GAE7B,IAAK,UACL,IAAK,SACH,MAAO,CAAEhD,KAAMC,EAAejD,QAASqC,MAAO2D,GAEhD,QACE,MAAMjD,EAAYiD,GAIxB,CACF,CA0DO,SAASE,EACd7D,GAEA,MAA2B,iBAAbA,EAAM,IAAmC,MAAhBA,EAAM,GAAG,EAClD,CAQO,SAAS1B,EAAgBmF,GAC9B,OAAOA,EAAMT,IAAI3C,EACnB,CAEO,SAAS9B,EAAckF,GAC5B,OAAc,OAAVA,EAAuB,KACpBV,EAAUU,EAAOpD,EAC1B,CAEO,SAASyD,EAAwB1D,GACtC,OAAQA,EAAK/B,QACX,KAAK,EACH,MAAO,CACLsC,KAAMC,EAAenC,KACrBC,KAAMC,EAAkByB,EAAK,IAC7BjC,OAAQ,KACRC,KAAM,MAEV,KAAK,EACH,OAAIb,MAAMC,QAAQ4C,EAAK,IACd,CACLO,KAAMC,EAAenC,KACrBC,KAAMC,EAAkByB,EAAK,IAC7BjC,OAAQG,EAAgB8B,EAAK,IAC7BhC,KAAM,MAGD,CACLuC,KAAMC,EAAenC,KACrBC,KAAMC,EAAkByB,EAAK,IAC7BjC,OAAQ,KACRC,KAAMG,EAAc6B,EAAK,KAK/B,KAAK,EACH,MAAO,CACLO,KAAMC,EAAenC,KACrBC,KAAMC,EAAkByB,EAAK,IAC7BjC,OAAQG,EAAgB8B,EAAK,IAC7BhC,KAAMG,EAAc6B,EAAK,KAGjC,CCp2BO,MAAM2D,EACXC,eAA2B,GAC3BC,SAAqB,CAAC,QAEtBC,IAAMC,KAENC,SAAAA,GACE,OAAOD,KAAKF,SAAS/E,MAAM,EAC7B,CAEAmF,QAAAA,GACE,OAAOF,KAAKH,cACd,CAEAM,OAAAA,CAAQ7G,GACN,OAAO8G,GAAUJ,KAAKH,eAAgBvG,EACxC,CAEA6B,KAAAA,CAAM7B,GACJ,OAAO0G,KAAKK,OAAO/G,EACrB,CAEAgH,GAAAA,CAAIhH,GACF,OAAO8G,GAAUJ,KAAKF,SAAUxG,EAClC,CAEAiH,KAAAA,CAAMjH,GACJ,MAAM,IAAImC,MACP,YAAWnC,iCAAoCA,oBAAuBA,iBAE3E,CAEA0G,IAAAA,GACE,OAAO,CACT,CAEAQ,QAAAA,CAASC,GACP,OAAO,CACT,CAGAJ,MAAAA,CAAO/G,GACL,OAAO8G,GAAUJ,KAAKF,SAAUxG,EAClC,CAEAoH,KAAAA,CAAMC,GACJ,OAAO,IAAIC,GAAaZ,KAAMW,EAChC,EAGF,MAAMC,GACID,OAAuBzF,IAE/B2F,WAAAA,CAAoBC,EAAiBH,GAAkBX,KAAnCc,OAAAA,EAClB,IAAK,IAAIP,KAASI,EAChBX,KAAKW,OAAOJ,GAASO,EAAOf,IAAIM,OAAOE,EAE3C,CAEA,gBAAIQ,GACF,OAAOC,EAAOhB,KAAKW,OACrB,CAEA,OAAIZ,GACF,OAAOC,KAAKc,OAAOf,GACrB,CAEAI,OAAAA,CAAQ7G,GACN,OAAO0G,KAAKc,OAAOX,QAAQ7G,EAC7B,CAEAgH,GAAAA,CAAIhH,GACF,OAAO0G,KAAKc,OAAOR,IAAIhH,EACzB,CAEA6B,KAAAA,CAAM7B,GACJ,OAAO0G,KAAKc,OAAO3F,MAAM7B,EAC3B,CAEAiH,KAAAA,CAAMjH,GACJ,OAAIA,KAAQ0G,KAAKW,OACRX,KAAKW,OAAOrH,GAEZ0G,KAAKc,OAAOP,MAAMjH,EAE7B,CAEA0G,IAAAA,GACE,OAAOA,KAAKc,OAAOd,MACrB,CAEAQ,QAAAA,CAASlH,GACP,OAAIA,KAAQ0G,KAAKW,QAGRX,KAAKc,OAAON,SAASlH,EAEhC,CAEAoH,KAAAA,CAAMC,GACJ,OAAO,IAAIC,GAAaZ,KAAMW,EAChC,EAGF,SAASP,GAAUa,EAAiBC,GAClC,IAAIC,EAAQF,EAAMG,QAAQF,GAE1B,OAAe,IAAXC,GACFA,EAAQF,EAAM/G,OACd+G,EAAMI,KAAKH,GACJC,GAEAA,CAEX,CAQA,SAASG,GAAOC,GACd,OAAO,IAAI9F,MAAO,iBAAgB8F,IACpC,CAEO,SAASC,GACdC,EACAC,GAEA,IAAItD,EAA8B,GAIlC,OAFAqD,EAAWjD,SAASM,GAAMV,EAAIiD,QAAQM,GAAezI,EAAmB4F,GAAI4C,MAErEtD,CACT,CAEO,SAASwD,GACdH,EACAC,GAEA,IAAItD,EAA8B,GAIlC,OAFAqD,EAAWjD,SAASM,GAAMV,EAAIiD,QAAQM,GAAe7C,EAAG4C,MAEjDtD,CACT,CAEO,SAASuD,GACdE,GAEwB,IADxBH,EAAgBxE,UAAAhD,OAAAgD,QAAAC,IAAAD,UAAAC,GAAAD,UAAA,GAAG,IAAI0C,EAEvB,OAAQiC,EAAWxH,MACjB,KAAKrB,EAAS2D,WACZ,MAAO,CACL,CACEkF,EAAWpH,QAAUqH,EAAGC,eAAiBD,EAAGhG,OAC5CkG,GAAaH,EAAWnH,KAAMgH,KAKpC,KAAK1I,EAAS4D,WACZ,MAAO,CACL,CACEiF,EAAWpH,QAAUqH,EAAGC,eAAiBD,EAAGhG,OAC5CmG,GACEJ,EAAW5F,KACX4F,EAAWpH,QAAU,gBAAkB,SACvCiH,KAMR,KAAK1I,EAASsB,KAAM,CAClB,IAAMC,KAAMG,EAAIV,OAAEA,EAAMC,KAAEA,EAAIQ,QAAEA,GAAYoH,EACxCK,EAAgDlI,EAChDmI,GAAYnI,EAAQ0H,GACpB,KACAU,EAAkCnI,EAAOoI,GAAUpI,EAAMyH,GAAW,KACpEY,EAAmCC,GACrC7H,EACAD,EACI+H,EAA0BC,gBAC1BD,EAA0BE,sBAC9BhB,GAGF,MAAO,CACL,CAACjH,EAAUqH,EAAGC,eAAiBD,EAAGhG,OAAQ,CAACgG,EAAGxH,KAAMgI,EAAWJ,EAAaE,IAEhF,CAEA,KAAKpJ,EAASQ,QACZ,MAAO,CAAC,CAACsI,EAAGhG,OAAQ+F,EAAWhG,QAGjC,KAAK7C,EAASmD,QACZ,MAAO,CAAC,CAAC2F,EAAG3F,QAAS0F,EAAWhG,QAGlC,KAAK7C,EAAS8B,MAAO,CACnB,IAAIH,EAwdH,SACLA,EACAC,EACAkG,GAEA,IAAIvC,EAAiB,GACjByC,EAA6C,GAEjD,IAAK,MAAO1H,EAAM6B,KAAUmD,OAAOI,QAAQ/D,GAGzC,GAFA4D,EAAK8C,KAAK/H,GAEG,YAATA,EAAoB,CACtB,IAAIoI,EAAUZ,EAAOJ,MAAM9F,GAAe,IAE1CoG,EAAOK,KAAKsB,GAAWxH,EAAOuG,EAASA,EAAQX,cACjD,MACEC,EAAOK,KAAKsB,GAAWxH,EAAO2F,EAAQ,KAI1C,MAAO,CAACvC,EAAMyC,EAChB,CA7emB4B,CAAYf,EAAWlH,OAAQkH,EAAWjH,YAAa8G,GAChEzH,EAAOoI,GAAUR,EAAW5H,KAAMyH,GAClC1H,EAASmI,GAAYN,EAAW7H,OAAQ0H,GACxChH,EAAO6H,GACTV,EAAWtH,KACXiI,EAA0BK,uBAC1BnB,GAGF,MAAO,CAAC,CAACI,EAAGhH,MAAOJ,EAAMV,EAAQC,EAAMU,GACzC,CAEA,KAAK3B,EAASgC,QACZ,MAAO,CAAC8H,GAAajB,EAAYH,IAGnC,KAAK1I,EAASsC,QACZ,OAyEN,SAAqByH,EAEnBrB,GACwB,IAFxBpI,KAAEA,EAAI2B,MAAEA,EAAKE,MAAEA,GAA0B4H,EAGrC3E,EAA8B,CAChC4E,GAAS/H,GAAS,CAAC6G,EAAGmB,qBAAsB3J,GAAQ,CAACwI,EAAGoB,YAAa5J,IAEvE,GAAI2B,EAAO,CACT,IAAIjB,OAAEA,EAAMmJ,KAAEA,GAkDX,SACLlI,EACAyG,GAEA,IAAI1H,EAAwC,GACxCuE,EAAiB,GACjByC,EAAkC,GAEtC,IAAK,MAAOvC,EAAK5C,KAAUyC,OAAOI,QAAQzD,GACpCY,IAAU7C,EAASiG,MACrBjF,EAAOqH,KAAK,CAACS,EAAGsB,UAAW1B,EAAQvG,MAAM,YACrB,MAAXsD,EAAI,IACbF,EAAK8C,KAAK5C,GACVuC,EAAOK,KAAKY,GAAgBpG,EAAO,SAAU6F,KAE7C1H,EAAOqH,QACFgC,GACD5E,EACA5C,EAEAyH,GAAiB7E,GACjBiD,IAMR,MAAO,CAAE1H,SAAQmJ,KAAM7F,EAAeiB,IAASjB,EAAe0D,GAAU,CAACzC,EAAMyC,GAAU,KAC3F,CA9E2BuC,CAAmBtI,EAAOyG,GACjDtD,EAAIiD,QAAQrH,GACZwJ,EAAgB,OAATL,EAAgB,sCACzB,CAGA,GAFA/E,EAAIiD,KAAK,CAACS,EAAG2B,eAETrK,MAAMC,QAAQ8B,GAChBA,EAAMqD,SAASM,GAAMV,EAAIiD,QAAQM,GAAe7C,EAAG4C,WAC9C,GAAc,OAAVvG,EAGT,MAAMoB,EAAYpB,GAKpB,OAFAiD,EAAIiD,KAAK,CAACS,EAAG4B,eAENtF,CACT,CAlGauF,CAAa9B,EAAYH,GAElC,KAAK1I,EAAS+C,SACZ,MAAMuF,GAAO,YAEf,KAAKtI,EAASgD,iBACZ,MAAMsF,GAAO,qBAEf,QACE,MAAM/E,EAAYsF,GAExB,CAEO,SAAS/C,GACd8E,GAE2B,IAAAC,IAAAA,EAAA3G,UAAAhD,OADxB4J,MAAY1K,MAAAyK,EAAAA,EAAAA,OAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAZD,EAAYC,EAAA7G,GAAAA,UAAA6G,GAEf,IAAIjH,EAAS8G,EAAII,QACf,CAAClH,EAAQmH,EAAQC,IAAMpH,EAAU,GAAEmH,IAASH,EAAaI,GAAKC,OAAOL,EAAaI,IAAM,MACxF,IAGF,MAAO,CAAC3K,EAAQC,QAASsD,EAC3B,CAEO,SAASsH,GAAER,GAAuE,IAAAS,IAAAA,EAAAnH,UAAAhD,OAAzC4J,MAAY1K,MAAAiL,EAAAA,EAAAA,OAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAZR,EAAYQ,EAAApH,GAAAA,UAAAoH,GAC1D,IAAIxH,EAAS8G,EAAII,QACf,CAAClH,EAAQmH,EAAQC,IAAMpH,EAAU,GAAEmH,IAASH,EAAaI,GAAKC,OAAOL,EAAaI,IAAM,MACxF,IAGF,MAAO,CAAC3K,EAAQ4C,QAASW,EAC3B,CAEO,SAASyH,GAAQC,GACtB,OAAOL,OAAOM,aAAaC,SAASF,EAAU,IAChD,CAEO,MAAMG,GAAU,KAEvB,SAAS7B,GACPjB,EACAH,GAEA,IAAIpI,KAAEA,GAASuI,EACX7H,EAASmI,GAAYN,EAAW7H,OAAQ0H,GACxCkD,EAAelD,EAAQhB,MAAMmB,EAAWjH,aAAe,IAEvDO,EAAQwH,GACVd,EAAWlH,OAAgB,QAC3BiK,EACAA,EAAa7D,cAEX8D,EAAUhD,EAAWlH,OAAa,KAClCgI,GAAWd,EAAWlH,OAAa,KAAG+G,EAAS,IAC/C,KAEJ,OAAQpI,GACN,IAAK,OACH,MAAO,CAACwI,EAAGgD,KAAMvJ,EAAOvB,EAAQ,wBAAwB,GAAImB,EAAO0J,GACrE,IAAK,KACH,MAAO,CAAC/C,EAAGiD,GAAIxJ,EAAOvB,EAAQ,sBAAsB,GAAImB,EAAO0J,GACjE,IAAK,OAAQ,CACX,IAAIG,EAAUnD,EAAW5H,KAAO4H,EAAW5H,KAAU,IAAI,KACrDwE,EAAMuG,EAAU/C,GAAgB+C,EAAS,SAAUtD,GAAW,KAClE,MAAO,CAACI,EAAGmD,KAAM1J,EAAOvB,EAAQ,sBAAsB,GAAIyE,EAAKtD,EAAO0J,EACxE,CAEA,QACE,MAAM,IAAIpJ,MAAM,yBAEtB,CA6BA,SAASuH,GAAS/H,GAChB,OAAc,OAAVA,GAEGqD,OAAOC,KAAKtD,GAAOiK,MAAMnG,GAAM9D,EAAM8D,KAAO/F,EAASiG,OAC9D,CAyDO,SAASqE,GAAiBhK,GAC/B,GAAa,UAATA,EACF,OAAO6L,EAGT,IAAI5F,EAAQ,qBAAqBxC,KAAKzD,GAEtC,GAAc,OAAViG,EACF,OAAO,KAKT,OAFgBA,EAAM,IAGpB,IAAK,QACH,OAAO6F,EACT,IAAK,MACH,OAAOC,EACT,IAAK,QACH,OAAOF,EAGX,OAAO,IACT,CAEO,SAAS9B,GACd/J,EACAuC,EACAyJ,EACA5D,GAEA,GAAQ7F,EAAMW,OACPC,EAAejD,QAAS,CAC3B,IAAI+L,EAAM1J,EAAMA,MAEhB,IAAY,IAAR0J,EACF,MAAO,GACF,IAAY,IAARA,EACT,MAAO,CAAC,CAACzD,EAAG0D,WAAYlM,EAAM,GAAIgM,QAAanI,IAC1C,GAAmB,iBAARoI,EAChB,MAAO,CAAC,CAACzD,EAAG0D,WAAYlM,EAAMiM,EAAKD,QAAanI,IAEhD,MAAM,IAAI1B,MAAO,8CAA6CC,KAAKC,UAAU4J,KAEjF,CAGE,MAAO,CACL,CACEzD,EAAG2D,YACHnM,EACA2I,GAAgBpG,EAAO,YAAa6F,GACpC4D,QAAanI,GAIvB,CAUA,SAASuI,GAAWC,EAAyBC,GAC3C,OAAQD,GACN,IAAK,SACH,OAAOC,EAAO,aAAe,eAC/B,IAAK,gBACH,OAAOA,EAAO,oBAAsB,sBACtC,IAAK,YACH,OAAOA,EAAO,gBAAkB,kBAClC,QACE,OAAOD,EAEb,CAEO,SAAS1D,GACdhG,EACA0J,EACAjE,GAEA,OAAQzF,EAAKO,MACX,KAAKC,EAAeC,QAClB,OAAOsF,GAAa/F,EAAMyF,GAG5B,KAAKjF,EAAec,OAClB,OAAOsI,GAAS5J,EAAKuB,SAAUkI,GAAWC,GAAS,GAAOjE,GAG5D,KAAKjF,EAAe/C,OAClB,MAAO,CAACoI,EAAGpI,OAAQoM,GAAY7J,EAAKjC,OAAQ0H,IAG9C,KAAKjF,EAAenC,KAAM,CACxB,IAAI4H,EAAcC,GAAYlG,EAAKjC,OAAQ0H,GACvCU,EAAYC,GAAUpG,EAAKhC,KAAMyH,GACjCY,EAAYC,GACdtG,EAAK1B,KACO,WAAZoL,EAAuB,gBAAkBD,GAAWC,GAAS,GAC7DjE,GAGF,MAAO,CAACI,EAAGxH,KAAMgI,EAAWJ,EAAaE,EAC3C,CAEA,KAAK3F,EAAe9C,SAClB,MAAO,CACLmI,EAAGnI,SACHkM,GACE,CAAExL,KAAMpB,EAAa6B,MAAOxB,KAAM2C,EAAK3C,KAAMsE,KAAM,SACnD4E,EAA0BuD,OAC1BrE,IAKN,KAAKjF,EAAe7C,eAClB,MAAO,CACLkI,EAAGlI,eACHiM,GACE,CAAExL,KAAMpB,EAAa6B,MAAOxB,KAAM2C,EAAK3C,KAAMsE,KAAM,SACnD4E,EAA0BuD,OAC1BrE,IAKN,KAAKjF,EAAejD,QAClB,YAAmB2D,IAAflB,EAAKJ,MACA,CAACiG,EAAGkE,WAEJ/J,EAAKJ,MAIhB,QACEU,EAAYN,GAElB,CAEO,SAASsG,GACd0D,EACAN,EACAjE,GAEA,OAAIuE,EAASzJ,OAASC,EAAec,OAC5BsI,GAASI,EAASzI,SAAUmI,EAASjE,GAErCM,GAAaiE,EAAUvE,EAElC,CAEO,SAASM,GAAazH,EAAsBmH,GACjD,OAAOmE,GAAStL,EAAKG,KAAKH,KAAMiI,EAA0BuD,OAAQrE,EAASnH,EAAKG,KAAKuC,KACvF,CAwBO,SAAS4I,GACdtL,EACAoL,EACAjE,EACAhH,GAEA,IACIwL,EADAC,EAA4BrE,EAAGsE,UAEnC,GAAQ7L,EAAKF,OACNpB,EAAa8E,KAEdoI,EADc,WAAZR,EACG7D,EAAGuE,iBACa,eAAZV,EACJ7D,EAAGwE,6CACa,iBAAZX,EACJ7D,EAAGyE,+BACa,sBAAZZ,EACJ7D,EAAG0E,kCACa,wBAAZb,EACJ7D,EAAG2E,oBACa,kBAAZd,EACJ7D,EAAG0E,kCACa,oBAAZb,GAEY,kBAAZA,EADJ7D,EAAG2E,oBAuCT,SAA6Bd,GAClC,OAAQA,GACN,KAAKnD,EAA0BuD,OAC7B,OAAOjE,EAAGuE,iBACZ,KAAK7D,EAA0BkE,gBAC7B,OAAO5E,EAAGwE,6CACZ,KAAK9D,EAA0BE,sBAC7B,OAAOZ,EAAGyE,+BACZ,KAAK/D,EAA0BC,gBAC7B,OAAOX,EAAG0E,kCACZ,KAAKhE,EAA0BmE,kBAC7B,OAAO7E,EAAG2E,oBACZ,KAAKjE,EAA0BoE,sBAC7B,OAAO9E,EAAG+E,sBACZ,KAAKrE,EAA0BK,uBAC7B,OAAOf,EAAGgF,uBACZ,QACE,OAAOC,EAAUpB,GAEvB,CAtDaqB,CAAoBrB,GAE3BO,EAAMxE,EAAQvB,QAAQ5F,EAAKjB,WAG3B6M,EAAKrE,EAAGsE,UACRF,EAUN,SACE7L,EACAqH,EACApI,GAEA,OAAQe,GACN,KAAKpB,EAAa+E,IAChB,OAAO0D,EAAQpB,IAAIhH,GACrB,KAAKL,EAAa6B,MAChB,OAAO4G,EAAQvG,MAAM7B,GACvB,KAAKL,EAAagF,MAChB,OAAOyD,EAAQnB,MAAMjH,GACvB,KAAKL,EAAa6E,KAChB,OAAO4D,EAAQ1B,OACjB,QACE,OAAO+G,EAAU1M,GAEvB,CA3BY4M,CAAgB1M,EAAKF,KAAMqH,EAASnH,EAAKjB,MAGnD,YAAa6D,IAATzC,GAAsC,IAAhBA,EAAKR,OACtB,CAACiM,EAAID,GAEL,CAACC,EAAID,EAAKxL,EAErB,CA0CO,SAASyH,GACd+E,EACAxF,GAEA,OAAc,OAAVwF,GAAmB5J,EAAe4J,GAE/BA,EAAMrI,KAAKsI,GAAMlF,GAAgBkF,EAAG,SAAUzF,KAFA,IAGvD,CAEO,SAASoE,GACdoB,EACAxF,GAEA,OAAOwF,EAAMrI,KAAKsI,GAAMlF,GAAgBkF,EAAG,YAAazF,IAC1D,CAEO,SAASW,GAAU6E,EAAiCxF,GACzD,GAAc,OAAVwF,EAAgB,OAAO,KAE3B,IAAI9I,EAA2C,CAAC,GAAI,IAEpD,IAAK,MAAOK,EAAK5C,KAAUyC,OAAOI,QAAQwI,GACxC9I,EAAI,GAAGiD,KAAK5C,GACZL,EAAI,GAAGiD,KAAKY,GAAgBpG,EAAO,SAAU6F,IAG/C,OAAOtD,CACT,CAyBA,SAASuE,GACPxH,EACAuG,GAEkC,IADlCf,EAAgBzD,UAAAhD,OAAA,QAAAiD,IAAAD,UAAA,GAAAA,UAAA,GAAG,GAEnB,MAAO,CAAC0E,GAA0BzG,EAAOuG,GAAUf,EACrD,CC7uBO,MAAMyG,KAKwB,oBAAXC,SAA0BA,OAAOC,WACvC,+BAA+BzJ,KAAKwJ,OAAOC,SAASC,SCRjE,MAAMC,WAAiBC,EAAK,YAAYC,WAKxC,MAAMC,WAAkBF,EAAK,aAAaC,WAO1C,MAAME,WAAYH,EAAK,OAAOC,WAE9B,MAAM3C,WAAW0C,EAAK,MAAMC,WAM5B,MAAMG,WAAiBJ,EAAK,YAAYC,WAMxC,MAAMzC,WAAawC,EAAK,QAAQC,WAOhC,MAAM5C,WAAa2C,EAAK,QAAQC,WAMhC,MAAMI,WAAYL,EAAK,OAAOC,WAK9B,MAAMK,WAAwBN,EAAK,mBAAmBC,WAKtD,MAAMM,WAAsBP,EAAK,iBAAiBC,WAIlD,MAAMO,WAAYR,EAAK,OAAOC,WAI9B,MAAMQ,WAAwBT,EAAK,mBAAmBC,WAMtD,MAAMS,WAAoBV,EAAK,eAAeC,WAI9C,MAAMU,WAAmBX,EAAK,cAAcC,WAKrBD,EAAK,YAAYC,SACxC,MAAMW,WAA0BZ,EAAK,qBAAqBC,WAG1D,MAAMY,WAAuBb,EAAK,kBAAkBC,WACpD,MAAMa,WAAsBd,EAAK,iBAAiBC,WAElD,MAAMc,WAAkBf,EAAK,aAAaC,WAiB1C,MAAMlC,WAAmBiC,EAAK,cAAcC,WAO5C,MAAMjC,WAAoBgC,EAAK,eAAeC,WAO9C,MAAMe,WAAsBhB,EAAK,iBAAiBC,WAOlD,MAAMgB,WAA0BjB,EAAK,qBAAqBC,WAI1D,MAAMiB,WAAclB,EAAK,SAASC,WAKlC,MAAMkB,WAAiBnB,EAAK,YAAYC,WAExC,MAAMmB,WAAuBpB,EAAK,kBAAkBC,WAIpD,MAAMoB,WAAiCrB,EAAK,4BAA4BC,WAKxE,MAAM3L,WAAiB0L,EAAK,YAAYC,WACxC,MAAMqB,WAAoBtB,EAAK,eAAeC,WAK9C,MAAMsB,WAAkBvB,EAAK,aAAaC,WAC1C,MAAMuB,WAAuBxB,EAAK,kBAAkBC,WAItBD,EAAK,mBAAmBC,SAI9BD,EAAK,aAAaC,SACTD,EAAK,sBAAsBC,SAKtCD,EAAK,WAAWC,SAItC,MAAMwB,WAAgBzB,EAAK,WAAWC,WACtC,MAAMyB,WAA8B1B,EAAK,yBAAyBC,WAGlE,MAAM/N,WAAiB8N,EAAK,YAAYC,WACxC,MAAM9N,WAAuB6N,EAAK,kBAAkBC,WAIpD,MAAM0B,WAAc3B,EAAK,SAASC,WAKlC,MAAM2B,WAAmB5B,EAAK,cAAcC,WAG5C,MAAM4B,WAAuB7B,EAAK,kBAAkBC,WAGpD,MAAM6B,WAAsB9B,EAAK,iBAAiBC,WAIlD,MAAM8B,WAAa/B,EAAK,QAAQC,WAIhC,MAAM+B,WAAahC,EAAK,QAAQC,WC7LhC,MAAMgC,GACX7I,WAAAA,CAAqB8I,GAAuB3J,KAAvB2J,KAAAA,CAAwB,CAE7CC,OAAAA,GACE,OAAO5J,KAAK2J,IACd,CAEA9K,GAAAA,CAAOR,GACL,IAAIvB,EAAS+M,EAAgB7J,KAAK2J,KAAMtL,GACxC,OAAO,IAAIqL,GAAY5M,EACzB,CAEAgN,MAAAA,CAAoBC,GAClB,IAAI3L,EAAW,GAEf,IAAK,IAAI8C,KAAQlB,KAAK2J,KAChBI,EAAU7I,IACZ9C,EAAIiD,KAAKH,GAIb,OAAO8I,GAAa5L,EACtB,CAEA6L,cAAAA,GACE,OAAOjK,KAAK2J,IACd,CAEAO,IAAAA,CAAInH,GAA4F,IAArFoH,UAAEA,GAA0EpH,EACrF,OAAOoH,EAAUnK,KACnB,EAGK,MAAMoK,GACFT,KAAY,GAErB9K,GAAAA,CAAOwL,GACL,OAAO,IAAID,EACb,CAEAN,MAAAA,CAAoBQ,GAClB,OAAO,IAAIF,EACb,CAEAR,OAAAA,GACE,OAAO5J,KAAK2J,IACd,CAEAM,cAAAA,GACE,OAAO,IACT,CAEAC,IAAAA,CAAIK,GAA0F,IAAnFC,QAAEA,GAAwED,EACnF,OAAOC,GACT,EAKK,SAASR,GAAgBnO,GAC9B,OAAIyB,EAAezB,GACV,IAAI6N,GAAY7N,GAEhB,IAAIuO,EAEf,CC1EA,MAAeK,GACb,UAAOC,GACL,IAAItM,EAAiB,GAAG,IAAA,IAAAyF,EAAA3G,UAAAhD,OADiByQ,EAAOvR,IAAAA,MAAAyK,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAP4G,EAAO5G,GAAA7G,UAAA6G,GAGhD,IAAK,IAAIjH,KAAU6N,EAAS,CAC1B,GAAI7N,EAAO8N,MACT,OAAO9N,EAAO+N,OAEdzM,EAAIiD,KAAKvE,EAAOjB,MAEpB,CAEA,OAAOiP,GAAG1M,EACZ,EAOK,MAAM2M,GAASN,GAEtB,MAAMO,WAAkBP,GACbQ,MAAO,EACPL,OAAQ,EAEjB/J,WAAAA,CAAqBhF,GACnBqP,QAAQlL,KADWnE,MAAAA,CAErB,CAEAN,MAAAA,CAAO4P,GACL,OAAOnL,KAAKnE,KACd,CAEAuP,IAAAA,CAAK/M,GAEH,OADAA,EAAS2B,KAAKnE,OACPmE,IACT,CAEAqL,OAAAA,CAAWhN,GACT,OAAOA,EAAS2B,KAAKnE,MACvB,CAEAyP,KAAAA,CAASjN,GACP,OAAOyM,GAAGzM,EAAS2B,KAAKnE,OAC1B,CAEA0P,KAAAA,CAAMlB,GACJ,OAAOrK,IACT,CAEAwL,MAAAA,CAAOnB,GACL,OAAOrK,IACT,EAGF,MAAMyL,WAAmBhB,GACdQ,MAAO,EACPL,OAAQ,EAEjB/J,WAAAA,CAAqB6K,GACnBR,QAAQlL,KADW0L,OAAAA,CAErB,CAEAnQ,MAAAA,CAAOgG,GACL,MAAM,IAAI9F,MAAM8F,GAAW,0BAC7B,CAEA8J,OAAAA,CAAWhB,GACT,OAAOrK,KAAK6K,MACd,CAEAS,KAAAA,CAASjB,GACP,OAAOrK,KAAK6K,MACd,CAEAO,IAAAA,CAAKf,GACH,OAAOrK,IACT,CAEAwL,MAAAA,CAAOnN,GACL,OAAOsN,GAAItN,EAAS2B,KAAK0L,QAC3B,CAEAH,KAAAA,CAAMlN,GAEJ,OADAA,EAAS2B,KAAK0L,QACP1L,IACT,CAEA6K,IAAAA,GACE,OAAO7K,IACT,EAuBK,SAAS8K,GAAMjP,GACpB,OAAO,IAAImP,GAAOnP,EACpB,CAIO,SAAS8P,GAAOD,GACrB,OAAO,IAAID,GAAQC,EACrB,CAoBO,MAAME,GACX/K,WAAAA,GAA6C,IAAzBgL,EAAkB3O,UAAAhD,OAAA,QAAAiD,IAAAD,UAAA,GAAAA,UAAA,GAAG,GAAE8C,KAAvB6L,MAAAA,CAA0B,CAE9CC,GAAAA,CAAI5K,GACFlB,KAAK6L,MAAMxK,KAAKH,EAClB,CAEA0I,OAAAA,GACE,IAAImC,EAAM/L,KAAK6L,MAAM/B,QAAQ5I,GAA6BA,aAAgBuK,KAAS,GAEnF,YAAYtO,IAAR4O,EACKA,EAAIlB,OAEJC,GAAI9K,KAAK6L,MAAsBhN,KAAKqC,GAASA,EAAKrF,QAE7D,CAEAmQ,cAAAA,GACE,OAAOhM,KAAK4J,UAAU0B,OAAO1H,GAAQoG,GAAapG,IACpD,EChJK,SAASqI,GAAkCxE,GAChD,MAA4B,SAArBA,EAAKyE,OAAO1P,IACrB,CA4CO,SAAS2P,GACdC,GAbK,IAAwBnQ,EAe7B,GAdyB,UADIA,EAeVmQ,GAdVF,OAAO1P,MAIa,SAAzBP,EAAKiQ,OAAOG,IAAI7P,OAIb8P,EAAMC,mBAAmBtQ,EAAKiQ,OAAOG,IAAIG,cAnB3C,SAAsB9R,GAC3B,GAAkB,SAAdA,EAAK8B,KAAiB,CACxB,IAAM6P,IAAK9R,EAAM0C,KAAMwP,GAAU/R,EAEjC,MAAqB,SAAdH,EAAKiC,OAAoB8P,EAAMC,mBAAmBhS,EAAKiS,aAAgC,IAAjBC,EAAMvS,MACrF,CACE,OAAO,CAEX,CAiBgCwS,CAAaN,EAAOF,QAIlD,MAAMS,EACH,KAAIC,GAAUR,EAAOF,+CACtBE,EAAOS,IAEX,CAEA,SAASD,GAAUlS,GACjB,OAAQA,EAAK8B,MACX,IAAK,UACH,OAAOd,KAAKC,UAAUjB,EAAKmB,OAC7B,IAAK,OAAQ,CACX,IAAIiR,EAAc,CAACC,GAAcrS,EAAK2R,MAEtC,OADAS,EAAYzL,QAAQ3G,EAAKuC,KAAK4B,KAAKmO,GAAMA,EAAEC,SACpCH,EAAYI,KAAK,IAC1B,CACA,IAAK,OACH,MAAQ,IAAGN,GAAUlS,EAAKwR,eAC5B,IAAK,iBACH,MAAQ,GAAExR,EAAKwR,OAAO5S,OACxB,IAAK,cACH,MAAM6T,EAAY,iEAExB,CAEA,SAASJ,GAAcxS,GACrB,OAAQA,EAAKiC,MACX,IAAK,MACH,OAAOjC,EAAKjB,KAAK2T,MACnB,IAAK,OACL,IAAK,QACH,OAAO1S,EAAKjB,KACd,IAAK,OACH,MAAO,OAEb,CC2DO,SAAS8T,GAA2B1S,GACzC,MAAkB,SAAdA,EAAK8B,MAAqC,SAAlB9B,EAAK2R,IAAI7P,MAAmB9B,EAAK2R,IAAI/S,QAAQ+T,EAChE,IAAIf,EAAMzD,eAAe,CAC9BqD,OAAQxR,EACRyI,KAAMmJ,EAAM9C,KAAK8D,MAAM5S,EAAKmS,KAC5BA,IAAKnS,EAAKmS,MAIPnS,CACT,CAEO,MAAM6S,GAAc,IAxKpB,MACLC,KAAAA,CAAM/F,EAA4BgG,GAChC,OAAQhG,EAAKjL,MACX,IAAK,UACH,OAAOsO,GAAG9K,KAAKxG,QAAQiO,IACzB,IAAK,cACH,OAAOzH,KAAK0N,YAAYjG,EAAMgG,GAChC,IAAK,OACH,OAAOzN,KAAKiJ,eAAexB,GAC7B,IAAK,OAAQ,CACX,IAAIkG,EAAaC,GAAcC,UAAUpG,EAAMgG,GAE/C,OAAmB,OAAfE,EACKA,EAGF3N,KAAK6I,eAAepB,EAAMgG,EACnC,CACA,IAAK,iBACH,OAAOzN,KAAK8N,wBAAwBrG,EAAMgG,GAEhD,CAUAM,SAAAA,CACEC,EACAP,GAEA,OAAO,IAAI7B,GAAYoC,EAAMnP,KAAKsI,GAAMoG,GAAYC,MAAMrG,EAAGsG,MAASzB,gBACxE,CAQA/C,cAAAA,CAAevO,GACb,IAAI2R,EAAMrM,KAAKiO,kBAAkBvT,EAAK2R,MAClCpP,KAAEA,GAASvC,EAEf,GAAI4C,EAAeL,GAAO,CACxB,IAAIiR,EAAUjR,EAAK,GAAG4P,IAAIsB,OAAOC,EAAQnR,GAAM4P,KAC/C,OAAO/B,GACL,IAAIuD,GAAmB,CACrBxB,IAAKnS,EAAKmS,IACVtS,KAAM8R,EACNpP,KAAM,IAAIoR,GAAS,CAAExB,IAAKqB,EAASI,QAASrR,MAGlD,CACE,OAAO6N,GAAGuB,EAEd,CAEA4B,iBAAAA,CAAkB5B,GAChB,OAAOA,CACT,CAEA7S,OAAAA,CAAQ+U,GACN,OAAOA,CACT,CAEAb,WAAAA,CACEzR,EACAwR,GAEA,IAAIhB,EAAQxQ,EAAKwQ,MAAM5N,IAAIuO,IAE3B,OAAOG,GAAYQ,UAAUtB,EAAOgB,GAAOnC,OACxCmB,GAAU,IAAI4B,GAA0B,CAAExB,IAAK5Q,EAAK4Q,IAAKJ,MAAOA,KAErE,CAEA5D,cAAAA,CACE5M,EACAwR,GAEA,GAAKxB,GAAQhQ,GAGX,OAAO8O,GAAOL,IACZ6C,GAAYC,MAAMvR,EAAKiQ,OAAQuB,GAC/BF,GAAY/D,KAAKvN,EAAKkH,KAAMsK,IAC5BnC,OACAvI,IAAA,IAAEmJ,EAAQ/I,GAAKJ,EAAA,OACb,IAAIsL,GAAmB,CACrBxB,IAAK5Q,EAAK4Q,IACVX,SACA/I,QACA,IAXN,MAAM,IAAI1H,MAAO,6DAcrB,CAEAqS,uBAAAA,CAAuBvD,EAErBiE,GAC4B,IAF5BlO,IAAEA,EAAG4L,OAAEA,EAAMW,IAAEA,GAAqCtC,EAGpD,OAAOO,GAAG,IAAIuD,GAA6B,CAAExB,MAAKvM,MAAK4L,WACzD,CAEA1C,IAAAA,CAAIiF,EAAyChB,GAA6C,IAArFiB,WAAEA,EAAUC,MAAEA,EAAK9B,IAAEA,GAAiB4B,EACzC,OAAO1D,GAAOL,IAAI1K,KAAKqJ,WAAWqF,EAAYjB,GAAQzN,KAAKsJ,eAAeqF,EAAOlB,IAAQnC,OACvFsD,IAAA,IAAEF,EAAYC,GAAMC,EAAA,OAClB,IAAIP,GAAS,CACXxB,MACA6B,aACAC,SACA,GAER,CAEAtF,UAAAA,CACEqF,EACAjB,GAEA,OAAOF,GAAYQ,UAAUW,EAAWxH,MAAOuG,GAAOnC,OACnD3B,GACC,IAAI0E,GAAe,CACjBxB,IAAK6B,EAAW7B,IAChBlD,UAGR,CAEAL,cAAAA,CACEqF,EACAlB,GAEA,IAAIoB,EAAQF,EAAMjQ,QAAQG,KAAKyB,IAC7B,IAAIzE,EAAQuR,GAA2B9M,EAAIzE,OAE3C,OAAO0R,GAAYC,MAAM3R,EAAO4R,GAAOnC,OACpCzP,GACC,IAAIwS,GAAkB,CACpBxB,IAAKvM,EAAIuM,IACTpO,IAAK6B,EAAIhH,KACTuC,WAEL,IAGH,OAAO,IAAI+P,GAAYiD,GACpB7C,iBACAV,OAAOuD,GAAU,IAAIR,GAAmB,CAAExB,IAAK8B,EAAM9B,IAAKnO,QAASmQ,KACxE,GC3IF,MAAMC,GAMMC,MAEVlO,WAAAA,CACYmO,EACVxS,EACQyS,GACRjP,KAHUgP,QAAAA,EAAUhP,KAEZiP,SAAAA,EAER,IAAIjB,EAAQ,IAAIkB,IAChB,IAAK,IAAIC,KAAYC,GAAc5S,GACjCwR,EAAMlC,IAAIqD,GAGZnP,KAAK+O,MAAQf,CACf,CAEUzO,KAAAA,CAAMkI,GACd,IAAKzH,KAAK+O,MAAMM,IAAI5H,EAAKjL,MACvB,OAAO,EAGT,IAAI9B,EAAO4U,GAAoB7H,GAE/B,OAAa,OAAT/M,GAA+B,SAAdA,EAAK8B,MAAqC,SAAlB9B,EAAK2R,IAAI7P,SAChD9B,EAAKuC,KAAK/C,OAAS,GACmB,UAApCQ,EAAK2R,IAAIG,WAAW+C,cAOnB7U,EAAK2R,IAAI/S,OAAS0G,KAAKgP,QAIlC,CAEAnB,SAAAA,CAAUpG,EAAyBgG,GACjC,GAAIzN,KAAKT,MAAMkI,GAAO,CACpB,IAAI/M,EAAO4U,GAAoB7H,GAE/B,OAAa,OAAT/M,GAA+B,SAAdA,EAAK8B,MAAmB9B,EAAKuC,KAAK/C,OAAS,EACvDyR,GACLgB,EACG,SACC3M,KAAKgP,4DAC8CtU,EAAKmS,IAAI2C,yFAC9D/H,EAAKoF,MAKC7M,KAAKiP,SAASzL,OAAOiE,EAAMgG,GAC1BpC,SAASoE,GAAUzP,KAAKiP,SAASpB,UAAU,CAAEpG,OAAMgG,SAASgC,IAC3E,CACE,OAAO,IAEX,EASK,MAAML,GAAgB,CAC3B9U,KAAM,CAAC,QACPQ,MAAO,CAAC,eACRgB,OAAQ,CAAC,iBACTC,SAAU,CAAC,oBAgDb,SAASuT,GACP7H,GAEA,OAAQA,EAAKjL,MAGX,IAAK,OACH,OAAOiL,EACT,IAAK,gBACH,OAAO6H,GAAoB7H,EAAK5L,OAClC,IAAK,OACL,IAAK,cACL,IAAK,kBACH,OAAO4L,EAAKyE,OACd,QACE,OAAO,KAEb,CAEO,MAAMwD,GAGXC,UAAuB,GACvBC,MAEA/O,WAAAA,CAAYrE,GACVwD,KAAK4P,MAAQpT,CACf,CAEAqT,EAAAA,CACEvW,EACA2V,GAIA,OAFAjP,KAAK2P,UAAUtO,KAhDZ,SAIL2N,EAAiBxS,EAASyS,GAC1B,OAAO,IAAIH,GAAYE,EAASxS,EAAMyS,EACxC,CA0CwBD,CAAQ1V,EAAM0G,KAAK4P,MAAOX,IAEvCjP,IACT,CAEA6N,SAAAA,CACEpG,EACAgG,GAEA,IAAK,IAAIuB,KAAWhP,KAAK2P,UAAW,CAClC,IAAI7S,EAASkS,EAAQnB,UAAUpG,EAAMgG,GACrC,GAAe,OAAX3Q,EACF,OAAOA,CAEX,CAEA,IAAIpC,EAAO4U,GAAoB7H,GAE/B,GAAI/M,GAAsB,SAAdA,EAAK8B,MAAqC,SAAlB9B,EAAK2R,IAAI7P,MAAmBsT,EAAUpV,EAAK2R,IAAI/S,MAAO,CACxF,IAAIA,KAAEA,GAASoB,EAAK2R,IAEhB0D,EAAW/P,KAAK4P,MAChBI,EAAqC3C,EAAe/T,GAExD,IAAK0W,EAAWC,SAASF,GACvB,OAAOpE,GACLgB,EACG,SAAQrT,oDACP4W,GAAoBH,oCAsBlC,SAA8BzW,EAAcyV,GAC1C,OAAOA,EACJlQ,KAAKrC,IACJ,OAAQA,GACN,IAAK,SACH,MAAQ,sCAAqClD,MAC/C,IAAK,QACH,MAAQ,qCAAoCA,SAAYA,MAC1D,IAAK,OACH,MAAQ,+BAA8BA,KACxC,IAAK,WACH,MAAQ,kCAAiCA,aAC3C,QACE,OAAOyN,EAAUvK,GACrB,IAED0Q,KAAK,OACV,CAtC8CiD,CAChC7W,EACA0W,wBAEFvI,EAAKoF,KAIb,CAEA,OAAO,IACT,EAGF,MAAMqD,GAAsB,CAC1BpU,OAAQ,sBACRhB,MAAO,oBACPR,KAAM,oBACNyB,SAAU,cAuGL,SAASqU,GAAgC5T,GAC9C,OAAO,IAAIkT,GAASlT,EACtB,CCzUO,SAAS6T,GAAQtN,GAOtB,IAP0BS,OAC1BA,EAAMqK,UACNA,GAC2D9K,EAK3D,MAAO,CACLS,SACAqK,SAAAA,CAAStD,EAEP1O,GAC4B,IAF5B4L,KAAEA,EAAIgG,MAAEA,GAAgElD,EAKxE,OAFasD,EAAU,CAAEpG,OAAMgG,SAAS5R,GAE1ByP,OAAOgF,GAAS,IAAIjC,GAAmB,CAAEiC,OAAMzD,IAAKpF,EAAKoF,OACzE,EAEJ,CCdA,MAAM0D,GAA4B,CAChC,CAACC,EAAahI,WAAY,YAC1B,CAACgI,EAAaC,QAAS,SACvB,CAACD,EAAazU,UAAW,YAGpB,SAAS2U,GAAmBC,GACjC,MAAO,CACLlJ,EACAgG,KAKA,IAAImD,EAAeL,GAA0BI,GACzCE,EAAiBF,IAAgBH,EAAahI,WAE9CrF,KAAEA,GAASsE,EAEXqJ,EAAa3N,EAAK4N,IAAI,GAE1B,GAAmB,OAAfD,EACF,OAAOnF,GACLgB,EACG,IAAGiE,iBAA4BA,gGAChCzN,EAAK0J,MAKX,GAAwB,YAApBiE,EAAWtU,KAAoB,CACjC,GAAIqU,GAAkBpD,EAAMuD,SAC1B,OAAOrF,GACLgB,EACG,IAAGiE,2DACJnJ,EAAKoF,MAGJ,IAAKgE,EACV,OAAOlF,GACLgB,EACG,IAAGiE,oDAA+DA,wBACnEnJ,EAAKoF,KAIb,CAWA,OATA1J,EAAO,IAAImJ,EAAM9C,KAAK,CACpBkF,WAAY,IAAIpC,EAAM2E,oBAAoB,CACxC/J,MAAO/D,EAAKuL,WAAWxH,MAAMnM,MAAM,GACnC8R,IAAK1J,EAAKuL,WAAW7B,MAEvB8B,MAAOxL,EAAKwL,MACZ9B,IAAK1J,EAAK0J,MAGL/B,GAAG,CAAEgG,aAAY3N,QAAO,CAEnC,CAEA,SAAS+N,GAAsBP,GAC7B,MAAO,CAAA5N,EAAAwH,KAMiB,IALtB9C,KACEA,EAAIgG,MACJA,GACgF1K,GAClF+N,WAAEA,EAAU3N,KAAEA,GAA8DoH,EAExE4G,EAAmB5D,GAAYC,MAAMsD,EAAYrD,GACjD2D,EAAa7D,GAAY/D,KAAKrG,EAAMsK,GAExC,OAAO1C,GAAOL,IAAIyG,EAAkBC,GAAY9F,OAC9CmD,IAAA,IAAEqC,EAAY3N,GAAKsL,EAAA,OACjB,IAAIJ,GAAU,CACZxB,IAAKpF,EAAKoF,IACV8D,cACAG,aACA3N,QACA,GACL,CAEL,CAEO,SAASkO,GACdV,GAMA,MAAO,CACLnN,OAAQkN,GAAmBC,GAC3B9C,UAAWqD,GAAsBP,GAErC,CC7DO,MAAMW,GAIT,CACF9N,OAzCF,SAAoCiE,GAClC,IAAI8J,EAAqB,kBAAd9J,EAAKjL,KAA2BiL,EAAK5L,MAAQ4L,EAEpDkH,EAAsB,SAAd4C,EAAK/U,KAAkB+U,EAAKpO,KAAKwL,MAAQ,KACjD6C,EAA4B,SAAdD,EAAK/U,KAAkB+U,EAAKpO,KAAKuL,WAAa,KAEhE,GAAIC,IAAUA,EAAM8C,UAClB,OAAO9F,GACLgB,EAAqB,wDAAwDlF,EAAKoF,MAItF,IAAI6E,EAAUF,GAAaT,IAAI,GAE/B,OAAKW,EAIDF,GAAeA,EAAYG,KAAO,EAC7BhG,GACLgB,EAAqB,uDAAuDlF,EAAKoF,MAI9E/B,GAAG4G,GATD/F,GAAIgB,EAAqB,iDAAiDlF,EAAKoF,KAU1F,EAiBEgB,UAfF,SAAsC9K,EAEpCzJ,GAC2B,IAF3BmO,KAAEA,EAAIgG,MAAEA,GAAgE1K,EAGxE,OAAOwK,GAAYC,MAAMlU,EAAMmU,GAAOnC,OACnChS,GAAS,IAAI+U,GAAkB,CAAE/U,OAAMuT,IAAKpF,EAAKoF,OAEtD,GCnCA,SAAS+E,GAAsBpV,GAC7B,OAAQiL,IACN,IAAI8J,EAAqB,kBAAd9J,EAAKjL,KAA2BiL,EAAK5L,MAAQ4L,EAEpDkH,EAAsB,SAAd4C,EAAK/U,KAAkB+U,EAAKpO,KAAKwL,MAAQ,KACjD6C,EAA4B,SAAdD,EAAK/U,KAAkB+U,EAAKpO,KAAKuL,WAAa,KAEhE,GAAIC,IAAUA,EAAM8C,UAClB,OAAO9F,GAAIgB,EAAqB,IAAGnQ,uCAA2C+U,EAAK1E,MAGrF,IAAK2E,GAAeA,EAAYC,UAC9B,OAAO3G,GAAG+G,EAAYC,UAAU,YAC3B,GAAiC,IAA7BN,EAAYtK,MAAMhN,OAAc,CACzC,IAAIwU,EAAa8C,EAAYtK,MAAM,GACnC,OAAIoF,EAAMyF,UAAUrD,EAAY,UACvB5D,GAAG4D,EAAWsD,WAEdrG,GACLgB,EACG,IAAGnQ,6DACJ+U,EAAK1E,KAIb,CACE,OAAOlB,GACLgB,EAAqB,IAAGnQ,6CAAiD+U,EAAK1E,KAElF,CAEJ,CAEA,SAASoF,GAAyBzV,GAChC,MAAO,CAAAuG,EAELmP,KAC8C,IAF9CzK,KAAEA,EAAMgG,OAAO0E,MAAEA,IAAoEpP,EAYrF,OAAO+H,GARI,cAATtO,EACI,IAAI6R,GAAa,CAAExB,IAAKpF,EAAKoF,IAAKqF,SAAQ7R,OAAQ8R,EAAMC,cAAcF,EAAOjF,SAC7E,IAAIoB,GAAmB,CACrBxB,IAAKpF,EAAKoF,IACVqF,SACA7R,OAAQ8R,EAAMC,cAAcF,EAAOjF,SAG3B,CAEpB,CAEO,SAASoF,GACd7V,GAMA,MAAO,CACLgH,OAAQoO,GAAsBpV,GAC9BqR,UAAWoE,GAAyBzV,GAExC,CC7DA,SAAS8V,GAA4B9V,GACnC,OACE+V,IAMA,IAAIC,EAAoB,WAAThW,EAEXiL,EAA6B,kBAAtB8K,EAAa/V,KAA2B+V,EAAa1W,MAAQ0W,EACpE5D,EAAsB,SAAdlH,EAAKjL,KAAkBiL,EAAKtE,KAAKwL,MAAQ,KACjDD,EAA2B,SAAdjH,EAAKjL,KAAkBiL,EAAKtE,KAAKuL,WAAa,KAE/D,GAAIC,IAAUA,EAAM8C,UAClB,OAAO9F,GACLgB,EACG,IAAGnQ,gDAAmDmS,EAAMjQ,QAC1DG,KAAKsI,GAAMA,EAAE7N,KAAK2T,QAClBC,KAAK,QACRqF,EAAa1F,MAKnB,IAAI4F,EAAY/D,GAAYqC,IAAI,GAEhC,IAAKrC,IAAe+D,EAClB,OAAO9G,GACLgB,EACG,sBAAqBnQ,0FAA6FA,sDACjHgW,EAAW,QAAU,yCAEvBD,EAAa1F,MAKnB,IAAI6F,EAAShE,EAAWqC,IAAI,GACxB4B,EAAQjE,EAAWqC,IAAI,GAE3B,OAAe,OAAX2B,EACK/G,GACLgB,EACG,sBAAqBnQ,0FAA6FA,sDACjHgW,EAAW,QAAU,qDAEvBD,EAAa1F,MAKf6B,EAAWiD,KAAO,EACbhG,GACLgB,EACG,sBAAqBnQ,8GAAiHA,kDACrIgW,EAAW,QAAU,0DAErBA,EAAW,OAAS,qBACR9D,GAAYiD,MAAQ,eAClCY,EAAa1F,MAKZ/B,GAAG,CAAE2H,YAAWC,SAAQC,SAAQ,CAE3C,CAEA,SAASC,GAA+BpW,GACtC,IAAIgW,EAAoB,WAAThW,EAEf,MAAO,CAAAuG,EAAAwH,KAcoB,IAbzB9C,KACEA,EAAIgG,MACJA,GACgF1K,GAClF0P,UACEA,EAASC,OACTA,EAAMC,MACNA,GAKDpI,EAEGsI,EAAkBtF,GAAYC,MAAMiF,EAAWhF,GAC/CqF,EAAevF,GAAYC,MAAMkF,EAAQjF,GACzCsF,EAAcJ,EAAQpF,GAAYC,MAAMmF,EAAOlF,GAAS3C,GAAG,MAE/D,OAAOC,GAAOL,IAAImI,EAAiBC,EAAcC,GAAazH,OAC5DmD,IAAgC,IAA9BgE,EAAWC,EAAQC,GAAMlE,EAKzB,OAJI+D,IACFC,EAAY,IAAIpE,GAAQ,CAAExS,MAAO4W,EAAW5F,IAAKpF,EAAKoF,OAGjD,IAAIwB,GAAa,CACtBxB,IAAKpF,EAAKoF,IACV4F,YACAC,SACAC,SACA,GAEL,CAEL,CAEO,SAASK,GAAsBxW,GASpC,MAAO,CACLgH,OAAQ8O,GAA4B9V,GACpCqR,UAAW+E,GAA+BpW,GAE9C,CCpGO,MAAMyW,GAIT,CACFzP,OA1BF,SAA0BiE,GACxB,IACEtE,MAAMwL,MAAEA,EAAKD,WAAEA,IACbjH,EAEJ,OAAIkH,IAAUA,EAAM8C,UACX9F,GAAIgB,EAAqB,0CAA0ClF,EAAKoF,MAG1E/B,GAAG4D,EACZ,EAiBEb,UAfF,SAA4B9K,EAE1B2L,GACiB,IAFjBjH,KAAEA,EAAIgG,MAAEA,GAAkE1K,EAG1E,OAAOwK,GAAYlE,WAAWqF,EAAYjB,GAAOnC,OAC9CoD,GAAe,IAAIL,GAAQ,CAAEK,aAAY7B,IAAKpF,EAAKoF,OAExD,GCZaqG,GAAkB9C,GAAS,UACrCP,GAAG,YAAaQ,GAASgC,GAAgB,eACzCxC,GAAG,mBAAoBQ,GAASgC,GAAgB,sBAChDxC,GAAG,mBAAoBQ,GAASiB,KAChCzB,GAAG,MAAOQ,GAAS4C,KACnBpD,GAAG,KAAMQ,GAAS2C,GAAsB,QACxCnD,GAAG,SAAUQ,GAAS2C,GAAsB,YAC5CnD,GAAG,QAAS,CACXrM,MAAAA,CAAOiE,GAIL,IAAItE,KAAEA,GAASsE,EAEf,GAAItE,EAAKwL,MAAM8C,UACb,OAAO3G,GAAG,CACRoH,OAAQiB,EAAIC,WAAWtB,UAAU,WAAWE,UAC5CtD,WAAYvL,EAAKuL,aAEd,CACL,IAAIwD,EAAS/O,EAAKwL,MAAM0E,IAAI,MAE5B,OAAIlQ,EAAKwL,MAAMgD,KAAO,GAAgB,OAAXO,EAClBvG,GACLgB,EAAqB,iDAAiDxJ,EAAKwL,MAAM9B,MAIjFP,EAAMyF,UAAUG,EAAQ,UACnBpH,GAAG,CAAEoH,OAAQA,EAAOF,UAAWtD,WAAYvL,EAAKuL,aAEhD/C,GACLgB,EAAqB,+CAA+CuF,EAAOrF,KAGjF,CACD,EAEDgB,SAAAA,CAAS9K,EAAAwH,GASgB,IARvB9C,KAAEA,EAAIgG,MAAEA,GAAiE1K,GACzEmP,OACEA,EAAMxD,WACNA,GAIDnE,EAED,OAAOgD,GAAYlE,WAAWqF,EAAYjB,GAAOnC,OAC9CoD,GACC,IAAIL,GAAU,CACZxB,IAAKpF,EAAKoF,IACVqF,SACAoB,GAAI7F,EAAM0E,MAAMC,cAAcF,EAAOjF,OACrCyB,gBAGR,IAEDmB,GAAG,WAAY,CACdrM,MAAAA,CAAOiE,GACL,IAAItE,KAAEA,GAASsE,GACXiH,WAAEA,GAAevL,EAErB,OAAIA,EAAKsO,UACA3G,QAAG3N,GAENuR,EAAW+C,UACN9F,GAAIgB,EAAqB,6CAA6ClF,EAAKoF,MAE3ElB,GACLgB,EAAqB,kDAAkDlF,EAAKoF,KAInF,EAEDgB,SAAAA,CAASY,GAMiB,IANhBhH,KACRA,EACAgG,OAAO0E,MAAEA,IAIV1D,EAEC,OADA0D,EAAMoB,iBACCzI,GAAG,IAAIuD,GAAa,CAAExB,IAAKpF,EAAKoF,IAAKsF,UAC9C,IAEDtC,GAAG,YAAa,CACfrM,OAAQkN,GAAmBF,EAAahI,WAExCqF,SAAAA,CAASe,EAAA4E,GAGsB,IAF7B/L,KAAEA,EAAIgG,MAAEA,GAAiEmB,GACzEkC,WAAEA,EAAU3N,KAAEA,GAA8DqQ,EAExErC,EAAmB5D,GAAYC,MAAMsD,EAAYrD,GACjD2D,EAAa7D,GAAY/D,KAAKrG,EAAMsK,GAExC,OAAO1C,GAAOL,IAAIyG,EAAkBC,GAAY9F,OAC9CmI,IAAA,IAAE3C,EAAY3N,GAAKsQ,EAAA,OACjB,IAAIpF,GAAoB,CACtBxB,IAAKpF,EAAKoF,IACViE,aACA3N,OACAxI,OAAQ,MACR,GAER,IAEDkV,GAAG,SAAU,CACZrM,OAAQkN,GAAmBF,EAAaC,QAExC5C,SAAAA,CAAS6F,EAAAC,GAGqB,IAF5BlM,KAAEA,EAAIgG,MAAEA,GAAiEiG,GACzE5C,WAAEA,EAAU3N,KAAEA,GAA8DwQ,EAExExC,EAAmB5D,GAAYC,MAAMsD,EAAYrD,GACjD2D,EAAa7D,GAAY/D,KAAKrG,EAAMsK,GAExC,OAAO1C,GAAOL,IAAIyG,EAAkBC,GAAY9F,OAAMsI,IAAwB,IAAtB9C,EAAY3N,GAAKyQ,EACnEtD,EAAO,IAAIjC,GAAmB,CAAEnC,OAAQ4E,EAAY3N,OAAM0J,IAAKpF,EAAKoF,MAExE,OAAO,IAAIwB,GAAmB,CAC5BxB,IAAKpF,EAAKoF,IACVyD,QACA,GAEN,ICnISuD,GAAiBzD,GAAS,SACpCP,GAAG,aAAc,CAChBrM,MAAAA,CAAOiE,GAIL,IAAItE,KAAEA,GAASsE,EAEXqM,EAAO3Q,EAAKkQ,IAAI,QAEpB,GAAIS,EACF,OAAOnI,GAAIgB,EAAqB,0CAA8CmH,EAAKjH,MAGrF,IAAIkH,EAAe5Q,EAAKkQ,IAAI,gBACxBW,EAAc7Q,EAAK4N,IAAI,GAE3B,OAAoB,OAAhBiD,EACKrI,GACLgB,EACG,8EACDxJ,EAAK0J,MAOJ/B,GAAG,CAAEiJ,eAAcC,eAC3B,EAEDnG,SAAAA,CAAS9K,EAAAwH,GAMgB,IALvB9C,KAAEA,EAAIgG,MAAEA,GAA+D1K,GACvEgR,aACEA,EAAYC,YACZA,GACiFzJ,EAE/EoE,EAAQlH,EAAK9M,OAAO0Y,IAAI,WACxBY,EAAOC,GAAY9L,WAAWuG,EAAOlB,GACrC0G,EAAoB5G,GAAYC,MAAMwG,EAAavG,GAEvD,OAAO1C,GAAOL,IAAIuJ,EAAME,GACrB9I,SACCoD,IAIM,IAJJwF,EAAMD,GAAYvF,EAKlB,OAAIsF,EACKxG,GAAYC,MAAMuG,EAActG,GAAOnC,OAAOyI,IAAkB,CACrEE,OACAD,cACAD,mBAGKjJ,GAAG,CACRmJ,OACAD,cACAD,aAAc,IAAI1F,GAAY,CAC5BxB,IAAKpF,EAAKyE,OAAOW,IAAIuH,SAAS,UAGpC,IAGH9I,OACCsD,IAAA,IAACqF,KAAEA,EAAID,YAAEA,EAAWD,aAAEA,GAAcnF,EAAA,OAClC,IAAIP,GAAc,CAChBxB,IAAKpF,EAAKoF,IACV1R,MAAO8Y,EACPF,eACAD,KAAMrG,EAAM4G,uBACZL,eACA,GAEV,IAEDnE,GAAG,KAAM,CACRrM,MAAAA,CAAOiE,GAGL,IAAItE,KAAEA,GAASsE,EAEf,IAAKtE,EAAKwL,MAAM8C,UACd,OAAO9F,GACLgB,EACG,qDAAoDxJ,EAAKwL,MAAMjQ,QAC7DG,KAAKsI,GAAMA,EAAE7N,KAAK2T,QAClBC,KAAK,QACRzF,EAAKoF,MAKX,GAAI1J,EAAKuL,WAAWiD,KAAO,EACzB,OAAOhG,GACLgB,EACG,oGAAmGxJ,EAAKuL,WAAWiD,kBACpHlK,EAAKoF,MAKX,IAAI4F,EAAYtP,EAAK4N,IAAI,GAEzB,OAAkB,OAAd0B,EACK9G,GACLgB,EACG,iGACDlF,EAAKoF,MAKJ/B,GAAG,CAAE2H,aACb,EAED5E,SAAAA,CAAS2F,EAAAC,GAGS,IAFhBhM,KAAEA,EAAIgG,MAAEA,GAA+D+F,GACvEf,UAAEA,GAAgDgB,EAE9CtY,EAAQsM,EAAK9M,OAAO0Y,IAAI,WACxBxO,EAAU4C,EAAK9M,OAAO0Y,IAAI,QAE1BR,EAAkBtF,GAAYC,MAAMiF,EAAWhF,GAC/C6G,EAAcJ,GAAY9L,WAAWjN,EAAOsS,GAC5C8G,EAAgB1P,EAAUqP,GAAY9L,WAAWvD,EAAS4I,GAAS3C,GAAG,MAE1E,OAAOC,GAAOL,IAAImI,EAAiByB,EAAaC,GAAejJ,OAC7DoI,IAAA,IAAEjB,EAAWtX,EAAO0J,GAAQ6O,EAAA,OAC1B,IAAIrF,GAAO,CACTxB,IAAKpF,EAAKoF,IACV4F,YACAtX,QACA0J,WACA,GAER,IAEDgL,GAAG,SAAU,CACZrM,MAAAA,CAAOiE,GAGL,IAAItE,KAAEA,GAASsE,EAEf,IAAKtE,EAAKwL,MAAM8C,UACd,OAAO9F,GACLgB,EACG,yDAAwDxJ,EAAKwL,MAAMjQ,QACjEG,KAAKsI,GAAMA,EAAE7N,KAAK2T,QAClBC,KAAK,QACRzF,EAAKoF,MAKX,GAAI1J,EAAKuL,WAAWiD,KAAO,EACzB,OAAOhG,GACLgB,EACG,wGAAuGxJ,EAAKuL,WAAWiD,kBACxHlK,EAAKoF,MAKX,IAAI4F,EAAYtP,EAAK4N,IAAI,GAEzB,OAAkB,OAAd0B,EACK9G,GACLgB,EACG,qGACDlF,EAAKoF,MAKJ/B,GAAG,CAAE2H,aACb,EAED5E,SAAAA,CAAS8F,EAAAC,GAGS,IAFhBnM,KAAEA,EAAIgG,MAAEA,GAA+DkG,GACvElB,UAAEA,GAAgDmB,EAE9CzY,EAAQsM,EAAK9M,OAAO0Y,IAAI,WACxBxO,EAAU4C,EAAK9M,OAAO0Y,IAAI,QAE1BR,EAAkBtF,GAAYC,MAAMiF,EAAWhF,GAC/C6G,EAAcJ,GAAY9L,WAAWjN,EAAOsS,GAC5C8G,EAAgB1P,EAAUqP,GAAY9L,WAAWvD,EAAS4I,GAAS3C,GAAG,MAE1E,OAAOC,GAAOL,IAAImI,EAAiByB,EAAaC,GAAejJ,OAC7DkJ,IAAA,IAAE/B,EAAWtX,EAAO0J,GAAQ2P,EAAA,OAC1B,IAAInG,GAAO,CACTxB,IAAKpF,EAAKoF,IACV4F,UAAW,IAAIpE,GAAQ,CAAExS,MAAO4W,EAAW5F,IAAKpF,EAAKoF,MACrD1R,QACA0J,WACA,GAER,IAEDgL,GAAG,OAAQ,CACVrM,MAAAA,CAAOiE,GAIL,IAAItE,KAAEA,GAASsE,EAEf,IAAKtE,EAAKwL,MAAMjQ,QAAQ+V,OAAOtN,GAAuB,QAAjBA,EAAE7N,KAAK2T,QAC1C,OAAOtB,GACLgB,EACG,kEAAiExJ,EAAKwL,MAAMjQ,QAC1EoL,QAAQ3C,GAAuB,QAAjBA,EAAE7N,KAAK2T,QACrBpO,KAAKsI,GAAMA,EAAE7N,KAAK2T,QAClBC,KAAK,QACR/J,EAAKwL,MAAM9B,MAKjB,GAAI1J,EAAKuL,WAAWiD,KAAO,EACzB,OAAOhG,GACLgB,EACG,gGAA+FxJ,EAAKuL,WAAWiD,kBAChHxO,EAAKuL,WAAW7B,MAKtB,IAAIhR,EAAQsH,EAAK4N,IAAI,GACjBtS,EAAM0E,EAAKkQ,IAAI,OAEnB,OAAc,OAAVxX,EACK8P,GACLgB,EACG,sHACDxJ,EAAK0J,MAKJ/B,GAAG,CAAEjP,QAAO4C,OACpB,EAEDoP,SAAAA,CAAS6G,EAAAC,GAGW,IAFlBlN,KAAEA,EAAIgG,MAAEA,GAA+DiH,GACvE7Y,MAAEA,EAAK4C,IAAEA,GAAwEkW,EAE7ExZ,EAAQsM,EAAK9M,OAAO0Y,IAAI,WACxBxO,EAAU4C,EAAK9M,OAAO0Y,IAAI,QAE1BuB,EAAcrH,GAAYC,MAAM3R,EAAO4R,GACvCoH,EAAYpW,EAAM8O,GAAYC,MAAM/O,EAAKgP,GAAS3C,GAAG,MAErDwJ,EAAcJ,GAAY9L,WAAWjN,EAAOsS,GAC5C8G,EAAgB1P,EAAUqP,GAAY9L,WAAWvD,EAAS4I,GAAS3C,GAAG,MAE1E,OAAOC,GAAOL,IAAIkK,EAAaC,EAAWP,EAAaC,GAAejJ,OACpEwJ,IAAA,IAAEjZ,EAAO4C,EAAKtD,EAAO0J,GAAQiQ,EAAA,OAC3B,IAAIzG,GAAS,CACXxB,IAAKpF,EAAKoF,IACVhR,QACA4C,MACAtD,QACA0J,WACA,GAER,IAEDgL,GAAG,OAAQ,CACVrM,MAAAA,CAAOiE,GAGL,IAAItE,KAAEA,GAASsE,EAEf,IAAKtE,EAAKwL,MAAM8C,UACd,OAAO9F,GACLgB,EACG,uDAAsDxJ,EAAKwL,MAAMjQ,QAC/DG,KAAKsI,GAAMA,EAAE7N,KAAK2T,QAClBC,KAAK,QACR/J,EAAKwL,MAAM9B,MAKjB,GAAI1J,EAAKuL,WAAWiD,KAAO,EACzB,OAAOhG,GACLgB,EACG,iEAAgExJ,EAAKuL,WAAWiD,kBACjFxO,EAAKuL,WAAW7B,MAKtB,IAAIhR,EAAQsH,EAAK4N,IAAI,GAErB,OAAc,OAAVlV,EACK8P,GACLgB,EACG,+FACDxJ,EAAK0J,MAKJ/B,GAAG,CAAEjP,SACb,EAEDgS,SAAAA,CAASkH,EAAAC,GAGW,IAFlBvN,KAAEA,EAAIgG,MAAEA,GAA+DsH,GACvElZ,MAAEA,GAAwCmZ,EAEtC7Z,EAAQsM,EAAK9M,OAAO0Y,IAAI,WACxBxO,EAAU4C,EAAK9M,OAAO0Y,IAAI,QAE1BuB,EAAcrH,GAAYC,MAAM3R,EAAO4R,GACvC6G,EAAcJ,GAAY9L,WAAWjN,EAAOsS,GAC5C8G,EAAgB1P,EAAUqP,GAAY9L,WAAWvD,EAAS4I,GAAS3C,GAAG,MAE1E,OAAOC,GAAOL,IAAIkK,EAAaN,EAAaC,GAAejJ,OACzD2J,IAAA,IAAEpZ,EAAOV,EAAO0J,GAAQoQ,EAAA,OACtB,IAAI5G,GAAS,CACXxB,IAAKpF,EAAKoF,IACVhR,QACAV,QACA0J,WACA,GAER,IAEDgL,GAAG,MAAO,CACTrM,MAAAA,CAAOiE,GAGL,IAAItE,KAAEA,GAASsE,EAEf,OAAKtE,EAAKwL,MAAM8C,UAWa,IAAzBtO,EAAKuL,WAAWiD,KACXhG,GACLgB,EACG,yGACDxJ,EAAKuL,WAAW7B,MAKlBpF,EAAK9M,OAAO0Y,IAAI,QACX1H,GACLgB,EAAqB,4CAA4CxJ,EAAKuL,WAAW7B,MAI9E/B,GAAG,CAAE4D,WAAYvL,EAAKuL,aAzBpB/C,GACLgB,EACG,sDAAqDxJ,EAAKwL,MAAMjQ,QAC9DG,KAAKsI,GAAMA,EAAE7N,KAAK2T,QAClBC,KAAK,QACR/J,EAAKwL,MAAM9B,KAqBlB,EAEDgB,SAAAA,CAASqH,EAAAC,GAGU,IAFjB1N,KAAEA,EAAIgG,MAAEA,GAA+DyH,GACvExG,WAAEA,GAAuDyG,EAErDha,EAAQsM,EAAK9M,OAAO0Y,IAAI,WAExB+B,EAAmB7H,GAAYlE,WAAWqF,EAAYjB,GACtD6G,EAAcJ,GAAY9L,WAAWjN,EAAOsS,GAEhD,OAAO1C,GAAOL,IAAI0K,EAAkBd,GAAahJ,OAC/C+J,IAAA,IAAE3G,EAAYvT,GAAMka,EAAA,OAClB,IAAIhH,GAAQ,CACVxB,IAAKpF,EAAKoF,IACV6B,aACAvT,SACA,GAER,IAED0U,GAAG,qBAAsB,CACxBrM,OAAOiE,GAGEqD,GAAG,CAAE6D,MAAOlH,EAAKtE,KAAKwL,QAG/Bd,SAAAA,CAASyH,EAAAC,GAGsB,IAF7B9N,KAAEA,EAAIgG,MAAEA,GAA+D6H,GACvE3G,MAAEA,GAAwC4G,EAEtCpa,EAAQsM,EAAK9M,OAAO0Y,IAAI,WAExBmC,EAAcjI,GAAYjE,eAAeqF,EAAOlB,GAChD6G,EAAcJ,GAAY9L,WAAWjN,EAAOsS,GAEhD,OAAO1C,GAAOL,IAAI8K,EAAalB,GAAahJ,OAC1CmK,IAAA,IAAE9G,EAAOxT,GAAMsa,EAAA,OACb,IAAIpH,GAAoB,CACtBxB,IAAKpF,EAAKoF,IACV8B,QACAxT,SACA,GAER,IAED0U,GAAG,YAAa,CACfrM,OAAQkN,GAAmBF,EAAahI,WAExCqF,SAAAA,CAAS6H,EAAAC,GAGsB,IAF7BlO,KAAEA,EAAIgG,MAAEA,GAA+DiI,GACvE5E,WAAEA,EAAU3N,KAAEA,GAA8DwS,EAExExE,EAAmB5D,GAAYC,MAAMsD,EAAYrD,GACjD2D,EAAa7D,GAAY/D,KAAKrG,EAAMsK,GACpCmI,EAAe1B,GAAY/L,YAAYV,EAAK9M,OAAQ8S,GAExD,OAAO1C,GAAOL,IAAIyG,EAAkBC,EAAYwE,GAActK,OAC5DuK,IAAA,IAAE/E,EAAY3N,EAAMxI,GAAOkb,EAAA,OACzB,IAAIxH,GAAoB,CACtBxB,IAAKpF,EAAKoF,IACViE,aACA3N,OACAxI,UACA,GAER,IClbSiT,GAAgBwC,GAAS,QACnCP,GAAG,YAAawC,GAAgB,cAChCxC,GAAG,mBAAoBwC,GAAgB,qBACvCxC,GAAG,mBAAoByB,IACvBzB,GAAG,MAAOoD,IACVpD,GAAG,KAAMmD,GAAsB,OAC/BnD,GAAG,SAAUmD,GAAsB,WACnCnD,GAAG,YAAawB,GAAab,EAAahI,YAC1CqH,GAAG,SAAUwB,GAAab,EAAaC,SACvCZ,GAAG,WAAYwB,GAAab,EAAazU,WChB/B+Z,GAAoB1F,GAAS,YCepC2F,GAAQ,+BACRC,GAAM,uCACNC,GAAQ,gCAERC,GAAsC,CAC1C,gBAAiBH,GACjB,gBAAiBA,GACjB,aAAcA,GACd,aAAcA,GACd,aAAcA,GACd,cAAeA,GACf,aAAcA,GACd,WAAYC,GACZ,WAAYA,GACZ,YAAaA,GACbG,MAAOF,GACP,cAAeA,IAOjB,MAAMG,GAEF,CACFC,IAAKC,EAAkBD,IACvBE,KAAMD,EAAkBC,KACxBC,EAAGF,EAAkBE,EACrBzX,EAAGuX,EAAkBvX,GAGjB0X,GAEF,CAAC,MAAO,OAAQ,IAAK,KAMlB,SAASC,GAAeC,GAC7B,MAA0B,iBAAZA,EAAuBA,EAAUF,GAAkBE,EACnE,CAEA,MAAMC,GAEF,CACFC,MAAOC,EAAmBD,MAC1BE,GAAID,EAAmBC,GACvBlb,MAAOib,EAAmBjb,MAC1BvC,KAAMwd,EAAmBxd,KACzBkD,KAAMsa,EAAmBta,KACzBwa,MAAOF,EAAmBE,MAC1BC,KAAMH,EAAmBG,MAGrBC,GAEF,CAAC,QAAS,KAAM,QAAS,OAAQ,OAAQ,QAAS,QAE/C,SAASC,GAAgBC,GAC9B,OAAOR,GAAmBQ,IAAaA,CACzC,CAEO,SAASC,GAAgBD,GAC9B,MAA2B,iBAAbA,EAAwBA,EAAWF,GAAmBE,EACtE,CC1DO,MAAME,GACFrI,SAETpO,WAAAA,CACW0W,EACTtI,EACSxB,GACTzN,KAHSuX,QAAAA,EAA0BvX,KAE1ByN,MAAAA,EAETzN,KAAKiP,SAAWA,CAClB,CAEAuI,WAAAA,GACE,OAAOxX,KAAKyX,UAAUpM,SAASqM,GAAa1X,KAAKiP,SAASuI,YAAYxX,KAAM0X,IAC9E,CAEQ1Y,IAAAA,CAAKA,GACX,IAAI1F,EAAO0F,EAAK1F,KACZqe,EAAW3Y,EAAKnD,MAChByJ,GDPyB8R,ECOI9d,EAAK2T,MDNjCiJ,GAAUkB,SCMiCja,GDP7C,IAA0Bia,ECS7B,OAAI9K,EAAMyF,UAAU4F,EAAU,UACrB7M,GACL,IAAIuD,GAAe,CACjBxB,IAAK7N,EAAK6N,IACVvT,OACAuC,MAAO8b,EAAS3F,UAChB1M,YACAjL,KAAM,CACJud,UAAW5X,KAAKiP,SAAS4I,oBAM1BtK,GAAYC,MAAMJ,GAA2BuK,GAAW3X,KAAKyN,OAAOnC,OAAOzP,IAChF,IAAIic,EAAa9Y,EAAK+Y,SAEtB,OAAO,IAAI1J,GAAgB,CACzBxB,IAAK7N,EAAK6N,IACVvT,OACAuC,MAAOA,EACPyJ,YACAjL,KAAM,CACJ0d,SAAUD,EACVF,UAAW5X,KAAKiP,SAAS4I,kBAE3B,GAEN,CAEQG,QAAAA,CAASA,IdlDZ,SACLvQ,GAEA,QAAKwE,GAAQxE,KAILA,EAAKtE,KAAKsO,SACpB,Ec2CQwG,CAAmBD,IACrB7L,GAAsB6L,GAGxB,IAAIrK,EAAamI,GAAkBjI,UAAUmK,EAAUhY,KAAKyN,OAE5D,GAAmB,OAAfE,EACF,OAAOA,EAGT,IAAIpT,EAAOgT,GAAYC,MAAMwK,EAAS9L,OAAQlM,KAAKyN,OAC/CtK,EAAOoK,GAAY/D,KAAKwO,EAAS7U,KAAMnD,KAAKyN,OAEhD,OAAO1C,GAAOL,IAAInQ,EAAM4I,GAAMmI,OAC5BvI,IAAA,IAAExI,EAAM4I,GAAKJ,EAAA,OACX,IAAIsL,GAAa,CACfxB,IAAKmL,EAASnL,IACdX,OAAQ3R,EACR4I,QACA,GAER,CAEQlI,KAAAA,GACN,IAAIA,EAAQ,IAAI2Q,GACZzI,EAAO,IAAIyI,GAQXsM,EAAkC,KAClCC,EAAmF,IAA1EnY,KAAKuX,QAAQtc,MAAM6O,QAAQ9K,GAAuB,cAAdA,EAAKxC,OAAsBtC,OAE5E,IAAK,IAAI8E,KAAQgB,KAAKuX,QAAQtc,MACV,cAAd+D,EAAKxC,KACPvB,EAAM6Q,IACJhB,GAAG,IAAIuD,GAAc,CAAExB,IAAK7N,EAAK6N,IAAKxM,OAAQL,KAAKyN,MAAM0E,MAAMC,cAAc,aAElD,SAApBpT,EAAK1F,KAAK2T,OAAoBkL,EACvCD,EAAWlZ,EAEX/D,EAAM6Q,IAAI9L,KAAKhB,KAAKA,IAIxB,IAAK,IAAIsB,KAAON,KAAKuX,QAAQa,cAC3BjV,EAAK2I,IAAI9L,KAAKiP,SAAS3O,IAAIA,EAAKN,OAOlC,OAJIkY,GACFjd,EAAM6Q,IAAI9L,KAAKhB,KAAKkZ,IAGfnN,GAAOL,IAAIvH,EAAKyG,UAAW3O,EAAM2O,WAAW0B,OAAMf,IAAA,IAAEpH,EAAMlI,GAAMsP,EAAA,MAAM,CAC3EtP,QACAkI,KAAM,IAAIkL,GAAmB,CAC3BxB,IAAKwL,EAASlV,EAAMgQ,EAAIC,WAAWkF,cACnC5Z,QAASsL,GAAa7G,KAEzB,GACH,CAEQsU,OAAAA,GACN,IAAIxc,EAAQ+E,KAAK/E,QACbsd,EAAY,IAAI3M,GAAY5L,KAAKuX,QAAQgB,UAAU1Z,KAAK2Z,GAAMxY,KAAKgY,SAASQ,MAAK5O,UAErF,OAAOmB,GAAOL,IAAIzP,EAAOsd,GAAWjN,OAAMmD,IAAyB,IAAvB3R,EAAQyb,GAAU9J,GACxDxT,MAAEA,EAAKkI,KAAEA,GAASrG,EAElB2b,EAAgB,IAAIxd,KAAUsd,GAOlC,MAAO,CAAEpV,OAAMnJ,OALF,IAAIqU,GAAsB,CACrCxB,IAAKwL,EAASI,EAAetF,EAAIC,WAAWkF,cAC5CrE,KAAMjK,GAAayO,KAGE,GAE3B,ECpJK,MAAMC,GACFb,iBAAkB,EAE3BhX,WAAAA,CAAoB8X,EAAiCpB,GAAgCvX,KAAjE2Y,IAAAA,EAAuB3Y,KAAUuX,QAAAA,CAAiC,CAEtFjX,GAAAA,CAAItB,EAAwB+D,GAA2D,IAAzD0K,MAAEA,GAA0B1K,EACpDzJ,EAAO0F,EAAK1F,KAEhB,OAAOiU,GAAYC,MAAMJ,GAA2BpO,EAAKnD,OAAQ4R,GAAOnC,OACrEzP,GACC,IAAIwS,GAAkB,CACpBxB,IAAK7N,EAAK6N,IACVpO,IAAKnF,EACLuC,WAGR,CAEA2b,WAAAA,CAAYI,EAA4BrN,GAAyD,IAAvDpH,KAAEA,EAAInJ,OAAEA,GAAsBuQ,GAClEgN,QAAEA,EAAO9J,MAAEA,GAAUmK,EAEzB,OAAO5X,KAAKrF,OAAO8S,GAAOnC,OACvB3Q,GACC,IAAI0T,GAAc,CAChBxB,IAAK0K,EAAQ1K,IACb8L,IAAK3Y,KAAK2Y,IACV3e,SACAmJ,OACAxI,YAGR,CAEQA,MAAAA,CAAO8S,GACb,OAAOyG,GAAY/L,YAAYnI,KAAKuX,QAAQ5c,OAAQ8S,EACtD,ECrCK,MAAMmL,GACX/X,WAAAA,CACU8X,EACApB,EACCM,GACT7X,KAHQ2Y,IAAAA,EAAgB3Y,KAChBuX,QAAAA,EAA4BvX,KAC3B6X,gBAAAA,CACR,CAEMgB,aAAc,EAEvBvY,GAAAA,CAAItB,GACF,OAAO2M,GACLgB,EACG,GAAE3N,EAAK1F,KAAK2T,mHAAmHjN,KAAK2Y,IAAI1L,qDACzIjO,EAAK6N,KAGX,CAEA2K,WAAAA,CAAYsB,EAA6B/V,GAAmD,IAAjD/I,OAAEA,GAAsB+I,GAC7D0K,MAAEA,EAAK8J,QAAEA,GAAYuB,EAIzB,OAFW5E,GAAYnG,UAAU/N,KAAKuX,QAAQtD,KAAMxG,GAExCnC,OACT2I,GACC,IAAI5F,GAAkB,CACpBxB,IAAK0K,EAAQ1K,IACb8L,IAAK3Y,KAAK2Y,IACV3e,SACAia,KAAMA,EAAKrK,UACXiO,gBAAiB7X,KAAK6X,mBAG9B,ECuGK,MAAM3D,GAAc,IAlI3B,MACEnG,SAAAA,CACEC,EACAP,GAEA,OAAO,IAAI7B,GAAYoC,EAAMnP,KAAKsI,GAAM+M,GAAY1G,MAAMrG,EAAGsG,MAC1DzB,iBACAV,OAAO3B,GAASA,EAAKG,QAAQhL,GAAsD,OAANA,KAClF,CAEA0O,KAAAA,CAAM/F,EAAyBgG,GAC7B,OAAQhG,EAAKjL,MACX,IAAK,iBACH,OAAOsO,GAAG,MACZ,IAAK,gBACH,OAAO9K,KAAK+Y,cAActR,EAAMgG,GAClC,IAAK,WACH,OAAO3C,GAAG9K,KAAKgZ,SAASvR,IAC1B,IAAK,cACH,OAAOqD,GAAG9K,KAAKiZ,YAAYxR,IAC7B,IAAK,cACH,OAAOzH,KAAK+I,YAAYtB,EAAMgG,GAChC,IAAK,kBACH,OAAOzN,KAAKwI,UAAUf,EAAMgG,GAC9B,IAAK,gBACH,OAAOzN,KAAKyI,cAAchB,EAAMgG,GAEtC,CAEA1E,WAAAA,CAAYtB,EAAyBgG,GACnC,IAAIE,EAAakG,GAAehG,UAAUpG,EAAMgG,GAEhD,GAAmB,OAAfE,EACF,OAAOA,EAGT,IAAIpT,EAAOgT,GAAYC,MAAM/F,EAAKyE,OAAQuB,GACtCtK,EAAOoK,GAAY/D,KAAK/B,EAAKtE,KAAMsK,GAEvC,OAAO1C,GAAOL,IAAInQ,EAAM4I,GAAMkI,SAAQtI,IAAA,IAAExI,EAAM4I,GAAKJ,EAAA,OACjD/C,KAAKmI,YAAYV,EAAK9M,OAAQ8S,GAAOnC,OAClC3Q,GACC,IAAI0T,GAAgB,CAClBxB,IAAKpF,EAAKoF,IACVtS,OACA4I,OACAxI,YAEL,GAEL,CAEAwN,WAAAA,CAAYxN,EAA2B8S,GAGrC,OAFW,IAAI7B,GAAYjR,EAAOA,OAAOkE,KAAKqa,GAAMlZ,KAAKoI,WAAW8Q,EAAGzL,MAGpE7D,UACA0B,OAAO3B,GAAS,IAAI0E,GAAgB,CAAExB,IAAKlS,EAAOkS,IAAKlS,OAAQqP,GAAaL,MACjF,CAEAvB,UAAAA,CAAWuG,EAAyBlB,GAGlC,OAFWA,EAAM0L,WAAWxK,EAAMxT,OAEtBmQ,OAAO2I,GACV,IAAI5F,GAAe,CACxBxB,IAAK8B,EAAM9B,IACXvT,KAAMqV,EAAMrV,KACZ2a,KAAMA,EAAKrK,UACXuI,MAAOxD,EAAMxT,MAAMgX,SAGzB,CAEA1J,aAAAA,CAAc8O,EAA8B9J,GAC1C,OAAO,IAAI6J,GACTC,EACA,IAAIqB,GAAwBrB,EAAQoB,IAAKpB,EH4ExC,SAA2B3I,GAG0B,IAHzB3T,MACjCA,EAAKsd,UACLA,GAC+C3J,EAE/C,OAAI2J,EAAUre,OAAS,KAKde,EAAM6O,QAAQ9K,GAAuB,cAAdA,EAAKxC,OAAsB,EAC7D,CGvFwD4c,CAAmB7B,IACrE9J,GACA+J,aACJ,CAEAhP,SAAAA,CAAUoP,EAAkCnK,GAC1C,OAAOF,GAAYC,MAAMoK,EAAU1L,OAAQuB,GAAOpC,SAASa,GACzD,IAAIoL,GACFM,EACA,IAAIc,GAAoBxM,EAAQ0L,GAChCnK,GACA+J,eAEN,CAEAuB,aAAAA,CAAcM,EAA6B5L,GACzC,IAAIE,EAAauF,GAAgBrF,UAAUwL,EAAQ5L,GAEnD,OAAmB,OAAfE,EACKA,EAGGJ,GAAYC,MAAM6L,EAAOxd,MAAO4R,GAE/BnC,OAAOzP,GACdwd,EAAOtB,SACF,IAAI1J,GAAsB,CAC/BxB,IAAKwM,EAAOxM,IACZyM,KAAMzd,IAGD,IAAIwS,GAAmB,CAC5BxB,IAAKwM,EAAOxM,IACZyD,KAAMzU,KAId,CAEAmd,QAAAA,CAAS1I,GACP,OAAO,IAAIjC,GAAmB,CAC5BxB,IAAKyD,EAAKzD,IACVyD,KAAM,IAAIhE,EAAMiN,kBAAkB,CAAE1M,IAAKyD,EAAKzD,IAAKhR,MAAOyU,EAAKrD,SAEnE,CAEAgM,WAAAA,CAAYO,GACV,OAAO,IAAInL,GAAkB,CAC3BxB,IAAK2M,EAAQ3M,IACbhR,MAAO2d,EAAQlJ,MAEnB,GClIK,MAAMmJ,GACXC,cACAC,aAAe,EAEf9Y,WAAAA,CAAY1F,EAA6B6V,GAAmBhR,KAAnBgR,SAAAA,EACvChR,KAAK0Z,cAAgBve,CACvB,CAEAkZ,oBAAAA,GACE,MAAQ,WAAUrU,KAAK2Z,iBACzB,CAEA,SAAIxH,GACF,OAAOnS,KAAK0Z,aACd,CAEAP,UAAAA,CAAWhe,GACT,IAAIye,EAAW5Z,KAAK0Z,cACpB1Z,KAAK0Z,cAAgBve,EAAMgX,MAE3B,IACE,OAAO+B,GAAYnG,UAAU5S,EAAM8Y,KAAMjU,KAC3C,CAAU,QACRA,KAAK0Z,cAAgBE,CACvB,CACF,ECtBa,MAAMC,GACXC,OACApY,QAERb,WAAAA,CAAWkC,GAAoE,IAAlEgX,EAAarY,EAASsY,EAAUF,GAAgC/W,EAC3E/C,KAAK8Z,OAASA,EACd9Z,KAAK0B,QAAUA,CACjB,CAEAuY,MAAAA,CAAOC,GACL,IAAI9b,EAAM,GAEV,IAAK,IAAIjF,KAAa+gB,EAAQ,GAC5B9b,EAAIiD,KAAKrB,KAAKma,aAAahhB,IAG7B,OAAOiF,CACT,CAEA+b,YAAAA,CAAaC,GACX,IAAIhhB,MAAMC,QAAQ+gB,GAuOhB,OAAOA,EAtOP,OAAQA,EAAO,IACb,KAAKtY,EAAGhG,OACN,MAAO,CAAC,SAAUkE,KAAKma,aAAaC,EAAO,KAC7C,KAAKtY,EAAGC,eACN,MAAO,CAAC,kBAAmB/B,KAAKma,aAAaC,EAAO,KAEtD,KAAKtY,EAAGhH,MACN,MAAO,CACL,QACAkF,KAAKma,aAAaC,EAAO,IACzBpa,KAAKqa,aAAaD,EAAO,IACzBpa,KAAKsa,WAAWF,EAAO,IACvBpa,KAAKua,aAAaH,EAAO,KAG7B,KAAKtY,EAAG6F,UACN,MAAO,CACL,aACAyS,EAAO,GACPpa,KAAKma,aAAaC,EAAO,IACzBA,EAAO,GAAKpa,KAAKma,aAAaC,EAAO,SAAMjd,GAG/C,KAAK2E,EAAGoB,YACN,MAAO,CAAC,eAAgBwT,GAAe0D,EAAO,KAEhD,KAAKtY,EAAGmB,qBACN,MAAO,CAAC,0BAA2ByT,GAAe0D,EAAO,KAE3D,KAAKtY,EAAG4B,aACN,MAAO,CAAC,iBAEV,KAAK5B,EAAG2B,aACN,MAAO,CAAC,iBAEV,KAAK3B,EAAG0D,WACN,MAAO,CAAC,cAAe6R,GAAgB+C,EAAO,IAAKA,EAAO,GAAIA,EAAO,IAEvE,KAAKtY,EAAG0Y,oBACN,MAAO,CAAC,wBAAyBnD,GAAgB+C,EAAO,IAAKA,EAAO,GAAIA,EAAO,IAEjF,KAAKtY,EAAG2D,YACN,MAAO,CACL,eACA4R,GAAgB+C,EAAO,IACvBpa,KAAKma,aAAaC,EAAO,IACzBA,EAAO,IAGX,KAAKtY,EAAG2Y,cACN,MAAO,CACL,iBACApD,GAAgB+C,EAAO,IACvBpa,KAAKma,aAAaC,EAAO,IACzBA,EAAO,IAGX,KAAKtY,EAAGsB,UACN,MAAO,CAAC,cAEV,KAAKtB,EAAG6G,MACN,MAAO,CAAC,QAASyR,EAAO,GAAIpa,KAAKqa,aAAaD,EAAO,KAEvD,KAAKtY,EAAG4Y,WACN,MAAO,CAAC,cAAeN,EAAO,GAAIpa,KAAKma,aAAaC,EAAO,KAE7D,KAAKtY,EAAG6Y,UACN,MAAO,CAAC,aAAcP,EAAO,GAAIpa,KAAKma,aAAaC,EAAO,KAE5D,KAAKtY,EAAG8Y,oBACN,MAAO,CACL,wBACAvD,GAAgB+C,EAAO,IACvBpa,KAAKma,aAAaC,EAAO,IACzBA,EAAO,IAGX,KAAKtY,EAAG+Y,sBACN,MAAO,CACL,0BACAxD,GAAgB+C,EAAO,IACvBpa,KAAKma,aAAaC,EAAO,IACzBA,EAAO,IAGX,KAAKtY,EAAG8G,SACN,MAAO,CAAC,WAAYwR,EAAO,IAE7B,KAAKtY,EAAG3F,QACN,MAAO,CAAC,UAAWie,EAAO,IAE5B,KAAKtY,EAAG/F,SACN,MAAO,CACL,WACAiE,KAAKma,aAAaC,EAAO,IACzBpa,KAAKqa,aAAaD,EAAO,IACzBpa,KAAKsa,WAAWF,EAAO,KAG3B,KAAKtY,EAAG0G,UACN,MAAO,CACL,YACAxI,KAAKma,aAAaC,EAAO,IACzBpa,KAAK8a,oBAAoBV,EAAO,IAChCpa,KAAKsa,WAAWF,EAAO,IACvBpa,KAAKua,aAAaH,EAAO,KAG7B,KAAKtY,EAAGnI,SACN,MAAO,CAAC,YAAaqG,KAAKma,aAAaC,EAAO,KAEhD,KAAKtY,EAAGlI,eACN,MAAO,CAAC,mBAAoBoG,KAAKma,aAAaC,EAAO,KAEvD,KAAKtY,EAAGsH,MACN,MAAO,CACL,QACApJ,KAAKma,aAAaC,EAAO,IACzBpa,KAAK+a,gBAAgBX,EAAO,IAC5Bpa,KAAKqa,aAAaD,EAAO,IACzBpa,KAAKsa,WAAWF,EAAO,KAG3B,KAAKtY,EAAGkE,UACN,MAAO,CAAC,aAEV,KAAKlE,EAAGxH,KACN,MAAO,CACL,OACA0F,KAAKma,aAAaC,EAAO,IACzBpa,KAAKqa,aAAaD,EAAO,IACzBpa,KAAKsa,WAAWF,EAAO,KAG3B,KAAKtY,EAAGpI,OACN,MAAO,CAAC,SAAUsG,KAAKqa,aAAaD,EAAO,KAE7C,KAAKtY,EAAGuE,iBACN,MAAO,CAAC,kBAAmBrG,KAAK8Z,OAAOM,EAAO,IAAKA,EAAO,IAE5D,KAAKtY,EAAGwE,6CACN,MAAO,CACL,+CACAtG,KAAK8Z,OAAOM,EAAO,IACnBA,EAAO,IAGX,KAAKtY,EAAGyE,+BACN,MAAO,CAAC,iCAAkCvG,KAAK8Z,OAAOM,EAAO,IAAKA,EAAO,IAE3E,KAAKtY,EAAG0E,kCACN,MAAO,CAAC,oCAAqCxG,KAAK8Z,OAAOM,EAAO,IAAKA,EAAO,IAE9E,KAAKtY,EAAGkZ,4CACN,MAAO,CAAC,8CAA+Chb,KAAK8Z,OAAOM,EAAO,KAE5E,KAAKtY,EAAG2E,oBACN,MAAO,CAAC,sBAAuBzG,KAAK8Z,OAAOM,EAAO,IAAKA,EAAO,IAEhE,KAAKtY,EAAGgF,uBACN,MAAO,CAAC,yBAA0B9G,KAAK8Z,OAAOM,EAAO,IAAKA,EAAO,IAEnE,KAAKtY,EAAG+E,sBACN,MAAO,CAAC,wBAAyB7G,KAAK8Z,OAAOM,EAAO,IAAKA,EAAO,IAElE,KAAKtY,EAAGsE,UACN,OAAkB,IAAdgU,EAAO,GACF,CAAC,aAAc,OAAQA,EAAO,IAE9B,CAAC,aAAcpa,KAAK0B,QAAQ0Y,EAAO,GAAK,GAAIA,EAAO,IAI9D,KAAKtY,EAAGmZ,iBACN,MAAO,CAAC,sBAAuBb,EAAO,GAAIA,EAAO,IAGnD,KAAKtY,EAAGiD,GACN,MAAO,CACL,KACA/E,KAAKma,aAAaC,EAAO,IACzBpa,KAAKkb,YAAYd,EAAO,IACxBA,EAAO,GAAKpa,KAAKkb,YAAYd,EAAO,IAAM,MAG9C,KAAKtY,EAAG+F,SACN,MAAO,CAAC,aAEV,KAAK/F,EAAG8F,IACN,MAAO,CAAC,OAEV,KAAK9F,EAAGmD,KACN,MAAO,CACL,OACAjF,KAAKma,aAAaC,EAAO,IACzBA,EAAO,GAAKpa,KAAKma,aAAaC,EAAO,IAAM,KAC3Cpa,KAAKkb,YAAYd,EAAO,IACxBA,EAAO,GAAKpa,KAAKkb,YAAYd,EAAO,IAAM,MAG9C,KAAKtY,EAAGgD,KACN,MAAO,CACL,OACA9E,KAAKma,aAAaC,EAAO,IACzBpa,KAAKkb,YAAYd,EAAO,IACxBA,EAAO,GAAKpa,KAAKkb,YAAYd,EAAO,IAAM,MAG9C,KAAKtY,EAAGgG,IACN,MAAO,CAAC,MAAO9H,KAAKqa,aAAaD,EAAO,IAAKpa,KAAKkb,YAAYd,EAAO,KAEvE,KAAKtY,EAAGmG,IACN,MAAO,CAAC,MAAOjI,KAAKqa,aAAaD,EAAO,KAE1C,KAAKtY,EAAGiG,gBACN,MAAO,CAAC,qBAAsB/H,KAAKsa,WAAWF,EAAO,IAAKpa,KAAKkb,YAAYd,EAAO,KAEpF,KAAKtY,EAAGkG,cACN,MAAO,CAAC,oBAAqBhI,KAAKma,aAAaC,EAAO,KAExD,KAAKtY,EAAGoG,gBACN,MAAO,CACL,YACAlI,KAAKma,aAAaC,EAAO,IACzBpa,KAAKqa,aAAaD,EAAO,IACzBpa,KAAKsa,WAAWF,EAAO,IACvBpa,KAAKua,aAAaH,EAAO,KAMnC,CAEQW,eAAAA,CAAgBlf,GACtB,OAAQA,GACN,KAAK2U,EAAahI,UAChB,MAAO,YACT,KAAKgI,EAAaC,OAChB,MAAO,SACT,KAAKD,EAAazU,SAChB,MAAO,WACT,QACE,MAAMgL,EAAUlL,GAEtB,CAEQif,mBAAAA,CAAoBK,GAC1B,OAAgB,OAAZA,EAAyB,KACtBA,EAAQtc,KAAKuc,GAAMpb,KAAKma,aAAaiB,IAC9C,CAEQf,YAAAA,CAAac,GACnB,OAAgB,OAAZA,EAAyB,KACtBA,EAAQtc,KAAKuc,GAAMpb,KAAKma,aAAaiB,IAC9C,CAEQd,UAAAA,CAAWrgB,GACjB,OAAa,OAATA,EAAsB,KAEnBA,EAAK,GAAG+J,QAAO,CAACqX,EAAO5c,EAAK0C,KACjCka,EAAM5c,GAAOuB,KAAKma,aAAalgB,EAAK,GAAGkH,IAChCka,IACNngB,IACL,CAEQqf,YAAAA,CAAa5f,GACnB,OAAe,OAAXA,EAAwB,KAErBA,EAAO,GAAGqJ,QAAO,CAACqX,EAAO5c,EAAK0C,KACnCka,EAAM5c,GAAOuB,KAAKkb,YAAYvgB,EAAO,GAAGwG,IACjCka,IACNngB,IACL,CAEQggB,WAAAA,CAAY/f,GAClB,MAAO,CACLsG,WAAYtG,EAAM,GAAG0D,KAAKC,GAAMkB,KAAKma,aAAarb,KAClDwc,WAAYngB,EAAM,GAEtB,EC1IK,MAAMogB,GAAO,IAvKb,MACLtf,IAAAA,CAAKA,GACH,OAAQA,EAAKO,MACX,IAAK,UACH,OACF,IAAK,UACH,OAAOwD,KAAKxG,QAAQyC,GACtB,IAAK,iBACH,OAAO+D,KAAK6I,eAAe5M,GAC7B,IAAK,2BACH,OAAO+D,KAAK8I,yBAAyB7M,GACvC,IAAK,iBACH,OAAO+D,KAAKiJ,eAAehN,GAC7B,IAAK,MACH,MAAO,CAACuf,EAAYpV,UAAWnK,EAAKoE,QACtC,IAAK,QACH,OAAOL,KAAK/B,MAAMhC,GACpB,IAAK,OACH,MAAO,CAACuf,EAAYpV,UAAW,GACjC,IAAK,OACH,MAAO,CAACnK,EAAKuQ,WAAWA,aAAcvQ,EAAKoE,QAC7C,IAAK,WACH,OAAOL,KAAKrG,SAASsC,GACvB,IAAK,iBACH,OAAO+D,KAAKpG,eAAeqC,GAC7B,IAAK,QACH,OAAO+D,KAAKoJ,MAAMnN,GACpB,IAAK,MACH,OAAO+D,KAAK4H,IAAI3L,GAClB,IAAK,WACH,OAAO+D,KAAK6H,SAAS5L,GACvB,IAAK,wBACH,OAAO+D,KAAKmJ,sBAAsBlN,GACpC,IAAK,gBACH,OAAO+D,KAAKgI,cAAc/L,GAC5B,IAAK,MACH,OAAO+D,KAAKiI,IAAIhM,GAEtB,CAEAzC,OAAAA,CAAOuJ,GAEsF,IAFrFlH,MACNA,GACwBkH,EACxB,YAAc5F,IAAVtB,EACK,CAAC2f,EAAYxV,WAEbnK,CAEX,CAEAqN,OAAAA,GAEA,CAEAvP,QAAAA,CAAQ4Q,GAA4D,IAA3DlK,OAAEA,GAAsBkK,EAC/B,MAAO,CAACiR,EAAY7hB,SAAU,CAAC6hB,EAAYpV,UAAW/F,GACxD,CAEAzG,cAAAA,CAAc6U,GAAwE,IAAvEpO,OAAEA,GAA4BoO,EAC3C,MAAO,CAAC+M,EAAY5hB,eAAgB,CAAC4hB,EAAYpV,UAAW/F,GAC9D,CAEA+I,KAAAA,CAAKwF,GAA6E,IAA5EkC,WAAEA,EAAUH,YAAEA,EAAWxN,KAAEA,GAAiByL,EAChD,MAAO,CACL4M,EAAYpS,MACZmS,GAAKtf,KAAK6U,GACVH,EACA4K,GAAKlS,WAAWlG,EAAKuL,YACrB6M,GAAKjS,eAAenG,EAAKwL,OAE7B,CAEA1Q,KAAAA,CAAKuV,GAKuC,IALtCiI,gBACJA,EAAepb,OACfA,GACwBmT,EAGxB,MAAO,CAACiI,EAAkBD,EAAYP,iBAAmBO,EAAYpV,UAAW/F,EAClF,CAEAqb,eAAAA,CAAejI,GAA4E,IAA3EpT,OAAEA,GAA6BoT,EAC7C,MAAO,CAAC+H,EAAYlV,6CAA8CjG,EACpE,CAEA4I,cAAAA,CAAcyK,GAAqE,IAApEnZ,KAAEA,EAAI0C,KAAEA,GAA0ByW,EAG/C,MAAO,IAFK6H,GAAKtf,KAAK1B,GAEJghB,GAAK9R,KAAKxM,GAC9B,CAEAkM,qBAAAA,CAAqBwK,GAAsE,IAArElH,MAAEA,GAAkCkH,EACxD,MAAO,CAAC6H,EAAY9hB,OAAQ+S,EAAM5N,KAAKsI,GAAMoU,GAAKtf,KAAKkL,KAAIyC,UAC7D,CAEAf,cAAAA,CAAc+K,GAAsE,IAArE1H,OAAEA,EAAM/I,KAAEA,GAA0ByQ,EACjD,MAAO,CAAC4H,EAAYlhB,KAAMihB,GAAKtf,KAAKiQ,MAAYqP,GAAK/R,KAAKrG,GAC5D,CAEA2F,wBAAAA,CAAwB0L,GAGiF,IAHhFlU,IACvBA,EAAG4L,OACHA,GAC6BsI,EAC7B,MAAO,CAACgH,EAAYR,4CAA6C9O,EAAO7L,OAAQ,CAACC,EAAI2M,OACvF,CAEAxD,IAAAA,CAAIiL,GAA8C,IAA7CpG,QAAEA,GAAmBoG,EACxB,OAAO7K,EAAgByE,GAAUqN,GAAWA,EAAO1O,OACrD,CAEAzD,IAAAA,CAAImL,GAAwD,IAAvDjG,WAAEA,EAAUC,MAAEA,GAAiBgG,EAClC,MAAO,CAAC3U,KAAKqJ,WAAWqF,GAAa1O,KAAKsJ,eAAeqF,GAC3D,CAEAtF,UAAAA,CAAUyL,GAAmD,IAAlDnL,KAAEA,GAAsBmL,EACjC,OAAOnL,EAAK9K,KAAK+c,GAAML,GAAKtf,KAAK2f,KAAI3R,gBACvC,CAEAV,aAAAA,CAAawL,GAA8C,IAA7CtW,IAAEA,EAAG5C,MAAEA,GAA0BkZ,EAC7C,MAAO,CAACtW,EAAIwO,MAAOsO,GAAKtf,KAAKJ,GAC/B,CAEAyN,cAAAA,CAAc0L,GAA+D,IAA5DtW,QAASmQ,GAA2BmG,EAC/CrL,EAAOkF,EAAMjF,UAEjB,GAAItM,EAAeqM,GAAO,CACxB,IAAIkS,EAAkB,GAClB7a,EAAkC,GAEtC,IAAK,IAAI8a,KAAQnS,EAAM,CACrB,IAAKrQ,EAAMuC,GAAS0f,GAAKhS,cAAcuS,GACvCD,EAAMxa,KAAK/H,GACX0H,EAAOK,KAAKxF,EACd,CAKA,OAHAkgB,EAAmBF,GACnBE,EAAmB/a,GAEZ,CAAC6a,EAAO7a,EACjB,CACE,OAAO,IAEX,CAEA4G,GAAAA,CAAGqN,GAAiD,IAAhDpZ,MAAEA,GAAgBoZ,EACpB,MAAO,CAACuG,EAAY5T,IAAK2T,GAAKtf,KAAKJ,GACrC,CAEAgM,QAAAA,CAAQqN,GAA8E,IAA7EzC,UAAEA,EAASC,OAAEA,EAAMC,MAAEA,GAAqBuC,EAC7CjZ,EAAO,CAACuf,EAAY3T,SAAU0T,GAAKtf,KAAKwW,GAAY8I,GAAKtf,KAAKyW,IAMlE,OAJIC,GACF1W,EAAKoF,KAAKka,GAAKtf,KAAK0W,IAGf1W,CACT,CAEA+L,aAAAA,CAAamN,GAAoE,IAAnE7b,KAAEA,GAAyB6b,EACvC,MAAO,CAACqG,EAAYxT,cAAeuT,GAAKtf,KAAK3C,GAC/C,CAEA2O,GAAAA,CAAGoN,GAAsD,IAArD3G,WAAEA,GAAqB2G,EACzB,MAAO,CAACmG,EAAYvT,IAAKjI,KAAKqJ,WAAWqF,GAC3C,GCzJF,MAAMsN,GACJnb,WAAAA,CAAoBY,GAA0BzB,KAA1ByB,WAAAA,CAA2B,CAE/CmI,OAAAA,GACE,OAAO5J,KAAKyB,UACd,EA4NK,MAAMwa,GAAU,IAzNhB,MACLtS,IAAAA,CAAKlI,GACH,IAAIrD,EAA8B,GAElC,IAAK,IAAIjF,KAAasI,EAAY,CAChC,IAAI3E,EAASmf,GAAQC,QAAQ/iB,GAEzB2D,GAAUA,aAAkBkf,GAC9B5d,EAAIiD,QAAQvE,EAAO8M,WAEnBxL,EAAIiD,KAAKvE,EAEb,CAEA,OAAOsB,CACT,CAEA8d,OAAAA,CAAQC,GAKN,OAJI/U,IACFgV,EAAaC,IAAK,WAAWF,GAGxBnc,KAAKsc,aAAaH,EAC3B,CAEQG,YAAAA,CAAaH,GACnB,OAAQA,EAAK3f,MACX,IAAK,WACH,MAAO,CAACgf,EAAY5S,SAAUuT,EAAKhK,MAAMoK,gBAC3C,IAAK,gBACH,OAAOvc,KAAKuI,cAAc4T,GAC5B,IAAK,iBACH,OAAOnc,KAAKsI,eAAe6T,GAC7B,IAAK,oBACH,OAAOnc,KAAKqI,kBAAkB8T,GAChC,IAAK,QACH,OAAOnc,KAAK2I,MAAMwT,GACpB,IAAK,YACH,OAAOnc,KAAKwI,UAAU2T,GACxB,IAAK,gBACH,OAAOnc,KAAKyI,cAAc0T,GAC5B,IAAK,YACH,OAAOnc,KAAK2H,UAAUwU,GACxB,IAAK,cACH,OAAOnc,KAAK+I,YAAYoT,GAC1B,IAAK,KACH,OAAOnc,KAAK+E,GAAGoX,GACjB,IAAK,OACH,OAAOnc,KAAKiF,KAAKkX,GACnB,IAAK,OACH,OAAOnc,KAAK8E,KAAKqX,GACnB,IAAK,MACH,OAAOnc,KAAK8H,IAAIqU,GAClB,IAAK,kBACH,OAAOnc,KAAK+H,gBAAgBoU,GAC9B,IAAK,kBACH,OAAOnc,KAAKkI,gBAAgBiU,GAC9B,QACE,OAAOpV,EAAUoV,GAEvB,CAEAxT,KAAAA,CAAK5F,GAA6D,IAA5DuQ,GAAEA,EAAE5E,WAAEA,GAAuB3L,EACjC,MAAO,CAACyY,EAAY7S,MAAO2K,EAAIiI,GAAKlS,WAAWqF,GACjD,CAEA/G,SAAAA,CAAS4C,GAK0C,IALzCuJ,KACRA,EAAIC,aACJA,EAAYC,YACZA,EAAW7Y,MACXA,GACcoP,EACViS,EAAYP,GAAQ7T,WAAWjN,GAAO,GAEtCshB,EAAkBlB,GAAKtf,KAAK+X,GAC5B0I,EAAmBnB,GAAKtf,KAAK8X,GAEjC,YAAyB5W,IAArBuf,EACK,CAAClB,EAAY7T,UAAW6U,EAAW1I,EAAM2I,GAEzC,CAACjB,EAAY7T,UAAW6U,EAAW1I,EAAM2I,EAAiBC,EAErE,CAEA3T,WAAAA,CAAW0F,GAAuE,IAAtElU,KAAEA,EAAI4I,KAAEA,EAAIxI,OAAEA,GAAyB8T,EACjD,MAAO,CAAC+M,EAAY1gB,MAAOygB,GAAKtf,KAAK1B,MAAUghB,GAAK/R,KAAKrG,GAAO8Y,GAAQ9T,YAAYxN,GACtF,CAEA0N,iBAAAA,CAAiBuG,GAAwE,IAAvE0K,KAAEA,GAA6B1K,EAC/C,MAAO,CAAC4M,EAAYzZ,eAAgBwZ,GAAKtf,KAAKqd,GAChD,CAEAhR,cAAAA,CAAckL,GAA6D,IAA5DlD,KAAEA,GAA0BkD,EACzC,MAAO,CAACgI,EAAY1f,OAAQyf,GAAKtf,KAAKqU,GACxC,CAEA/H,aAAAA,CAAakL,GAA8D,IAA7D5X,MAAEA,GAA0B4X,EACxC,MAAO,CAAC+H,EAAYrf,QAASN,EAAMoR,MACrC,CAEAxE,aAAAA,CAAaiL,GAA4E,IAA3EiF,IAAEA,EAAG3e,OAAEA,EAAMia,KAAEA,EAAI4D,gBAAEA,GAAoCnE,EACjEvN,EAAK0R,EAAkB2D,EAAYvY,qBAAuBuY,EAAYtY,YAC1E,OAAO,IAAI8Y,GAAmE,CAC5E,CAAC7V,GR9EwBwQ,EQ8ELgC,EAAI1L,MR7ErBmJ,GAAkBO,IAAYA,OQ8E9BsF,GAAQvT,kBAAkB1O,GAAQ4P,UACrC,CAAC4R,EAAY/X,iBACVwY,GAAQtS,KAAKsK,GAChB,CAACuH,EAAY9X,gBRlFZ,IAAwBiT,CQoF7B,CAEAnO,SAAAA,CAASmL,GAAgF,IAA/EgF,IAAEA,EAAG3e,OAAEA,EAAMmJ,KAAEA,EAAIxI,OAAEA,GAAuBgZ,EAChDgJ,EAAUpB,GAAKtf,KAAK0c,GACpBiE,EAAiBX,GAAQvT,kBAAkB1O,GAC3C6iB,EAAYtB,GAAKjS,eAAenG,GAEhC2Z,EAAkBb,GAAQ9T,YAAYxN,GAE1C,MAAO,CACL6gB,EAAYhT,UACZmU,EACAC,EAAe3S,iBACf4S,EACAC,EAEJ,CAEApU,iBAAAA,CAAiBkL,GAA6E,IAA5EK,KAAEA,GAA6BL,EAC/C,OAAOK,EAAKpV,KAAK2X,GAAMyF,GAAQc,iBAAiBvG,IAClD,CAEAuG,gBAAAA,CAAiBtN,GACf,OAAQA,EAAMjT,MACZ,IAAK,YACH,MAAO,CAACgf,EAAYpY,UAAWqM,EAAMpP,QACvC,IAAK,cACH,MAAO,CAAC2c,GAAcvN,EAAMpV,SAAU4iB,GAAYxN,IACpD,IAAK,aACH,MAAO,CAACyN,GAAazN,EAAMpV,SAAU8iB,GAAW1N,IAClD,IAAK,WACH,MAAO,CAAC+L,EAAYzf,SAAUwf,GAAKtf,KAAKwT,EAAMvD,WAAYqP,GAAK/R,KAAKiG,EAAMtM,OAEhF,CAEAgF,WAAAA,CAAWqM,GAAsD,IAArD7Z,OAAEA,GAAyB6Z,EACjCqH,EAAkB,GAClBuB,EAAuD,GAE3D,IAAK,IAAIjiB,KAASR,EAAOiP,UAAW,CAClC,IAAKtQ,EAAM+jB,GAAmBpB,GAAQ7T,WAAWjN,GAEjD0gB,EAAMxa,KAAK/H,GACX8jB,EAAiB/b,KAAKgc,EACxB,CAEA,OAAOxB,EAAM3hB,OAAS,EAAI,CAAC2hB,EAAOuB,GAAoB,IACxD,CAEAhV,UAAAA,CAAUsM,GAAoE,IAAnEpb,KAAEA,EAAI2a,KAAEA,EAAI9B,MAAEA,GAAuBuC,EAC1C4I,EAAYhkB,EAAK2T,MAIrB,MAHkB,YAAdqQ,IACFA,EAAY,QAEP,CAACA,EAAW,CAACrB,GAAQtS,KAAKsK,GAAO9B,EAAMoL,OAChD,CAEAxY,EAAAA,CAAE4P,GAAkE,IAAjElC,UAAEA,EAAStX,MAAEA,EAAK0J,QAAEA,GAAiB8P,EACtC,MAAO,CACL6G,EAAYzW,GACZwW,GAAKtf,KAAKwW,GACVwJ,GAAQ7T,WAAWjN,GAAO,GAC1B0J,EAAUoX,GAAQ7T,WAAWvD,GAAS,GAAK,KAE/C,CAEAI,IAAAA,CAAI6P,GAAuE,IAAtEjZ,MAAEA,EAAK4C,IAAEA,EAAGtD,MAAEA,EAAK0J,QAAEA,GAAmBiQ,EAC3C,MAAO,CACL0G,EAAYvW,KACZsW,GAAKtf,KAAKJ,GACV4C,EAAM8c,GAAKtf,KAAKwC,GAAO,KACvBwd,GAAQ7T,WAAWjN,GAAO,GAC1B0J,EAAUoX,GAAQ7T,WAAWvD,GAAS,GAAK,KAE/C,CAEAC,IAAAA,CAAIiQ,GAAkE,IAAjElZ,MAAEA,EAAKV,MAAEA,EAAK0J,QAAEA,GAAmBkQ,EACtC,MAAO,CACLyG,EAAY1W,KACZyW,GAAKtf,KAAKJ,GACVogB,GAAQ7T,WAAWjN,GAAO,GAC1B0J,EAAUoX,GAAQ7T,WAAWvD,GAAS,GAAK,KAE/C,CAEAiD,GAAAA,CAAGkN,GAA4D,IAA3DtG,WAAEA,EAAUvT,MAAEA,GAAgB6Z,EAChC,MAAO,CAACwG,EAAY1T,IAAKyT,GAAKlS,WAAWqF,GAAauN,GAAQ7T,WAAWjN,GAAO,GAClF,CAEA4M,eAAAA,CAAekN,GAA+E,IAA9EtG,MAAEA,EAAKxT,MAAEA,GAA4B8Z,EACnD,MAAO,CAACuG,EAAYzT,gBAAiBwT,GAAKjS,eAAeqF,GAAQsN,GAAQ7T,WAAWjN,GAAO,GAC7F,CAEA+M,eAAAA,CAAegN,GAIgD,IAJ/CpE,WACdA,EAAU3N,KACVA,EAAIxI,OACJA,GACoBua,EACpB,MAAO,CACLsG,EAAYtT,gBACZqT,GAAKtf,KAAK6U,GACVyK,GAAKlS,WAAWlG,EAAKuL,YACrB6M,GAAKjS,eAAenG,EAAKwL,OACzBhU,EAASshB,GAAQ9T,YAAYxN,GAAU,KAE3C,GAOF,SAASwiB,GAAUhI,GAA6D,IAA5D7b,KAAEA,EAAIuC,MAAEA,EAAKyJ,UAAEA,GAA2B6P,EACxD/W,EAAsB,CAAC+Y,GAAgB7d,EAAK2T,OAAQpR,EAAMoR,OAM9D,OAJI3H,GACFlH,EAAIiD,KAAKiE,GAGJlH,CACT,CAQA,SAAS6e,GAAW5H,GAA+D,IAA9D/b,KAAEA,EAAIuC,MAAEA,EAAKyJ,UAAEA,GAA4B+P,EAC1DjX,EAAuB,CAAC+Y,GAAgB7d,EAAK2T,OAAQsO,GAAKtf,KAAKJ,IAMnE,OAJIyJ,GACFlH,EAAIiD,KAAKiE,GAGJlH,CACT,CAGA,SAAS8e,GAAa7iB,GACpB,OAAIA,EAAKud,UACA4D,EAAYhB,oBAEZgB,EAAYhW,UAEvB,CAEA,SAASwX,GACP3iB,GAMA,OAAIA,EAAKud,UACAvd,EAAK0d,SAAWyD,EAAYX,sBAAwBW,EAAYf,cAEhEpgB,EAAK0d,SAAWyD,EAAYZ,oBAAsBY,EAAY/V,WAEzE,CC3Qa+X,MAAAA,GAA0B,MACrC,MAAMC,EACc,iBAAXC,QAAiD,mBAAnBA,OAAOC,QACxCD,OAAOC,QACPC,WAAWD,QAEjB,GAAIF,EACF,IACE,MAAMI,EAASJ,EAAI,UAEbK,EAAsB3K,IAC1B,MAAMlZ,EAAO4jB,EAAOE,WAAW,QAG/B,OAFA9jB,EAAK+jB,OAAO7K,EAAK,QAEVlZ,EAAKgkB,OAAO,UAAUC,UAAU,EAAG,EAAE,EAK9C,OAFAJ,EAAK,QAEEA,CACT,CAAE,MACA,CAIJ,OAAO,WACL,OAAO,KAEV,EA5BsC,GA8BjCK,GAAoC,CACxCpH,GAAIyG,IAiBC,SAASY,GACdna,GAEwD,IADxDoa,EAA8DnhB,UAAAhD,OAAA,QAAAiD,IAAAD,UAAA,GAAAA,UAAA,GAAGihB,GAEjE,MAAMG,EAAS,IAAInL,EAAIoL,OAAOta,GAAU,GAAIoa,EAAQG,MAAMC,aACnDC,EAAK/d,GAAUge,EAAUL,EAAQ,CAAEM,aAAcA,KAAM,KAAUP,IAClEljB,ECpCO,SACbmjB,EACAO,EACA7N,GAGA,IAAIvD,EAAQ,IAAIgM,GAAmBoF,EAAKC,MAAO9N,GAE3C5J,KACFgV,EAAa2C,eAAgB,mBAC7B3C,EAAaC,IAAI,UAAWwC,EAAKC,OACjC1C,EAAaC,IAAI,SAAUiC,GAC3BlC,EAAa4C,YAGf,IAAI/K,EAAOC,GAAYnG,UAAU8Q,EAAK5K,KAAMxG,GAU5C,OARIrG,KACE6M,EAAKhJ,KACPmR,EAAaC,IAAI,gBAAiBpI,EAAKpY,OAEvCugB,EAAaC,IAAI,kBAAmBpI,EAAKvI,SAItCuI,EAAK3I,OACT2I,GAAS,IAAI5F,GAAa,CAAExB,IAAKgS,EAAKhS,IAAKsF,MAAO0M,EAAKC,MAAO7K,KAAMA,EAAKrK,aAE9E,CDQgBqV,CAAMX,EAAQI,EAAKL,EAAQa,aAAc,GAAO5T,OAAO6T,GE3EhE,SAAeC,GACpB,IAAI3d,EAAawa,GAAQtS,KAAKyV,EAASnL,MACnC9B,EAAQiN,EAASjN,MACjBhX,EAA4C,CAC9CsG,EACA0Q,EAAMzQ,QACNyQ,EAAMkN,QACNlN,EAAM2H,QAGR,GAAI1S,GAAkB,CACpB,IAAIkY,EAAQ,IAAIzF,GAAmB1e,GACnCihB,EAAaC,IACV,MACD5a,EAAW5C,KAAKC,GAAMwgB,EAAMnF,aAAarb,KAE7C,CAEA,OAAO3D,CACT,CFyDWokB,CAAMJ,KAOf,GAJI/X,IACFgV,EAAaC,IAAK,cAAclhB,GAG9BA,EAAM8P,KACR,MAAO,CAAC9P,EAAMU,MAAO8E,GAErB,MAAMxF,EAAMuQ,MAEhB,CAIA,MAAM8T,GAAoB,uCAgBnB,SAASC,GACdnB,GAEoB,IADpBD,EAA8DnhB,UAAAhD,OAAA,QAAAiD,IAAAD,UAAA,GAAAA,UAAA,GAAGihB,GAEjE,MAAOhjB,EAAOukB,GAActB,GAAeE,EAAQD,GAE7CI,EAAaJ,EAAQG,MAAMC,WAC3BX,EAAOO,EAAQtH,IAAMyG,GACrBmC,EAAYjkB,KAAKC,UAAUR,GAC3BykB,EAAsD,CAC1D7I,GAAI+G,EAAKpiB,KAAKC,UAAU0iB,EAAQG,MAAQmB,GACxCxkB,MAAOwkB,EACPlB,WAAYA,GAAc,4BAG1BtM,MAAOqN,GACPK,aAAcxB,EAAQa,aAAc,GAGZ,IAAtBQ,EAAWxlB,eACN0lB,EAAmBzN,MAI5B,IAAI2N,EAAcpkB,KAAKC,UAAUikB,GAEjC,GAAIF,EAAWxlB,OAAS,EAAG,CACzB,MAAM6lB,EAAW,QAAOL,EAAWxS,KAAK,QAExC4S,EAAcA,EAAYE,QAAS,IAAGR,MAAsBO,EAC9D,CAEA,OAAOD,CACT"}
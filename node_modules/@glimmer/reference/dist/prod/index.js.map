{"version":3,"file":"index.js","sources":["../../lib/reference.ts","../../lib/iterable.ts"],"sourcesContent":["import { getProp, setProp } from '@glimmer/global-context';\nimport type {\n  ComputeReference,\n  ConstantReference,\n  InvokableReference,\n  Nullable,\n  Reference,\n  ReferenceSymbol,\n  ReferenceType,\n  UnboundReference,\n} from \"@glimmer/interfaces\";\nimport { expect, isDict } from '@glimmer/util';\nimport {\n  CONSTANT_TAG,\n  consumeTag,\n  INITIAL,\n  type Revision,\n  type Tag,\n  track,\n  validateTag,\n  valueForTag,\n} from '@glimmer/validator';\n\nexport const REFERENCE: ReferenceSymbol = Symbol('REFERENCE') as ReferenceSymbol;\n\nconst CONSTANT: ConstantReference = 0;\nconst COMPUTE: ComputeReference = 1;\nconst UNBOUND: UnboundReference = 2;\nconst INVOKABLE: InvokableReference = 3;\n\nexport type { Reference as default };\nexport type { Reference };\n\n//////////\n\nexport interface ReferenceEnvironment {\n  getProp(obj: unknown, path: string): unknown;\n  setProp(obj: unknown, path: string, value: unknown): unknown;\n}\n\nclass ReferenceImpl<T = unknown> implements Reference<T> {\n  [REFERENCE]: ReferenceType;\n  public tag: Nullable<Tag> = null;\n  public lastRevision: Revision = INITIAL;\n  public lastValue?: T;\n\n  public children: Nullable<Map<string | Reference, Reference>> = null;\n\n  public compute: Nullable<() => T> = null;\n  public update: Nullable<(val: T) => void> = null;\n\n  public debugLabel?: string;\n\n  constructor(type: ReferenceType) {\n    this[REFERENCE] = type;\n  }\n}\n\nexport function createPrimitiveRef<T>(value: T): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.tag = CONSTANT_TAG;\n  ref.lastValue = value;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = String(value);\n  }\n\n  return ref;\n}\n\nexport const UNDEFINED_REFERENCE = createPrimitiveRef(undefined);\nexport const NULL_REFERENCE = createPrimitiveRef(null);\nexport const TRUE_REFERENCE = createPrimitiveRef(true as const);\nexport const FALSE_REFERENCE = createPrimitiveRef(false as const);\n\nexport function createConstRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(CONSTANT);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createUnboundRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createComputeRef<T = unknown>(\n  compute: () => T,\n  update: Nullable<(value: T) => void> = null,\n  debugLabel: false | string = 'unknown'\n): Reference<T> {\n  const ref = new ReferenceImpl<T>(COMPUTE);\n\n  ref.compute = compute;\n  ref.update = update;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = `(result of a \\`${debugLabel}\\` helper)`;\n  }\n\n  return ref;\n}\n\nexport function createReadOnlyRef(ref: Reference): Reference {\n  if (!isUpdatableRef(ref)) return ref;\n\n  return createComputeRef(() => valueForRef(ref), null, ref.debugLabel);\n}\n\nexport function isInvokableRef(ref: Reference) {\n  return ref[REFERENCE] === INVOKABLE;\n}\n\nexport function createInvokableRef(inner: Reference): Reference {\n  const ref = createComputeRef(\n    () => valueForRef(inner),\n    (value) => updateRef(inner, value)\n  );\n  ref.debugLabel = inner.debugLabel;\n  ref[REFERENCE] = INVOKABLE;\n\n  return ref;\n}\n\nexport function isConstRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.tag === CONSTANT_TAG;\n}\n\nexport function isUpdatableRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.update !== null;\n}\n\nexport function valueForRef<T>(_ref: Reference<T>): T {\n  const ref = _ref as ReferenceImpl<T>;\n\n  let { tag } = ref;\n\n  if (tag === CONSTANT_TAG) {\n    return ref.lastValue as T;\n  }\n\n  const { lastRevision } = ref;\n  let lastValue;\n\n  if (tag === null || !validateTag(tag, lastRevision)) {\n    const { compute } = ref;\n\n    const newTag = track(() => {\n      lastValue = ref.lastValue = compute!();\n    }, import.meta.env.DEV && ref.debugLabel);\n\n    tag = ref.tag = newTag;\n\n    ref.lastRevision = valueForTag(newTag);\n  } else {\n    lastValue = ref.lastValue;\n  }\n\n  consumeTag(tag);\n\n  return lastValue as T;\n}\n\nexport function updateRef(_ref: Reference, value: unknown) {\n  const ref = _ref as ReferenceImpl;\n\n  const update = expect(ref.update, 'called update on a non-updatable reference');\n\n  update(value);\n}\n\nexport function childRefFor(_parentRef: Reference, path: string): Reference {\n  const parentRef = _parentRef as ReferenceImpl;\n\n  const type = parentRef[REFERENCE];\n\n  let children = parentRef.children;\n  let child: Reference;\n\n  if (children === null) {\n    children = parentRef.children = new Map();\n  } else {\n    child = children.get(path)!;\n\n    if (child !== undefined) {\n      return child;\n    }\n  }\n\n  if (type === UNBOUND) {\n    const parent = valueForRef(parentRef);\n\n    if (isDict(parent)) {\n      child = createUnboundRef(\n        (parent as Record<string, unknown>)[path],\n        import.meta.env.DEV && `${parentRef.debugLabel}.${path}`\n      );\n    } else {\n      child = UNDEFINED_REFERENCE;\n    }\n  } else {\n    child = createComputeRef(\n      () => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return getProp(parent, path);\n        }\n      },\n      (val) => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return setProp(parent, path, val);\n        }\n      }\n    );\n\n    if (import.meta.env.DEV) {\n      child.debugLabel = `${parentRef.debugLabel}.${path}`;\n    }\n  }\n\n  children.set(path, child);\n\n  return child;\n}\n\nexport function childRefFromParts(root: Reference, parts: string[]): Reference {\n  let reference = root;\n\n  for (const part of parts) {\n    reference = childRefFor(reference, part);\n  }\n\n  return reference;\n}\n\nexport let createDebugAliasRef: undefined | ((debugLabel: string, inner: Reference) => Reference);\n\nif (import.meta.env.DEV) {\n  createDebugAliasRef = (debugLabel: string, inner: Reference) => {\n    const update = isUpdatableRef(inner) ? (value: unknown) => updateRef(inner, value) : null;\n    const ref = createComputeRef(() => valueForRef(inner), update);\n\n    ref[REFERENCE] = inner[REFERENCE];\n\n    ref.debugLabel = debugLabel;\n\n    return ref;\n  };\n}\n","import { getPath, toIterator } from '@glimmer/global-context';\nimport type { Dict, Nullable } from \"@glimmer/interfaces\";\nimport { EMPTY_ARRAY, isObject } from '@glimmer/util';\nimport { consumeTag, createTag, dirtyTag } from '@glimmer/validator';\n\nimport {\n  createComputeRef,\n  type Reference,\n  type ReferenceEnvironment,\n  valueForRef,\n} from './reference';\n\nexport interface IterationItem<T, U> {\n  key: unknown;\n  value: T;\n  memo: U;\n}\n\nexport interface AbstractIterator<T, U, V extends IterationItem<T, U>> {\n  isEmpty(): boolean;\n  next(): Nullable<V>;\n}\n\nexport type OpaqueIterationItem = IterationItem<unknown, unknown>;\nexport type OpaqueIterator = AbstractIterator<unknown, unknown, OpaqueIterationItem>;\n\nexport interface IteratorDelegate {\n  isEmpty(): boolean;\n  next(): { value: unknown; memo: unknown } | null;\n}\n\nexport interface IteratorReferenceEnvironment extends ReferenceEnvironment {\n  getPath(obj: unknown, path: string): unknown;\n  toIterator(obj: unknown): Nullable<IteratorDelegate>;\n}\n\ntype KeyFor = (item: unknown, index: unknown) => unknown;\n\nconst NULL_IDENTITY = {};\n\nconst KEY: KeyFor = (_, index) => index;\nconst INDEX: KeyFor = (_, index) => String(index);\nconst IDENTITY: KeyFor = (item) => {\n  if (item === null) {\n    // Returning null as an identity will cause failures since the iterator\n    // can't tell that it's actually supposed to be null\n    return NULL_IDENTITY;\n  }\n\n  return item;\n};\n\nfunction keyForPath(path: string): KeyFor {\n  if (import.meta.env.DEV && path[0] === '@') {\n    throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);\n  }\n  return uniqueKeyFor((item) => getPath(item as object, path));\n}\n\nfunction makeKeyFor(key: string) {\n  switch (key) {\n    case '@key':\n      return uniqueKeyFor(KEY);\n    case '@index':\n      return uniqueKeyFor(INDEX);\n    case '@identity':\n      return uniqueKeyFor(IDENTITY);\n    default:\n      return keyForPath(key);\n  }\n}\n\nclass WeakMapWithPrimitives<T> {\n  private _weakMap?: WeakMap<object, T>;\n  private _primitiveMap?: Map<unknown, T>;\n\n  private get weakMap() {\n    if (this._weakMap === undefined) {\n      this._weakMap = new WeakMap();\n    }\n\n    return this._weakMap;\n  }\n\n  private get primitiveMap() {\n    if (this._primitiveMap === undefined) {\n      this._primitiveMap = new Map();\n    }\n\n    return this._primitiveMap;\n  }\n\n  set(key: unknown, value: T) {\n    if (isObject(key)) {\n      this.weakMap.set(key, value);\n    } else {\n      this.primitiveMap.set(key, value);\n    }\n  }\n\n  get(key: unknown): T | undefined {\n    if (isObject(key)) {\n      return this.weakMap.get(key);\n    } else {\n      return this.primitiveMap.get(key);\n    }\n  }\n}\n\nconst IDENTITIES = new WeakMapWithPrimitives<object[]>();\n\nfunction identityForNthOccurence(value: any, count: number) {\n  let identities = IDENTITIES.get(value);\n\n  if (identities === undefined) {\n    identities = [];\n    IDENTITIES.set(value, identities);\n  }\n\n  let identity = identities[count];\n\n  if (identity === undefined) {\n    identity = { value, count };\n    identities[count] = identity;\n  }\n\n  return identity;\n}\n\n/**\n * When iterating over a list, it's possible that an item with the same unique\n * key could be encountered twice:\n *\n * ```js\n * let arr = ['same', 'different', 'same', 'same'];\n * ```\n *\n * In general, we want to treat these items as _unique within the list_. To do\n * this, we track the occurences of every item as we iterate the list, and when\n * an item occurs more than once, we generate a new unique key just for that\n * item, and that occurence within the list. The next time we iterate the list,\n * and encounter an item for the nth time, we can get the _same_ key, and let\n * Glimmer know that it should reuse the DOM for the previous nth occurence.\n */\nfunction uniqueKeyFor(keyFor: KeyFor) {\n  let seen = new WeakMapWithPrimitives<number>();\n\n  return (value: unknown, memo: unknown) => {\n    let key = keyFor(value, memo);\n    let count = seen.get(key) || 0;\n\n    seen.set(key, count + 1);\n\n    if (count === 0) {\n      return key;\n    }\n\n    return identityForNthOccurence(key, count);\n  };\n}\n\nexport function createIteratorRef(listRef: Reference, key: string) {\n  return createComputeRef(() => {\n    let iterable = valueForRef(listRef) as { [Symbol.iterator]: any } | null | false;\n\n    let keyFor = makeKeyFor(key);\n\n    if (Array.isArray(iterable)) {\n      return new ArrayIterator(iterable, keyFor);\n    }\n\n    let maybeIterator = toIterator(iterable);\n\n    if (maybeIterator === null) {\n      return new ArrayIterator(EMPTY_ARRAY, () => null);\n    }\n\n    return new IteratorWrapper(maybeIterator, keyFor);\n  });\n}\n\nexport function createIteratorItemRef(_value: unknown) {\n  let value = _value;\n  let tag = createTag();\n\n  return createComputeRef(\n    () => {\n      consumeTag(tag);\n      return value;\n    },\n    (newValue) => {\n      if (value !== newValue) {\n        value = newValue;\n        dirtyTag(tag);\n      }\n    }\n  );\n}\n\nclass IteratorWrapper implements OpaqueIterator {\n  constructor(private inner: IteratorDelegate, private keyFor: KeyFor) {}\n\n  isEmpty() {\n    return this.inner.isEmpty();\n  }\n\n  next() {\n    let nextValue = this.inner.next() as OpaqueIterationItem;\n\n    if (nextValue !== null) {\n      nextValue.key = this.keyFor(nextValue.value, nextValue.memo);\n    }\n\n    return nextValue;\n  }\n}\n\nclass ArrayIterator implements OpaqueIterator {\n  private current: { kind: 'empty' } | { kind: 'first'; value: unknown } | { kind: 'progress' };\n  private pos = 0;\n\n  constructor(private iterator: unknown[] | readonly unknown[], private keyFor: KeyFor) {\n    if (iterator.length === 0) {\n      this.current = { kind: 'empty' };\n    } else {\n      this.current = { kind: 'first', value: iterator[this.pos] };\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.current.kind === 'empty';\n  }\n\n  next(): Nullable<IterationItem<unknown, number>> {\n    let value: unknown;\n\n    let current = this.current;\n    if (current.kind === 'first') {\n      this.current = { kind: 'progress' };\n      value = current.value;\n    } else if (this.pos >= this.iterator.length - 1) {\n      return null;\n    } else {\n      value = this.iterator[++this.pos];\n    }\n\n    let { keyFor } = this;\n\n    let key = keyFor(value as Dict, this.pos);\n    let memo = this.pos;\n\n    return { key, value, memo };\n  }\n}\n"],"names":["REFERENCE","Symbol","COMPUTE","UNBOUND","ReferenceImpl","tag","lastRevision","INITIAL","lastValue","children","compute","update","debugLabel","constructor","type","this","createPrimitiveRef","value","ref","CONSTANT_TAG","String","UNDEFINED_REFERENCE","undefined","NULL_REFERENCE","TRUE_REFERENCE","FALSE_REFERENCE","createConstRef","createUnboundRef","createComputeRef","arguments","length","createReadOnlyRef","isUpdatableRef","valueForRef","isInvokableRef","createInvokableRef","inner","updateRef","isConstRef","_ref","validateTag","newTag","track","valueForTag","consumeTag","expect","childRefFor","_parentRef","path","parentRef","child","Map","get","parent","isDict","getProp","val","setProp","set","childRefFromParts","root","parts","reference","part","createDebugAliasRef","NULL_IDENTITY","KEY","_","index","INDEX","IDENTITY","item","makeKeyFor","key","uniqueKeyFor","Error","getPath","keyForPath","WeakMapWithPrimitives","_weakMap","_primitiveMap","weakMap","WeakMap","primitiveMap","isObject","IDENTITIES","keyFor","seen","memo","count","identities","identity","identityForNthOccurence","createIteratorRef","listRef","iterable","Array","isArray","ArrayIterator","maybeIterator","toIterator","EMPTY_ARRAY","IteratorWrapper","createIteratorItemRef","_value","createTag","newValue","dirtyTag","isEmpty","next","nextValue","current","pos","iterator","kind"],"mappings":"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"}
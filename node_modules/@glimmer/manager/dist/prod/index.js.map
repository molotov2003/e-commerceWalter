{"version":3,"file":"index.js","sources":["../../lib/util/args-proxy.ts","../../lib/util/capabilities.ts","../../lib/public/helper.ts","../../lib/internal/defaults.ts","../../lib/internal/api.ts","../../lib/public/component.ts","../../lib/public/modifier.ts","../../lib/public/api.ts","../../lib/public/template.ts"],"sourcesContent":["import type {\n  Arguments,\n  CapturedArguments,\n  CapturedNamedArguments,\n  CapturedPositionalArguments,\n} from '@glimmer/interfaces';\nimport { valueForRef } from '@glimmer/reference';\nimport { type Tag, track } from '@glimmer/validator';\n\nconst CUSTOM_TAG_FOR = new WeakMap<object, (obj: object, key: string) => Tag>();\n\nexport function getCustomTagFor(obj: object): ((obj: object, key: string) => Tag) | undefined {\n  return CUSTOM_TAG_FOR.get(obj);\n}\n\nexport function setCustomTagFor(obj: object, customTagFn: (obj: object, key: string) => Tag) {\n  CUSTOM_TAG_FOR.set(obj, customTagFn);\n}\n\nfunction convertToInt(prop: number | string | symbol): number | null {\n  if (typeof prop === 'symbol') return null;\n\n  const num = Number(prop);\n\n  if (isNaN(num)) return null;\n\n  return num % 1 === 0 ? num : null;\n}\n\nfunction tagForNamedArg(namedArgs: CapturedNamedArguments, key: string): Tag {\n  return track(() => {\n    if (key in namedArgs) {\n      valueForRef(namedArgs[key]!);\n    }\n  });\n}\n\nfunction tagForPositionalArg(positionalArgs: CapturedPositionalArguments, key: string): Tag {\n  return track(() => {\n    if (key === '[]') {\n      // consume all of the tags in the positional array\n      positionalArgs.forEach(valueForRef);\n    }\n\n    const parsed = convertToInt(key);\n\n    if (parsed !== null && parsed < positionalArgs.length) {\n      // consume the tag of the referenced index\n      valueForRef(positionalArgs[parsed]!);\n    }\n  });\n}\n\nclass NamedArgsProxy implements ProxyHandler<{}> {\n  declare set?: (target: {}, prop: string | number | symbol) => boolean;\n\n  constructor(private named: CapturedNamedArguments) {}\n\n  get(_target: {}, prop: string | number | symbol) {\n    const ref = this.named[prop as string];\n\n    if (ref !== undefined) {\n      return valueForRef(ref);\n    }\n  }\n\n  has(_target: {}, prop: string | number | symbol) {\n    return prop in this.named;\n  }\n\n  ownKeys() {\n    return Object.keys(this.named);\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  getOwnPropertyDescriptor(_target: {}, prop: string | number | symbol) {\n    if (import.meta.env.DEV && !(prop in this.named)) {\n      throw new Error(\n        `args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \\`${String(\n          prop\n        )}\\``\n      );\n    }\n\n    return {\n      enumerable: true,\n      configurable: true,\n    };\n  }\n}\n\nclass PositionalArgsProxy implements ProxyHandler<[]> {\n  declare set?: (target: [], prop: string | number | symbol) => boolean;\n  declare ownKeys?: (target: []) => string[];\n\n  constructor(private positional: CapturedPositionalArguments) {}\n\n  get(target: [], prop: string | number | symbol) {\n    let { positional } = this;\n\n    if (prop === 'length') {\n      return positional.length;\n    }\n\n    const parsed = convertToInt(prop);\n\n    if (parsed !== null && parsed < positional.length) {\n      return valueForRef(positional[parsed]!);\n    }\n\n    return (target as any)[prop];\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  has(_target: [], prop: string | number | symbol) {\n    const parsed = convertToInt(prop);\n\n    return parsed !== null && parsed < this.positional.length;\n  }\n}\n\nexport const argsProxyFor = (\n  capturedArgs: CapturedArguments,\n  type: 'component' | 'helper' | 'modifier'\n): Arguments => {\n  const { named, positional } = capturedArgs;\n\n  let getNamedTag = (_obj: object, key: string) => tagForNamedArg(named, key);\n  let getPositionalTag = (_obj: object, key: string) => tagForPositionalArg(positional, key);\n\n  const namedHandler = new NamedArgsProxy(named);\n  const positionalHandler = new PositionalArgsProxy(positional);\n\n  const namedTarget = Object.create(null);\n  const positionalTarget: unknown[] = [];\n\n  if (import.meta.env.DEV) {\n    const setHandler = function (_target: unknown, prop: symbol | string | number): never {\n      throw new Error(\n        `You attempted to set ${String(\n          prop\n        )} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`\n      );\n    };\n\n    const forInDebugHandler = (): never => {\n      throw new Error(\n        `Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`\n      );\n    };\n\n    namedHandler.set = setHandler;\n    positionalHandler.set = setHandler;\n    positionalHandler.ownKeys = forInDebugHandler;\n  }\n\n  const namedProxy = new Proxy(namedTarget, namedHandler);\n  const positionalProxy = new Proxy(positionalTarget, positionalHandler);\n\n  setCustomTagFor(namedProxy, getNamedTag);\n  setCustomTagFor(positionalProxy, getPositionalTag);\n\n  return {\n    named: namedProxy,\n    positional: positionalProxy,\n  };\n};\n","import { check, CheckNumber } from '@glimmer/debug';\nimport type {\n  AttributeHookCapability,\n  Capabilities,\n  CapabilityMask,\n  CreateArgsCapability,\n  CreateCallerCapability,\n  CreateInstanceCapability,\n  DynamicLayoutCapability,\n  DynamicScopeCapability,\n  DynamicTagCapability,\n  ElementHookCapability,\n  Expand,\n  HasSubOwnerCapability,\n  InternalComponentCapability,\n  InternalComponentManager,\n  PrepareArgsCapability,\n  UpdateHookCapability,\n  WillDestroyCapability,\n  WithCreateInstance,\n  WithDynamicLayout,\n  WithPrepareArgs,\n  WithSubOwner,\n  WithUpdateHook,\n  WrappedCapability,\n} from '@glimmer/interfaces';\nimport { InternalComponentCapabilities } from '@glimmer/vm';\n\nexport const FROM_CAPABILITIES = import.meta.env.DEV ? new WeakSet() : undefined;\n\nexport function buildCapabilities<T extends object>(capabilities: T): T & Capabilities {\n  if (import.meta.env.DEV) {\n    FROM_CAPABILITIES!.add(capabilities);\n    Object.freeze(capabilities);\n  }\n\n  return capabilities as T & Capabilities;\n}\n\nconst EMPTY = InternalComponentCapabilities.Empty;\n\ntype CapabilityOptions = Expand<{\n  [P in keyof Omit<typeof InternalComponentCapabilities, 'Empty'>]?: boolean | undefined;\n}>;\n\n/**\n * Converts a ComponentCapabilities object into a 32-bit integer representation.\n */\nexport function capabilityFlagsFrom(capabilities: CapabilityOptions): CapabilityMask {\n  return (EMPTY |\n    capability(capabilities, 'dynamicLayout') |\n    capability(capabilities, 'dynamicTag') |\n    capability(capabilities, 'prepareArgs') |\n    capability(capabilities, 'createArgs') |\n    capability(capabilities, 'attributeHook') |\n    capability(capabilities, 'elementHook') |\n    capability(capabilities, 'dynamicScope') |\n    capability(capabilities, 'createCaller') |\n    capability(capabilities, 'updateHook') |\n    capability(capabilities, 'createInstance') |\n    capability(capabilities, 'wrapped') |\n    capability(capabilities, 'willDestroy') |\n    capability(capabilities, 'hasSubOwner')) as CapabilityMask;\n}\n\nfunction capability(\n  capabilities: CapabilityOptions,\n  capability: keyof CapabilityOptions\n): InternalComponentCapability {\n  return capabilities[capability] ? InternalComponentCapabilities[capability] : EMPTY;\n}\n\nexport type InternalComponentCapabilityFor<C extends InternalComponentCapability> =\n  C extends DynamicLayoutCapability\n    ? WithDynamicLayout\n    : C extends DynamicTagCapability\n    ? InternalComponentManager\n    : C extends PrepareArgsCapability\n    ? WithPrepareArgs\n    : C extends CreateArgsCapability\n    ? InternalComponentManager\n    : C extends AttributeHookCapability\n    ? InternalComponentManager\n    : C extends ElementHookCapability\n    ? InternalComponentManager\n    : C extends DynamicScopeCapability\n    ? InternalComponentManager\n    : C extends CreateCallerCapability\n    ? InternalComponentManager\n    : C extends UpdateHookCapability\n    ? WithUpdateHook\n    : C extends CreateInstanceCapability\n    ? WithCreateInstance\n    : C extends WrappedCapability\n    ? InternalComponentManager\n    : C extends WillDestroyCapability\n    ? InternalComponentManager\n    : C extends HasSubOwnerCapability\n    ? WithSubOwner\n    : never;\n\nexport function managerHasCapability<F extends InternalComponentCapability>(\n  _manager: InternalComponentManager,\n  capabilities: CapabilityMask,\n  capability: F\n): _manager is InternalComponentCapabilityFor<F> {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n\nexport function hasCapability(\n  capabilities: CapabilityMask,\n  capability: InternalComponentCapability\n): boolean {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n","import { associateDestroyableChild } from '@glimmer/destroyable';\nimport type {\n  Helper,\n  HelperCapabilities,\n  HelperCapabilitiesVersions,\n  HelperDefinitionState,\n  HelperManager,\n  HelperManagerWithDestroyable,\n  HelperManagerWithValue,\n  InternalHelperManager,\n  Owner,\n} from \"@glimmer/interfaces\";\nimport { createComputeRef, createConstRef, UNDEFINED_REFERENCE } from '@glimmer/reference';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\nimport type { ManagerFactory } from './index';\n\nexport function helperCapabilities<Version extends keyof HelperCapabilitiesVersions>(\n  managerAPI: Version,\n  options: Partial<HelperCapabilities> = {}\n): HelperCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.23') {\n    throw new Error('Invalid helper manager compatibility specified');\n  }\n\n  if (\n    import.meta.env.DEV &&\n    (!(options.hasValue || options.hasScheduledEffect) ||\n      (options.hasValue && options.hasScheduledEffect))\n  ) {\n    throw new Error(\n      'You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.'\n    );\n  }\n\n  if (import.meta.env.DEV && options.hasScheduledEffect) {\n    throw new Error(\n      'The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead'\n    );\n  }\n\n  return buildCapabilities({\n    hasValue: Boolean(options.hasValue),\n    hasDestroyable: Boolean(options.hasDestroyable),\n    hasScheduledEffect: Boolean(options.hasScheduledEffect),\n  });\n}\n\n////////////\n\nexport function hasValue(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithValue<unknown> {\n  return manager.capabilities.hasValue;\n}\n\nexport function hasDestroyable(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithDestroyable<unknown> {\n  return manager.capabilities.hasDestroyable;\n}\n\n////////////\n\nexport class CustomHelperManager<O extends Owner = Owner> implements InternalHelperManager<O> {\n  constructor(private factory: ManagerFactory<O | undefined, HelperManager<unknown>>) {}\n\n  private helperManagerDelegates = new WeakMap<O, HelperManager<unknown>>();\n  private undefinedDelegate: HelperManager<unknown> | null = null;\n\n  private getDelegateForOwner(owner: O) {\n    let delegate = this.helperManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom helper managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.23')\\` (imported via \\`import { capabilities } from '@ember/helper';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      this.helperManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  getDelegateFor(owner: O | undefined) {\n    if (owner === undefined) {\n      let { undefinedDelegate } = this;\n\n      if (undefinedDelegate === null) {\n        let { factory } = this;\n        this.undefinedDelegate = undefinedDelegate = factory(undefined);\n      }\n\n      return undefinedDelegate;\n    } else {\n      return this.getDelegateForOwner(owner);\n    }\n  }\n\n  getHelper(definition: HelperDefinitionState): Helper {\n    return (capturedArgs, owner) => {\n      let manager = this.getDelegateFor(owner as O | undefined);\n\n      const args = argsProxyFor(capturedArgs, 'helper');\n      const bucket = manager.createHelper(definition, args);\n\n      if (hasValue(manager)) {\n        let cache = createComputeRef(\n          () => (manager as HelperManagerWithValue<unknown>).getValue(bucket),\n          null,\n          import.meta.env.DEV && manager.getDebugName && manager.getDebugName(definition)\n        );\n\n        if (hasDestroyable(manager)) {\n          associateDestroyableChild(cache, manager.getDestroyable(bucket));\n        }\n\n        return cache;\n      } else if (hasDestroyable(manager)) {\n        let ref = createConstRef(\n          undefined,\n          import.meta.env.DEV && (manager.getDebugName?.(definition) ?? 'unknown helper')\n        );\n\n        associateDestroyableChild(ref, manager.getDestroyable(bucket));\n\n        return ref;\n      } else {\n        return UNDEFINED_REFERENCE;\n      }\n    };\n  }\n}\n","import type {\n  CapturedArguments as Arguments,\n  HelperCapabilities,\n  HelperManagerWithValue,\n} from \"@glimmer/interfaces\";\n\nimport { buildCapabilities } from '../util/capabilities';\n\ntype FnArgs<Args extends Arguments = Arguments> =\n  | [...Args['positional'], Args['named']]\n  | [...Args['positional']];\n\ntype AnyFunction = (...args: any[]) => unknown;\n\ninterface State {\n  fn: AnyFunction;\n  args: Arguments;\n}\n\nexport class FunctionHelperManager implements HelperManagerWithValue<State> {\n  capabilities = buildCapabilities({\n    hasValue: true,\n    hasDestroyable: false,\n    hasScheduledEffect: false,\n  }) as HelperCapabilities;\n\n  createHelper(fn: AnyFunction, args: Arguments): State {\n    return { fn, args };\n  }\n\n  getValue({ fn, args }: State): unknown {\n    if (Object.keys(args.named).length > 0) {\n      let argsForFn: FnArgs<Arguments> = [...args.positional, args.named];\n\n      return fn(...argsForFn);\n    }\n\n    return fn(...args.positional);\n  }\n\n  getDebugName(fn: AnyFunction): string {\n    if (fn.name) {\n      return `(helper function ${fn.name})`;\n    }\n\n    return '(anonymous helper function)';\n  }\n}\n","import type {\n  Helper,\n  InternalComponentManager,\n  InternalModifierManager,\n  Owner,\n} from \"@glimmer/interfaces\";\nimport { debugToString } from '@glimmer/util';\n\nimport { CustomHelperManager } from '../public/helper';\nimport { FunctionHelperManager } from './defaults';\n\ntype InternalManager =\n  | InternalComponentManager\n  | InternalModifierManager\n  | CustomHelperManager\n  | Helper;\n\nconst COMPONENT_MANAGERS = new WeakMap<object, InternalComponentManager>();\n\nconst MODIFIER_MANAGERS = new WeakMap<object, InternalModifierManager>();\n\nconst HELPER_MANAGERS = new WeakMap<object, CustomHelperManager | Helper>();\n\n///////////\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nfunction setManager<Def extends object>(\n  map: WeakMap<object, object>,\n  manager: object,\n  obj: Def\n): Def {\n  if (\n    import.meta.env.DEV &&\n    (typeof obj !== 'object' || obj === null) &&\n    typeof obj !== 'function'\n  ) {\n    throw new Error(\n      `Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${debugToString!(\n        obj\n      )}`\n    );\n  }\n\n  if (import.meta.env.DEV && map.has(obj)) {\n    throw new Error(\n      `Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${debugToString!(\n        obj\n      )}`\n    );\n  }\n\n  map.set(obj, manager);\n  return obj;\n}\n\nfunction getManager<M extends InternalManager>(\n  map: WeakMap<object, M>,\n  obj: object\n): M | undefined {\n  let pointer = obj;\n  while (pointer !== undefined && pointer !== null) {\n    const manager = map.get(pointer);\n\n    if (manager !== undefined) {\n      return manager;\n    }\n\n    pointer = getPrototypeOf(pointer);\n  }\n\n  return undefined;\n}\n\n///////////\n\nexport function setInternalModifierManager<T extends object>(\n  manager: InternalModifierManager,\n  definition: T\n): T {\n  return setManager(MODIFIER_MANAGERS, manager, definition);\n}\n\nexport function getInternalModifierManager(definition: object): InternalModifierManager;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalModifierManager | null;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional?: true | undefined\n): InternalModifierManager | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${definition}`\n    );\n  }\n\n  const manager = getManager(MODIFIER_MANAGERS, definition)!;\n\n  if (manager === undefined) {\n    if (isOptional === true) {\n      return null;\n    } else if (import.meta.env.DEV) {\n      throw new Error(\n        `Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n  }\n\n  return manager;\n}\n\nexport function setInternalHelperManager<T extends object, O extends Owner>(\n  manager: CustomHelperManager<O> | Helper<O>,\n  definition: T\n): T {\n  return setManager(HELPER_MANAGERS, manager, definition);\n}\n\nconst DEFAULT_MANAGER = new CustomHelperManager(() => new FunctionHelperManager());\n\nexport function getInternalHelperManager(definition: object): CustomHelperManager | Helper;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional: true | undefined\n): CustomHelperManager | Helper | null;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional?: true | undefined\n): CustomHelperManager | Helper | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${definition}`\n    );\n  }\n\n  let manager = getManager(HELPER_MANAGERS, definition);\n\n  // Functions are special-cased because functions are defined\n  // as the \"default\" helper, per: https://github.com/emberjs/rfcs/pull/756\n  if (manager === undefined && typeof definition === 'function') {\n    manager = DEFAULT_MANAGER;\n  }\n\n  if (manager) {\n    return manager;\n  } else if (isOptional === true) {\n    return null;\n  } else if (import.meta.env.DEV) {\n    throw new Error(\n      `Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${debugToString!(\n        definition\n      )}`\n    );\n  }\n\n  return null;\n}\n\nexport function setInternalComponentManager<T extends object>(\n  factory: InternalComponentManager,\n  obj: T\n): T {\n  return setManager(COMPONENT_MANAGERS, factory, obj);\n}\n\nexport function getInternalComponentManager(definition: object): InternalComponentManager;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalComponentManager | null;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional?: true | undefined\n): InternalComponentManager | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${definition}`\n    );\n  }\n\n  const manager = getManager(COMPONENT_MANAGERS, definition)!;\n\n  if (manager === undefined) {\n    if (isOptional === true) {\n      return null;\n    } else if (import.meta.env.DEV) {\n      throw new Error(\n        `Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n  }\n\n  return manager;\n}\n\n///////////\n\nexport function hasInternalComponentManager(definition: object): boolean {\n  return (\n    hasDefaultComponentManager(definition) ||\n    getManager(COMPONENT_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalHelperManager(definition: object): boolean {\n  return (\n    hasDefaultHelperManager(definition) || getManager(HELPER_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalModifierManager(definition: object): boolean {\n  return (\n    hasDefaultModifierManager(definition) || getManager(MODIFIER_MANAGERS, definition) !== undefined\n  );\n}\n\nfunction hasDefaultComponentManager(_definition: object): boolean {\n  return false;\n}\n\nfunction hasDefaultHelperManager(definition: object): boolean {\n  return typeof definition === 'function';\n}\n\nfunction hasDefaultModifierManager(_definition: object): boolean {\n  return false;\n}\n","import { registerDestructor } from '@glimmer/destroyable';\nimport type {\n  Arguments,\n  ComponentCapabilities,\n  ComponentCapabilitiesVersions,\n  ComponentDefinitionState,\n  ComponentManager,\n  ComponentManagerWithAsyncLifeCycleCallbacks,\n  ComponentManagerWithAsyncUpdateHook,\n  ComponentManagerWithDestructors,\n  ComponentManagerWithUpdateHook,\n  Destroyable,\n  InternalComponentCapabilities,\n  InternalComponentManager,\n  Nullable,\n  Owner,\n  VMArguments,\n} from \"@glimmer/interfaces\";\nimport { createConstRef, type Reference } from '@glimmer/reference';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\nimport type { ManagerFactory } from './api';\n\nconst CAPABILITIES = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  createCaller: false,\n  dynamicScope: true,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport function componentCapabilities<Version extends keyof ComponentCapabilitiesVersions>(\n  managerAPI: Version,\n  options: ComponentCapabilitiesVersions[Version] = {}\n): ComponentCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.13') {\n    throw new Error('Invalid component manager compatibility specified');\n  }\n\n  let updateHook = Boolean((options as ComponentCapabilitiesVersions['3.13']).updateHook);\n\n  return buildCapabilities({\n    asyncLifeCycleCallbacks: Boolean(options.asyncLifecycleCallbacks),\n    destructor: Boolean(options.destructor),\n    updateHook,\n  });\n}\n\nexport function hasAsyncLifeCycleCallbacks<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncLifeCycleCallbacks<ComponentInstance> {\n  return delegate.capabilities.asyncLifeCycleCallbacks;\n}\n\nexport function hasUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithUpdateHook<ComponentInstance> {\n  return delegate.capabilities.updateHook;\n}\n\nexport function hasAsyncUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncUpdateHook<ComponentInstance> {\n  return hasAsyncLifeCycleCallbacks(delegate) && hasUpdateHook(delegate);\n}\n\nexport function hasDestructors<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithDestructors<ComponentInstance> {\n  return delegate.capabilities.destructor;\n}\n\n/**\n  The CustomComponentManager allows addons to provide custom component\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom component manager, which\n  implements a set of hooks that determine component behavior.\n\n  To create a custom component manager, instantiate a new CustomComponentManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomComponentManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a component, the component manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n\n  * `create()` - invoked when a new instance of a component should be created\n  * `update()` - invoked when the arguments passed to a component change\n  * `getContext()` - returns the object that should be\n*/\nexport class CustomComponentManager<O extends Owner, ComponentInstance>\n  implements InternalComponentManager<CustomComponentState<ComponentInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ComponentManager<ComponentInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ComponentManager<ComponentInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom component managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.13')\\` (imported via \\`import { capabilities } from '@ember/component';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(\n    owner: O,\n    definition: ComponentDefinitionState,\n    vmArgs: VMArguments\n  ): CustomComponentState<ComponentInstance> {\n    let delegate = this.getDelegateFor(owner);\n    let args = argsProxyFor(vmArgs.capture(), 'component');\n\n    let component: ComponentInstance = delegate.createComponent(definition, args);\n\n    return new CustomComponentState(component, delegate, args);\n  }\n\n  getDebugName(definition: ComponentDefinitionState): string {\n    return typeof definition === 'function' ? definition.name : definition.toString();\n  }\n\n  update(bucket: CustomComponentState<ComponentInstance>): void {\n    let { delegate } = bucket;\n    if (hasUpdateHook(delegate)) {\n      let { component, args } = bucket;\n\n      delegate.updateComponent(component, args);\n    }\n  }\n\n  didCreate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncLifeCycleCallbacks(delegate)) {\n      delegate.didCreateComponent(component);\n    }\n  }\n\n  didUpdate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncUpdateHook(delegate)) {\n      delegate.didUpdateComponent(component);\n    }\n  }\n\n  didRenderLayout(): void {}\n\n  didUpdateLayout(): void {}\n\n  getSelf({ component, delegate }: CustomComponentState<ComponentInstance>): Reference {\n    return createConstRef(delegate.getContext(component), 'this');\n  }\n\n  getDestroyable(bucket: CustomComponentState<ComponentInstance>): Nullable<Destroyable> {\n    const { delegate } = bucket;\n\n    if (hasDestructors(delegate)) {\n      const { component } = bucket;\n\n      registerDestructor(bucket, () => delegate.destroyComponent(component));\n      return bucket;\n    }\n\n    return null;\n  }\n\n  getCapabilities(): InternalComponentCapabilities {\n    return CAPABILITIES;\n  }\n}\n\n/**\n * Stores internal state about a component instance after it's been created.\n */\nexport class CustomComponentState<ComponentInstance> {\n  constructor(\n    public component: ComponentInstance,\n    public delegate: ComponentManager<ComponentInstance>,\n    public args: Arguments\n  ) {}\n}\n","import { registerDestructor } from '@glimmer/destroyable';\nimport type {\n  Arguments,\n  CapturedArguments,\n  InternalModifierManager,\n  ModifierCapabilities,\n  ModifierCapabilitiesVersions,\n  ModifierManager,\n  Owner,\n  SimpleElement,\n  UpdatableTag,\n} from '@glimmer/interfaces';\nimport { valueForRef } from '@glimmer/reference';\nimport { castToBrowser, dict } from '@glimmer/util';\nimport { createUpdatableTag, untrack } from '@glimmer/validator';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\nimport type { ManagerFactory } from '.';\n\nexport function modifierCapabilities<Version extends keyof ModifierCapabilitiesVersions>(\n  managerAPI: Version,\n  optionalFeatures: ModifierCapabilitiesVersions[Version] = {}\n): ModifierCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.22') {\n    throw new Error('Invalid modifier manager compatibility specified');\n  }\n\n  return buildCapabilities({\n    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking),\n  });\n}\n\nexport interface CustomModifierState<ModifierInstance> {\n  tag: UpdatableTag;\n  element: SimpleElement;\n  modifier: ModifierInstance;\n  delegate: ModifierManager<ModifierInstance>;\n  args: Arguments;\n  debugName?: string;\n}\n\n/**\n  The CustomModifierManager allows addons to provide custom modifier\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom modifier manager, which\n  implements a set of hooks that determine modifier behavior.\n  To create a custom modifier manager, instantiate a new CustomModifierManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomModifierManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a modifier, the modifier manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n  * `createModifier()` - invoked when a new instance of a modifier should be created\n  * `installModifier()` - invoked when the modifier is installed on the element\n  * `updateModifier()` - invoked when the arguments passed to a modifier change\n  * `destroyModifier()` - invoked when the modifier is about to be destroyed\n*/\nexport class CustomModifierManager<O extends Owner, ModifierInstance>\n  implements InternalModifierManager<CustomModifierState<ModifierInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ModifierManager<ModifierInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ModifierManager<ModifierInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom modifier managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.22')\\` (imported via \\`import { capabilities } from '@ember/modifier';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(owner: O, element: SimpleElement, definition: object, capturedArgs: CapturedArguments) {\n    let delegate = this.getDelegateFor(owner);\n\n    let args = argsProxyFor(capturedArgs, 'modifier');\n    let instance: ModifierInstance = delegate.createModifier(definition, args);\n\n    let tag = createUpdatableTag();\n    let state: CustomModifierState<ModifierInstance>;\n\n    state = {\n      tag,\n      element,\n      delegate,\n      args,\n      modifier: instance,\n    };\n\n    if (import.meta.env.DEV) {\n      state.debugName = typeof definition === 'function' ? definition.name : definition.toString();\n    }\n\n    registerDestructor(state, () => delegate.destroyModifier(instance, args));\n\n    return state;\n  }\n\n  getDebugName({ debugName }: CustomModifierState<ModifierInstance>) {\n    return debugName!;\n  }\n\n  getTag({ tag }: CustomModifierState<ModifierInstance>) {\n    return tag;\n  }\n\n  install({ element, args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking === true) {\n      untrack(() => delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args));\n    } else {\n      delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args);\n    }\n  }\n\n  update({ args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking === true) {\n      untrack(() => delegate.updateModifier(modifier, args));\n    } else {\n      delegate.updateModifier(modifier, args);\n    }\n  }\n\n  getDestroyable(state: CustomModifierState<ModifierInstance>) {\n    return state;\n  }\n}\n\nexport function reifyArgs({ named, positional }: CapturedArguments): {\n  named: Record<string, unknown>;\n  positional: unknown[];\n} {\n  let reifiedNamed = dict();\n\n  for (const [key, value] of Object.entries(named)) {\n    reifiedNamed[key] = valueForRef(value);\n  }\n\n  let reifiedPositional = positional.map(valueForRef);\n\n  return {\n    named: reifiedNamed,\n    positional: reifiedPositional,\n  };\n}\n","import type { ComponentManager, HelperManager, ModifierManager, Owner } from \"@glimmer/interfaces\";\n\nimport {\n  setInternalComponentManager,\n  setInternalHelperManager,\n  setInternalModifierManager,\n} from '../internal/api';\nimport { CustomComponentManager } from './component';\nimport { CustomHelperManager } from './helper';\nimport { CustomModifierManager } from './modifier';\n\ntype Manager = ComponentManager<unknown> | ModifierManager<unknown> | HelperManager<unknown>;\n\nexport type ManagerFactory<O, D extends Manager = Manager> = (owner: O) => D;\n\nexport function setComponentManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ComponentManager<unknown>>,\n  obj: T\n): T {\n  return setInternalComponentManager(new CustomComponentManager(factory), obj);\n}\n\nexport function setModifierManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ModifierManager<unknown>>,\n  obj: T\n): T {\n  return setInternalModifierManager(new CustomModifierManager(factory), obj);\n}\n\nexport function setHelperManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O | undefined, HelperManager<unknown>>,\n  obj: T\n): T {\n  return setInternalHelperManager(new CustomHelperManager(factory), obj);\n}\n","import type { TemplateFactory } from \"@glimmer/interfaces\";\nimport { debugToString } from '@glimmer/util';\n\nconst TEMPLATES: WeakMap<object, TemplateFactory> = new WeakMap();\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nexport function setComponentTemplate(factory: TemplateFactory, obj: object) {\n  if (\n    import.meta.env.DEV &&\n    !(obj !== null && (typeof obj === 'object' || typeof obj === 'function'))\n  ) {\n    throw new Error(`Cannot call \\`setComponentTemplate\\` on \\`${debugToString!(obj)}\\``);\n  }\n\n  if (import.meta.env.DEV && TEMPLATES.has(obj)) {\n    throw new Error(\n      `Cannot call \\`setComponentTemplate\\` multiple times on the same class (\\`${debugToString!(\n        obj\n      )}\\`)`\n    );\n  }\n\n  TEMPLATES.set(obj, factory);\n\n  return obj;\n}\n\nexport function getComponentTemplate(obj: object): TemplateFactory | undefined {\n  let pointer = obj;\n\n  while (pointer !== null) {\n    let template = TEMPLATES.get(pointer);\n\n    if (template !== undefined) {\n      return template;\n    }\n\n    pointer = getPrototypeOf(pointer);\n  }\n\n  return undefined;\n}\n"],"names":["CUSTOM_TAG_FOR","WeakMap","getCustomTagFor","obj","get","setCustomTagFor","customTagFn","set","convertToInt","prop","num","Number","isNaN","NamedArgsProxy","constructor","named","this","_target","ref","undefined","valueForRef","has","ownKeys","Object","keys","isExtensible","getOwnPropertyDescriptor","Error","String","enumerable","configurable","PositionalArgsProxy","positional","target","length","parsed","argsProxyFor","capturedArgs","type","namedHandler","positionalHandler","namedTarget","create","setHandler","forInDebugHandler","namedProxy","Proxy","positionalProxy","getNamedTag","_obj","key","namedArgs","track","tagForNamedArg","getPositionalTag","positionalArgs","forEach","tagForPositionalArg","FROM_CAPABILITIES","WeakSet","buildCapabilities","capabilities","add","freeze","EMPTY","InternalComponentCapabilities","Empty","capabilityFlagsFrom","capability","managerHasCapability","_manager","check","CheckNumber","hasCapability","helperCapabilities","managerAPI","options","arguments","hasValue","hasScheduledEffect","Boolean","hasDestroyable","manager","CustomHelperManager","factory","helperManagerDelegates","undefinedDelegate","getDelegateForOwner","owner","delegate","JSON","stringify","getDelegateFor","getHelper","definition","args","bucket","createHelper","cache","createComputeRef","getValue","getDebugName","associateDestroyableChild","getDestroyable","createConstRef","UNDEFINED_REFERENCE","FunctionHelperManager","fn","_ref","name","COMPONENT_MANAGERS","MODIFIER_MANAGERS","HELPER_MANAGERS","getPrototypeOf","setManager","map","debugToString","getManager","pointer","setInternalModifierManager","getInternalModifierManager","isOptional","setInternalHelperManager","DEFAULT_MANAGER","getInternalHelperManager","setInternalComponentManager","getInternalComponentManager","hasInternalComponentManager","hasInternalHelperManager","hasDefaultHelperManager","hasInternalModifierManager","CAPABILITIES","dynamicLayout","dynamicTag","prepareArgs","createArgs","attributeHook","elementHook","createCaller","dynamicScope","updateHook","createInstance","wrapped","willDestroy","hasSubOwner","componentCapabilities","asyncLifeCycleCallbacks","asyncLifecycleCallbacks","destructor","hasAsyncLifeCycleCallbacks","hasUpdateHook","CustomComponentManager","componentManagerDelegates","vmArgs","capture","component","createComponent","CustomComponentState","toString","update","updateComponent","didCreate","didCreateComponent","didUpdate","_ref2","hasAsyncUpdateHook","didUpdateComponent","didRenderLayout","didUpdateLayout","getSelf","_ref3","getContext","hasDestructors","registerDestructor","destroyComponent","getCapabilities","modifierCapabilities","optionalFeatures","disableAutoTracking","CustomModifierManager","element","state","instance","createModifier","tag","createUpdatableTag","modifier","debugName","destroyModifier","getTag","install","untrack","installModifier","castToBrowser","_ref4","updateModifier","setComponentManager","setModifierManager","setHelperManager","TEMPLATES","setComponentTemplate","getComponentTemplate","template"],"mappings":"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"}
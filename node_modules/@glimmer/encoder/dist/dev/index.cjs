'use strict';

var env = require('@glimmer/env');
var vm = require('@glimmer/vm');

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

class InstructionEncoderImpl {
  constructor(buffer) {
    _defineProperty(this, "size", 0);
    this.buffer = buffer;
  }
  encode(type, machine) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    if (type > vm.TYPE_SIZE) {
      throw new Error(`Opcode type over 8-bits. Got ${type}.`);
    }
    let first = type | machine | arguments.length - 2 << vm.ARG_SHIFT;
    this.buffer.push(first);
    for (const op of args) {
      if (env.DEBUG && typeof op === 'number' && op > vm.MAX_SIZE) {
        throw new Error(`Operand over 32-bits. Got ${op}.`);
      }
      this.buffer.push(op);
    }
    this.size = this.buffer.length;
  }
  patch(position, target) {
    if (this.buffer[position + 1] === -1) {
      this.buffer[position + 1] = target;
    } else {
      throw new Error('Trying to patch operand in populated slot instead of a reserved slot.');
    }
  }
}

exports.InstructionEncoderImpl = InstructionEncoderImpl;
//# sourceMappingURL=index.cjs.map

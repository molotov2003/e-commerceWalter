import{TYPE_SIZE as r,MAX_SIZE as e,ARG_SHIFT as t}from"@glimmer/vm";class o{constructor(r){this.buffer=r}size=0;encode(o,f){for(var s=arguments.length,i=new Array(s>2?s-2:0),h=2;h<s;h++)i[h-2]=arguments[h];if(o>r)throw new Error(`Opcode type over 8-bits. Got ${o}.`);let n=o|f|arguments.length-2<<t;this.buffer.push(n);for(const r of i){if("number"==typeof r&&r>e)throw new Error(`Operand over 32-bits. Got ${r}.`);this.buffer.push(r)}this.size=this.buffer.length}patch(r,e){if(-1!==this.buffer[r+1])throw new Error("Trying to patch operand in populated slot instead of a reserved slot.");this.buffer[r+1]=e}}export{o as InstructionEncoderImpl};
//# sourceMappingURL=index.js.map

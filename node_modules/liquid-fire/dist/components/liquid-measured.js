import { a as _applyDecoratedDescriptor, b as _initializerDefineProperty } from '../_rollupPluginBabelHelpers-241f4bb8.js';
import { setComponentTemplate } from '@ember/component';
import { precompileTemplate } from '@ember/template-compilation';
import { bind, next, throttle } from '@ember/runloop';
import { inject } from '@ember/service';
import Component from '@glimmer/component';
import 'rsvp';
import '@ember/application';
import '@ember/string';
import '../animate.js';
import '@ember/array';
import '@ember/object/internals';
import '../constraints.js';
import MutationObserver from '../mutation-observer.js';
import '../velocity-ext.js';
import { action } from '@ember/object';
import { measure } from '../utils/animate.js';

var TEMPLATE = precompileTemplate("<div\r\n	{{did-insert this.setup}}\r\n	{{will-destroy this.destroyElement}}\r\n>\r\n	{{yield}}\r\n</div>\r\n");

var _dec, _class, _descriptor;
const WINDOW_RESIZE_THROTTLE_DURATION = 100;
let LiquidMeasuredComponent = (_dec = inject('liquid-fire-transitions'), (_class = class LiquidMeasuredComponent extends Component {
  constructor() {
    super(...arguments);

    // this._destroyOnUnload = bind(this, this._destroyOnUnload);
    _initializerDefineProperty(this, "transitionMap", _descriptor, this);
  }
  setup(element) {
    this.element = element;
    const self = this;

    // This prevents margin collapse
    this.element.style.overflow = 'auto';
    this.didMutate();
    this.observer = new MutationObserver(function (mutations) {
      self.didMutate(mutations);
    });
    this.observer.observe(this.element, {
      attributes: true,
      subtree: true,
      childList: true,
      characterData: true
    });
    this.windowResizeHandler = bind(this, this.windowDidResize);
    window.addEventListener('resize', this.windowResizeHandler);
    this.element.addEventListener('webkitTransitionEnd', function () {
      self.didMutate();
    });
    // Chrome Memory Leak: https://bugs.webkit.org/show_bug.cgi?id=93661
    // window.addEventListener('unload', this._destroyOnUnload);
  }

  destroyElement() {
    if (this.observer) {
      this.observer.disconnect();
    }
    window.removeEventListener('resize', this.windowResizeHandler);
    // window.removeEventListener('unload', this._destroyOnUnload);
  }

  didMutate() {
    // by incrementing the running transitions counter here we prevent
    // tests from falling through the gap between the time they
    // triggered mutation the time we may actually animate in
    // response.
    const tmap = this.transitionMap;
    tmap.incrementRunningTransitions();
    next(this, function () {
      this._didMutate();
      tmap.decrementRunningTransitions();
    });
  }
  windowDidResize() {
    throttle(this, this.didMutate, WINDOW_RESIZE_THROTTLE_DURATION);
  }
  _didMutate() {
    if (!this.element) {
      return;
    }
    this.args.didMeasure(measure(this.element));
  }

  // _destroyOnUnload() {
  //   this.willDestroyElement();
  // }
}, (_applyDecoratedDescriptor(_class.prototype, "setup", [action], Object.getOwnPropertyDescriptor(_class.prototype, "setup"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroyElement", [action], Object.getOwnPropertyDescriptor(_class.prototype, "destroyElement"), _class.prototype), _descriptor = _applyDecoratedDescriptor(_class.prototype, "transitionMap", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class));
setComponentTemplate(TEMPLATE, LiquidMeasuredComponent);

export { LiquidMeasuredComponent as default };
//# sourceMappingURL=liquid-measured.js.map

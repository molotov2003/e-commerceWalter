{"version":3,"file":"constraint.js","sources":["../src/constraint.js"],"sourcesContent":["import { guidFor } from '@ember/object/internals';\r\nimport { isArray, A } from '@ember/array';\r\nimport constrainables from './constrainables';\r\n\r\n// Every rule constraint has a target and either `keys` or\r\n// `predicate`. key-based constraints are cheaper because we can check\r\n// them with O(1) lookups, whereas predicates must be searched O(n).\r\nexport default class Constraint {\r\n  constructor(target, matcher) {\r\n    // targets are the properties of a transition that we can\r\n    // constrain\r\n    this.target = target;\r\n    if (arguments.length === 1) {\r\n      return;\r\n    }\r\n    if (matcher instanceof RegExp) {\r\n      this.predicate = function (value) {\r\n        return matcher.test(value);\r\n      };\r\n    } else if (typeof matcher === 'function') {\r\n      this.predicate = matcher;\r\n    } else if (typeof matcher === 'boolean') {\r\n      this.predicate = function (value) {\r\n        return matcher ? value : !value;\r\n      };\r\n    } else {\r\n      this.keys = constraintKeys(matcher);\r\n    }\r\n  }\r\n\r\n  invert() {\r\n    if (!constrainables[this.target].reversesTo) {\r\n      return this;\r\n    }\r\n    const inverse = new this.constructor(\r\n      constrainables[this.target].reversesTo,\r\n    );\r\n    inverse.predicate = this.predicate;\r\n    inverse.keys = this.keys;\r\n    return inverse;\r\n  }\r\n}\r\n\r\nexport const EMPTY = '__liquid_fire_EMPTY__';\r\nexport const ANY = '__liquid_fire_ANY__';\r\n\r\nexport function constraintKeys(matcher) {\r\n  if (typeof matcher === 'undefined' || matcher === null) {\r\n    matcher = [EMPTY];\r\n  } else if (!isArray(matcher)) {\r\n    matcher = [matcher];\r\n  }\r\n  return A(matcher).map((elt) => {\r\n    if (typeof elt === 'string') {\r\n      return elt;\r\n    } else {\r\n      return guidFor(elt);\r\n    }\r\n  });\r\n}\r\n"],"names":["Constraint","constructor","target","matcher","arguments","length","RegExp","predicate","value","test","keys","constraintKeys","invert","constrainables","reversesTo","inverse","EMPTY","ANY","isArray","A","map","elt","guidFor"],"mappings":";;;;AAIA;AACA;AACA;AACe,MAAMA,UAAU,CAAC;AAC9BC,EAAAA,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAE;AAC3B;AACA;IACA,IAAI,CAACD,MAAM,GAAGA,MAAM,CAAA;AACpB,IAAA,IAAIE,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;AAC1B,MAAA,OAAA;AACF,KAAA;IACA,IAAIF,OAAO,YAAYG,MAAM,EAAE;AAC7B,MAAA,IAAI,CAACC,SAAS,GAAG,UAAUC,KAAK,EAAE;AAChC,QAAA,OAAOL,OAAO,CAACM,IAAI,CAACD,KAAK,CAAC,CAAA;OAC3B,CAAA;AACH,KAAC,MAAM,IAAI,OAAOL,OAAO,KAAK,UAAU,EAAE;MACxC,IAAI,CAACI,SAAS,GAAGJ,OAAO,CAAA;AAC1B,KAAC,MAAM,IAAI,OAAOA,OAAO,KAAK,SAAS,EAAE;AACvC,MAAA,IAAI,CAACI,SAAS,GAAG,UAAUC,KAAK,EAAE;AAChC,QAAA,OAAOL,OAAO,GAAGK,KAAK,GAAG,CAACA,KAAK,CAAA;OAChC,CAAA;AACH,KAAC,MAAM;AACL,MAAA,IAAI,CAACE,IAAI,GAAGC,cAAc,CAACR,OAAO,CAAC,CAAA;AACrC,KAAA;AACF,GAAA;AAEAS,EAAAA,MAAMA,GAAG;IACP,IAAI,CAACC,cAAc,CAAC,IAAI,CAACX,MAAM,CAAC,CAACY,UAAU,EAAE;AAC3C,MAAA,OAAO,IAAI,CAAA;AACb,KAAA;AACA,IAAA,MAAMC,OAAO,GAAG,IAAI,IAAI,CAACd,WAAW,CAClCY,cAAc,CAAC,IAAI,CAACX,MAAM,CAAC,CAACY,UAC9B,CAAC,CAAA;AACDC,IAAAA,OAAO,CAACR,SAAS,GAAG,IAAI,CAACA,SAAS,CAAA;AAClCQ,IAAAA,OAAO,CAACL,IAAI,GAAG,IAAI,CAACA,IAAI,CAAA;AACxB,IAAA,OAAOK,OAAO,CAAA;AAChB,GAAA;AACF,CAAA;AAEO,MAAMC,KAAK,GAAG,wBAAuB;AACrC,MAAMC,GAAG,GAAG,sBAAqB;AAEjC,SAASN,cAAcA,CAACR,OAAO,EAAE;EACtC,IAAI,OAAOA,OAAO,KAAK,WAAW,IAAIA,OAAO,KAAK,IAAI,EAAE;IACtDA,OAAO,GAAG,CAACa,KAAK,CAAC,CAAA;AACnB,GAAC,MAAM,IAAI,CAACE,OAAO,CAACf,OAAO,CAAC,EAAE;IAC5BA,OAAO,GAAG,CAACA,OAAO,CAAC,CAAA;AACrB,GAAA;EACA,OAAOgB,CAAC,CAAChB,OAAO,CAAC,CAACiB,GAAG,CAAEC,GAAG,IAAK;AAC7B,IAAA,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;AAC3B,MAAA,OAAOA,GAAG,CAAA;AACZ,KAAC,MAAM;MACL,OAAOC,OAAO,CAACD,GAAG,CAAC,CAAA;AACrB,KAAA;AACF,GAAC,CAAC,CAAA;AACJ;;;;"}